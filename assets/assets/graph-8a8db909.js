import { R as React, bx as useDoenetRenderer, r as reactExports, b as jsxs, F as Fragment, j as jsx, by as Context, bz as cesc } from "./PageViewer-d914b069.js";
import { s as sizeToCSS } from "./css-5483d03f.js";
import { V as VisibilitySensor } from "./visibility-sensor-57589aaf.js";
var __webpack_modules__ = { 351: (t, e, i2) => {
  i2.d(e, { Z: () => n });
  var s, r2 = i2(765), o = "1.5.1-dev";
  s = { version: o, licenseText: "JSXGraph v" + o + " Copyright (C) see https://jsxgraph.org", COORDS_BY_USER: 1, COORDS_BY_SCREEN: 2, OBJECT_TYPE_ARC: 1, OBJECT_TYPE_ARROW: 2, OBJECT_TYPE_AXIS: 3, OBJECT_TYPE_AXISPOINT: 4, OBJECT_TYPE_TICKS: 5, OBJECT_TYPE_CIRCLE: 6, OBJECT_TYPE_CONIC: 7, OBJECT_TYPE_CURVE: 8, OBJECT_TYPE_GLIDER: 9, OBJECT_TYPE_IMAGE: 10, OBJECT_TYPE_LINE: 11, OBJECT_TYPE_POINT: 12, OBJECT_TYPE_SLIDER: 13, OBJECT_TYPE_CAS: 14, OBJECT_TYPE_GXTCAS: 15, OBJECT_TYPE_POLYGON: 16, OBJECT_TYPE_SECTOR: 17, OBJECT_TYPE_TEXT: 18, OBJECT_TYPE_ANGLE: 19, OBJECT_TYPE_INTERSECTION: 20, OBJECT_TYPE_TURTLE: 21, OBJECT_TYPE_VECTOR: 22, OBJECT_TYPE_OPROJECT: 23, OBJECT_TYPE_GRID: 24, OBJECT_TYPE_TANGENT: 25, OBJECT_TYPE_HTMLSLIDER: 26, OBJECT_TYPE_CHECKBOX: 27, OBJECT_TYPE_INPUT: 28, OBJECT_TYPE_BUTTON: 29, OBJECT_TYPE_TRANSFORMATION: 30, OBJECT_TYPE_FOREIGNOBJECT: 31, OBJECT_TYPE_VIEW3D: 32, OBJECT_TYPE_POINT3D: 33, OBJECT_TYPE_LINE3D: 34, OBJECT_TYPE_PLANE3D: 35, OBJECT_TYPE_CURVE3D: 36, OBJECT_TYPE_SURFACE3D: 37, OBJECT_CLASS_POINT: 1, OBJECT_CLASS_LINE: 2, OBJECT_CLASS_CIRCLE: 3, OBJECT_CLASS_CURVE: 4, OBJECT_CLASS_AREA: 5, OBJECT_CLASS_OTHER: 6, OBJECT_CLASS_TEXT: 7, OBJECT_CLASS_3D: 8, GENTYPE_ABC: 1, GENTYPE_AXIS: 2, GENTYPE_MID: 3, GENTYPE_REFLECTION: 4, GENTYPE_MIRRORELEMENT: 5, GENTYPE_REFLECTION_ON_LINE: 4, GENTYPE_REFLECTION_ON_POINT: 5, GENTYPE_TANGENT: 6, GENTYPE_PARALLEL: 7, GENTYPE_BISECTORLINES: 8, GENTYPE_BOARDIMG: 9, GENTYPE_BISECTOR: 10, GENTYPE_NORMAL: 11, GENTYPE_POINT: 12, GENTYPE_GLIDER: 13, GENTYPE_INTERSECTION: 14, GENTYPE_CIRCLE: 15, GENTYPE_CIRCLE2POINTS: 16, GENTYPE_LINE: 17, GENTYPE_TRIANGLE: 18, GENTYPE_QUADRILATERAL: 19, GENTYPE_TEXT: 20, GENTYPE_POLYGON: 21, GENTYPE_REGULARPOLYGON: 22, GENTYPE_SECTOR: 23, GENTYPE_ANGLE: 24, GENTYPE_PLOT: 25, GENTYPE_SLIDER: 26, GENTYPE_TRUNCATE: 27, GENTYPE_JCODE: 28, GENTYPE_MOVEMENT: 29, GENTYPE_COMBINED: 30, GENTYPE_RULER: 31, GENTYPE_SLOPETRIANGLE: 32, GENTYPE_PERPSEGMENT: 33, GENTYPE_LABELMOVEMENT: 34, GENTYPE_VECTOR: 35, GENTYPE_NONREFLEXANGLE: 36, GENTYPE_REFLEXANGLE: 37, GENTYPE_PATH: 38, GENTYPE_DERIVATIVE: 39, GENTYPE_DELETE: 41, GENTYPE_COPY: 42, GENTYPE_MIRROR: 43, GENTYPE_ROTATE: 44, GENTYPE_ABLATION: 45, GENTYPE_MIGRATE: 46, GENTYPE_VECTORCOPY: 47, GENTYPE_POLYGONCOPY: 48, GENTYPE_CTX_TYPE_G: 51, GENTYPE_CTX_TYPE_P: 52, GENTYPE_CTX_TRACE: 53, GENTYPE_CTX_VISIBILITY: 54, GENTYPE_CTX_CCVISIBILITY: 55, GENTYPE_CTX_MPVISIBILITY: 56, GENTYPE_CTX_WITHLABEL: 57, GENTYPE_CTX_LABEL: 58, GENTYPE_CTX_FIXED: 59, GENTYPE_CTX_STROKEWIDTH: 60, GENTYPE_CTX_LABELSIZE: 61, GENTYPE_CTX_SIZE: 62, GENTYPE_CTX_FACE: 63, GENTYPE_CTX_STRAIGHT: 64, GENTYPE_CTX_ARROW: 65, GENTYPE_CTX_COLOR: 66, GENTYPE_CTX_RADIUS: 67, GENTYPE_CTX_COORDS: 68, GENTYPE_CTX_TEXT: 69, GENTYPE_CTX_ANGLERADIUS: 70, GENTYPE_CTX_DOTVISIBILITY: 71, GENTYPE_CTX_FILLOPACITY: 72, GENTYPE_CTX_PLOT: 73, GENTYPE_CTX_SCALE: 74, GENTYPE_CTX_INTVAL: 75, GENTYPE_CTX_POINT1: 76, GENTYPE_CTX_POINT2: 77, GENTYPE_CTX_LABELSTICKY: 78, GENTYPE_CTX_TYPE_I: 79, GENTYPE_CTX_HASINNERPOINTS: 80, GENTYPE_CTX_SNAPWIDTH: 81, GENTYPE_CTX_SNAPTOGRID: 82 }, r2.Z.extendConstants(r2.Z, s);
  const n = s;
}, 705: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(351), o = i2(88), n = i2(109), a = i2(275);
  s.Z.Coords = function(t2, e2, i3, s2) {
    this.board = i3, this.usrCoords = [], this.scrCoords = [], this.emitter = !n.Z.exists(s2) || s2, this.emitter && o.Z.eventify(this), this.setCoordinates(t2, e2, false, true);
  }, s.Z.extend(s.Z.Coords.prototype, { normalizeUsrCoords: function() {
    Math.abs(this.usrCoords[0]) > a.Z.eps && (this.usrCoords[1] /= this.usrCoords[0], this.usrCoords[2] /= this.usrCoords[0], this.usrCoords[0] = 1);
  }, usr2screen: function(t2) {
    var e2 = Math.round, i3 = this.board, s2 = this.usrCoords, r3 = i3.origin.scrCoords;
    true === t2 ? (this.scrCoords[0] = e2(s2[0]), this.scrCoords[1] = e2(s2[0] * r3[1] + s2[1] * i3.unitX), this.scrCoords[2] = e2(s2[0] * r3[2] - s2[2] * i3.unitY)) : (this.scrCoords[0] = s2[0], this.scrCoords[1] = s2[0] * r3[1] + s2[1] * i3.unitX, this.scrCoords[2] = s2[0] * r3[2] - s2[2] * i3.unitY);
  }, screen2usr: function() {
    var t2 = this.board.origin.scrCoords, e2 = this.scrCoords, i3 = this.board;
    this.usrCoords[0] = 1, this.usrCoords[1] = (e2[1] - t2[1]) / i3.unitX, this.usrCoords[2] = (t2[2] - e2[2]) / i3.unitY;
  }, distance: function(t2, e2) {
    var i3, s2, o2 = 0, n2 = this.usrCoords, h2 = this.scrCoords;
    if (t2 === r2.Z.COORDS_BY_USER) {
      if (i3 = e2.usrCoords, (o2 = (s2 = n2[0] - i3[0]) * s2) > a.Z.eps * a.Z.eps)
        return Number.POSITIVE_INFINITY;
      o2 += (s2 = n2[1] - i3[1]) * s2, o2 += (s2 = n2[2] - i3[2]) * s2;
    } else
      i3 = e2.scrCoords, o2 += (s2 = h2[1] - i3[1]) * s2, o2 += (s2 = h2[2] - i3[2]) * s2;
    return Math.sqrt(o2);
  }, setCoordinates: function(t2, e2, i3, s2) {
    var o2 = this.usrCoords, n2 = this.scrCoords, a2 = [o2[0], o2[1], o2[2]], h2 = [n2[0], n2[1], n2[2]];
    return t2 === r2.Z.COORDS_BY_USER ? (2 === e2.length ? (o2[0] = 1, o2[1] = e2[0], o2[2] = e2[1]) : (o2[0] = e2[0], o2[1] = e2[1], o2[2] = e2[2], this.normalizeUsrCoords()), this.usr2screen(i3)) : (2 === e2.length ? (n2[1] = e2[0], n2[2] = e2[1]) : (n2[1] = e2[1], n2[2] = e2[2]), this.screen2usr()), !this.emitter || s2 || h2[1] === n2[1] && h2[2] === n2[2] || this.triggerEventHandlers(["update"], [a2, h2]), this;
  }, copy: function(t2, e2) {
    return void 0 === e2 && (e2 = 0), this[t2].slice(e2);
  }, isReal: function() {
    return !isNaN(this.usrCoords[1] + this.usrCoords[2]) && Math.abs(this.usrCoords[0]) > a.Z.eps;
  }, __evt__update: function(t2, e2) {
  }, __evt: function() {
  } });
  const h = s.Z.Coords;
}, 218: (t, e, i2) => {
  i2.d(e, { Z: () => d });
  var s = i2(765), r2 = i2(275), o = i2(922), n = i2(336), a = i2(309), h = i2(705), l = i2(351), c = i2(109);
  s.Z.CoordsElement = function(t2, e2) {
    var i3;
    for (c.Z.exists(t2) || (t2 = [1, 0, 0]), i3 = 0; i3 < t2.length; ++i3)
      t2[i3] = parseFloat(t2[i3]);
    this.coords = new h.Z(l.Z.COORDS_BY_USER, t2, this.board), this.initialCoords = new h.Z(l.Z.COORDS_BY_USER, t2, this.board), this.position = null, this.isConstrained = false, this.onPolygon = false, this.slideObject = null, this.slideObjects = [], this.needsUpdateFromParent = true, this.groups = [], this.Xjc = null, this.Yjc = null, this.methodMap = c.Z.deepCopy(this.methodMap, { move: "moveTo", moveTo: "moveTo", moveAlong: "moveAlong", visit: "visit", glide: "makeGlider", makeGlider: "makeGlider", intersect: "makeIntersection", makeIntersection: "makeIntersection", X: "X", Y: "Y", free: "free", setPosition: "setGliderPosition", setGliderPosition: "setGliderPosition", addConstraint: "addConstraint", dist: "Dist", onPolygon: "onPolygon" }), c.Z.exists(this.element) && this.addAnchor(t2, e2), this.isDraggable = true;
  }, s.Z.extend(s.Z.CoordsElement.prototype, { updateConstraint: function() {
    return this;
  }, updateCoords: function(t2) {
    return this.needsUpdate ? (c.Z.exists(t2) || (t2 = false), c.Z.evaluate(this.visProp.frozen) || this.updateConstraint(), this.type === l.Z.OBJECT_TYPE_GLIDER && (this.isConstrained && (t2 = false), t2 ? this.updateGliderFromParent() : this.updateGlider()), this.updateTransform(t2), this) : this;
  }, updateGlider: function() {
    var t2, e2, i3, s2, n2, a2, d2, u, p, _, f, b, g, m, v, Z, C, y, P, E = 2 * Math.PI, O = false, x = this.slideObject, w = [];
    if (this.needsUpdateFromParent = false, x.elementClass === l.Z.OBJECT_CLASS_CIRCLE)
      c.Z.evaluate(this.visProp.isgeonext) && (E = 1), m = o.Z.projectPointToCircle(this, x, this.board), v = o.Z.rad([x.center.X() + 1, x.center.Y()], x.center, this) / E;
    else if (x.elementClass === l.Z.OBJECT_CLASS_LINE) {
      if (this.onPolygon) {
        if (e2 = x.point1.coords.usrCoords, s2 = (i3 = x.point2.coords.usrCoords)[t2 = 1] - e2[t2], Math.abs(s2) < r2.Z.eps && (s2 = i3[t2 = 2] - e2[t2]), d2 = (o.Z.projectPointToLine(this, x, this.board).usrCoords[t2] - e2[t2]) / s2, a2 = x.parentPolygon, d2 < 0) {
          for (t2 = 0; t2 < a2.borders.length; t2++)
            if (x === a2.borders[t2]) {
              x = a2.borders[(t2 - 1 + a2.borders.length) % a2.borders.length];
              break;
            }
        } else if (d2 > 1) {
          for (t2 = 0; t2 < a2.borders.length; t2++)
            if (x === a2.borders[t2]) {
              x = a2.borders[(t2 + 1 + a2.borders.length) % a2.borders.length];
              break;
            }
        }
        x.id !== this.slideObject.id && (this.slideObject = x);
      }
      e2 = x.point1.coords, i3 = x.point2.coords, (s2 = e2.distance(l.Z.COORDS_BY_USER, i3)) < r2.Z.eps ? (m = e2, O = true, v = 0) : (m = o.Z.projectPointToLine(this, x, this.board), e2 = e2.usrCoords.slice(0), i3 = i3.usrCoords.slice(0), Math.abs(i3[0]) < r2.Z.eps ? (s2 = i3[t2 = 1], Math.abs(s2) < r2.Z.eps && (s2 = i3[t2 = 2]), v = ((s2 = (m.usrCoords[t2] - e2[t2]) / s2) >= 0 ? 1 : -1) * (s2 = Math.abs(s2)) / (s2 + 1)) : Math.abs(e2[0]) < r2.Z.eps ? (s2 = e2[t2 = 1], Math.abs(s2) < r2.Z.eps && (s2 = e2[t2 = 2]), v = (s2 = (m.usrCoords[t2] - i3[t2]) / s2) < 0 ? (1 - 2 * s2) / (1 - s2) : 1 / (s2 + 1)) : (s2 = i3[t2 = 1] - e2[t2], Math.abs(s2) < r2.Z.eps && (s2 = i3[t2 = 2] - e2[t2]), v = (m.usrCoords[t2] - e2[t2]) / s2)), Z = c.Z.evaluate(this.visProp.snapwidth), c.Z.evaluate(Z) > 0 && Math.abs(this._smax - this._smin) >= r2.Z.eps && (n2 = (v = Math.max(Math.min(v, 1), 0)) * (this._smax - this._smin) + this._smin, v = ((n2 = Math.round(n2 / Z) * Z) - this._smin) / (this._smax - this._smin), this.update(true)), e2 = x.point1.coords, !c.Z.evaluate(x.visProp.straightfirst) && Math.abs(e2.usrCoords[0]) > r2.Z.eps && v < 0 && (m = e2, O = true, v = 0), i3 = x.point2.coords, !c.Z.evaluate(x.visProp.straightlast) && Math.abs(i3.usrCoords[0]) > r2.Z.eps && v > 1 && (m = i3, O = true, v = 1);
    } else if (x.type === l.Z.OBJECT_TYPE_TURTLE)
      this.updateConstraint(), m = (C = o.Z.projectPointToTurtle(this, x, this.board))[0], v = C[1];
    else if (x.elementClass === l.Z.OBJECT_CLASS_CURVE)
      if (x.type === l.Z.OBJECT_TYPE_ARC || x.type === l.Z.OBJECT_TYPE_SECTOR)
        m = o.Z.projectPointToCircle(this, x, this.board), _ = o.Z.rad(x.radiuspoint, x.center, this), u = 0, p = o.Z.rad(x.radiuspoint, x.center, x.anglepoint), v = _, ("minor" === (Z = c.Z.evaluate(x.visProp.selection)) && p > Math.PI || "major" === Z && p < Math.PI) && (u = p, p = 2 * Math.PI), (_ < u || _ > p) && (v = p, (_ < u && _ > 0.5 * u || _ > p && _ > 0.5 * p + Math.PI) && (v = u), this.needsUpdateFromParent = true, this.updateGliderFromParent()), E = p - u, this.visProp.isgeonext && (E = 1), Math.abs(E) > r2.Z.eps && (v /= E);
      else if (this.updateConstraint(), x.transformations.length > 0) {
        for (P = false, (C = x.getTransformationSource())[0] && (P = C[0], w.push(x), w.push(C[1])); C[0] && c.Z.exists(C[1]._transformationSource); )
          C = C[1].getTransformationSource(), w.push(C[1]);
        if (y = this.coords.usrCoords, P) {
          for (t2 = 0; t2 < w.length; t2++)
            w[t2].updateTransformMatrix(), g = r2.Z.inverse(w[t2].transformMat), y = r2.Z.matVecMult(g, y);
          for (f = new h.Z(l.Z.COORDS_BY_USER, y, this.board).usrCoords, y = (b = o.Z.projectCoordsToCurve(f[1], f[2], this.position || 0, w[w.length - 1], this.board))[0].usrCoords, t2 = w.length - 2; t2 >= 0; t2--)
            y = r2.Z.matVecMult(w[t2].transformMat, y);
          b[0] = new h.Z(l.Z.COORDS_BY_USER, y, this.board);
        } else
          x.updateTransformMatrix(), g = r2.Z.inverse(x.transformMat), y = r2.Z.matVecMult(g, y), f = new h.Z(l.Z.COORDS_BY_USER, y, this.board).usrCoords, b = o.Z.projectCoordsToCurve(f[1], f[2], this.position || 0, x, this.board);
        m = b[0], v = b[1];
      } else
        m = (C = o.Z.projectPointToCurve(this, x, this.board))[0], v = C[1];
    else
      c.Z.isPoint(x) && (m = o.Z.projectPointToPoint(this, x, this.board), v = this.position);
    this.coords.setCoordinates(l.Z.COORDS_BY_USER, m.usrCoords, O), this.position = v;
  }, updateGliderFromParent: function() {
    var t2, e2, i3, s2, n2, a2, d2, u, p, _, f, b, g = this.slideObject, m = [], v = 2 * Math.PI;
    if (this.needsUpdateFromParent) {
      if (g.elementClass === l.Z.OBJECT_CLASS_CIRCLE)
        i3 = g.Radius(), c.Z.evaluate(this.visProp.isgeonext) && (v = 1), n2 = [g.center.X() + i3 * Math.cos(this.position * v), g.center.Y() + i3 * Math.sin(this.position * v)];
      else if (g.elementClass === l.Z.OBJECT_CLASS_LINE)
        t2 = g.point1.coords.usrCoords, e2 = g.point2.coords.usrCoords, 0 === t2[0] && 0 === t2[1] && 0 === t2[2] || 0 === e2[0] && 0 === e2[1] && 0 === e2[2] ? n2 = [0, 0, 0] : Math.abs(e2[0]) < r2.Z.eps ? (s2 = Math.min(Math.abs(this.position), 1 - r2.Z.eps), s2 /= 1 - s2, this.position < 0 && (s2 = -s2), n2 = [t2[0] + s2 * e2[0], t2[1] + s2 * e2[1], t2[2] + s2 * e2[2]]) : Math.abs(t2[0]) < r2.Z.eps ? (s2 = Math.max(this.position, r2.Z.eps), s2 = (s2 = Math.min(s2, 2 - r2.Z.eps)) > 1 ? (s2 - 1) / (s2 - 2) : (1 - s2) / s2, n2 = [e2[0] + s2 * t2[0], e2[1] + s2 * t2[1], e2[2] + s2 * t2[2]]) : (s2 = this.position, n2 = [t2[0] + s2 * (e2[0] - t2[0]), t2[1] + s2 * (e2[1] - t2[1]), t2[2] + s2 * (e2[2] - t2[2])]);
      else if (g.type === l.Z.OBJECT_TYPE_TURTLE)
        this.coords.setCoordinates(l.Z.COORDS_BY_USER, [g.Z(this.position), g.X(this.position), g.Y(this.position)]), this.updateConstraint(), n2 = o.Z.projectPointToTurtle(this, g, this.board)[0].usrCoords;
      else if (g.elementClass === l.Z.OBJECT_CLASS_CURVE) {
        for (u = false, (a2 = g.getTransformationSource())[0] && (u = a2[0], m.push(g), m.push(a2[1])); a2[0] && c.Z.exists(a2[1]._transformationSource); )
          a2 = a2[1].getTransformationSource(), m.push(a2[1]);
        if (u ? this.coords.setCoordinates(l.Z.COORDS_BY_USER, [m[m.length - 1].Z(this.position), m[m.length - 1].X(this.position), m[m.length - 1].Y(this.position)]) : this.coords.setCoordinates(l.Z.COORDS_BY_USER, [g.Z(this.position), g.X(this.position), g.Y(this.position)]), g.type === l.Z.OBJECT_TYPE_ARC || g.type === l.Z.OBJECT_TYPE_SECTOR)
          p = o.Z.rad([g.center.X() + 1, g.center.Y()], g.center, g.radiuspoint), _ = 0, b = o.Z.rad(g.radiuspoint, g.center, g.anglepoint), ("minor" === g.visProp.selection && b > Math.PI || "major" === g.visProp.selection && b < Math.PI) && (_ = b, b = 2 * Math.PI), v = b - _, c.Z.evaluate(this.visProp.isgeonext) && (v = 1), ((f = this.position * v) < _ || f > b) && (((f = b) < _ && f > 0.5 * _ || f > b && f > 0.5 * b + Math.PI) && (f = _), this.position = f, Math.abs(v) > r2.Z.eps && (this.position /= v)), i3 = g.Radius(), n2 = [g.center.X() + i3 * Math.cos(this.position * v + p), g.center.Y() + i3 * Math.sin(this.position * v + p)];
        else if (this.updateConstraint(), u)
          for (n2 = o.Z.projectPointToCurve(this, m[m.length - 1], this.board)[0].usrCoords, d2 = m.length - 2; d2 >= 0; d2--)
            n2 = new h.Z(l.Z.COORDS_BY_USER, r2.Z.matVecMult(m[d2].transformMat, n2), this.board).usrCoords;
        else
          n2 = o.Z.projectPointToCurve(this, g, this.board)[0].usrCoords;
      } else
        c.Z.isPoint(g) && (n2 = o.Z.projectPointToPoint(this, g, this.board).usrCoords);
      this.coords.setCoordinates(l.Z.COORDS_BY_USER, n2, false);
    } else
      this.needsUpdateFromParent = true;
  }, updateRendererGeneric: function(t2) {
    return this.needsUpdate && this.board.renderer ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.coords.usrCoords[1] + this.coords.usrCoords[2]), this.isReal = Math.abs(this.coords.usrCoords[0]) > r2.Z.eps && this.isReal, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer[t2](this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
  }, X: function() {
    return this.coords.usrCoords[1];
  }, Y: function() {
    return this.coords.usrCoords[2];
  }, Z: function() {
    return this.coords.usrCoords[0];
  }, XEval: function() {
    return this.coords.usrCoords[1];
  }, YEval: function() {
    return this.coords.usrCoords[2];
  }, ZEval: function() {
    return this.coords.usrCoords[0];
  }, Dist: function(t2) {
    return this.isReal && t2.isReal ? this.coords.distance(l.Z.COORDS_BY_USER, t2.coords) : NaN;
  }, snapToGrid: function(t2) {
    return this.handleSnapToGrid(t2);
  }, handleSnapToPoints: function(t2) {
    var e2, i3, s2, r3, n2, a2, h2, d2, u = 0, p = 1 / 0, _ = null, f = c.Z.evaluate(this.visProp.ignoredsnaptopoints), b = false;
    if (r3 = this.board.objectsList.length, f && (h2 = f.length), c.Z.evaluate(this.visProp.snaptopoints) || t2) {
      for (n2 = c.Z.evaluate(this.visProp.attractorunit), a2 = c.Z.evaluate(this.visProp.attractordistance), e2 = 0; e2 < r3; e2++) {
        if (i3 = this.board.objectsList[e2], f) {
          for (b = false, d2 = 0; d2 < h2; d2++)
            if (i3 === this.board.select(f[d2])) {
              b = true;
              break;
            }
          if (b)
            continue;
        }
        c.Z.isPoint(i3) && i3 !== this && i3.visPropCalc.visible && (s2 = o.Z.projectPointToPoint(this, i3, this.board), (u = "screen" === n2 ? s2.distance(l.Z.COORDS_BY_SCREEN, this.coords) : s2.distance(l.Z.COORDS_BY_USER, this.coords)) < a2 && u < p && (p = u, _ = s2));
      }
      null !== _ && this.coords.setCoordinates(l.Z.COORDS_BY_USER, _.usrCoords);
    }
    return this;
  }, snapToPoints: function(t2) {
    return this.handleSnapToPoints(t2);
  }, handleAttractors: function() {
    var t2, e2, i3, s2, r3 = 0, n2 = c.Z.evaluate(this.visProp.attractorunit), a2 = c.Z.evaluate(this.visProp.attractordistance), d2 = c.Z.evaluate(this.visProp.snatchdistance), u = c.Z.evaluate(this.visProp.attractors), p = u.length;
    if (0 !== a2) {
      for (t2 = 0; t2 < p; t2++)
        if (e2 = this.board.select(u[t2]), c.Z.exists(e2) && e2 !== this) {
          if (c.Z.isPoint(e2) ? i3 = o.Z.projectPointToPoint(this, e2, this.board) : e2.elementClass === l.Z.OBJECT_CLASS_LINE ? (s2 = o.Z.projectCoordsToSegment(this.coords.usrCoords, e2.point1.coords.usrCoords, e2.point2.coords.usrCoords), i3 = !c.Z.evaluate(e2.visProp.straightfirst) && s2[1] < 0 ? e2.point1.coords : !c.Z.evaluate(e2.visProp.straightlast) && s2[1] > 1 ? e2.point2.coords : new h.Z(l.Z.COORDS_BY_USER, s2[0], this.board)) : e2.elementClass === l.Z.OBJECT_CLASS_CIRCLE ? i3 = o.Z.projectPointToCircle(this, e2, this.board) : e2.elementClass === l.Z.OBJECT_CLASS_CURVE ? i3 = o.Z.projectPointToCurve(this, e2, this.board)[0] : e2.type === l.Z.OBJECT_TYPE_TURTLE ? i3 = o.Z.projectPointToTurtle(this, e2, this.board)[0] : e2.type === l.Z.OBJECT_TYPE_POLYGON && (i3 = new h.Z(l.Z.COORDS_BY_USER, o.Z.projectCoordsToPolygon(this.coords.usrCoords, e2), this.board)), (r3 = "screen" === n2 ? i3.distance(l.Z.COORDS_BY_SCREEN, this.coords) : i3.distance(l.Z.COORDS_BY_USER, this.coords)) < a2) {
            this.type === l.Z.OBJECT_TYPE_GLIDER && (e2 === this.slideObject || this.slideObject && this.onPolygon && this.slideObject.parentPolygon === e2) || this.makeGlider(e2);
            break;
          }
          r3 >= d2 && (e2 === this.slideObject || this.slideObject && this.onPolygon && this.slideObject.parentPolygon === e2) && this.popSlideObject();
        }
      return this;
    }
  }, setPositionDirectly: function(t2, e2) {
    var i3, s2, o2, n2, d2 = this.coords;
    if (this.relativeCoords)
      return s2 = new h.Z(t2, e2, this.board), c.Z.evaluate(this.visProp.islabel) ? (o2 = a.Z.subtract(s2.scrCoords, d2.scrCoords), this.relativeCoords.scrCoords[1] += o2[1], this.relativeCoords.scrCoords[2] += o2[2]) : (o2 = a.Z.subtract(s2.usrCoords, d2.usrCoords), this.relativeCoords.usrCoords[1] += o2[1], this.relativeCoords.usrCoords[2] += o2[2]), this;
    for (this.coords.setCoordinates(t2, e2), this.handleSnapToGrid(), this.handleSnapToPoints(), this.handleAttractors(), i3 = this.transformations.length - 1; i3 >= 0; i3--)
      t2 === l.Z.COORDS_BY_SCREEN ? n2 = new h.Z(t2, e2, this.board).usrCoords : (2 === e2.length && (e2 = [1].concat(e2)), n2 = e2), this.initialCoords.setCoordinates(l.Z.COORDS_BY_USER, r2.Z.matVecMult(r2.Z.inverse(this.transformations[i3].matrix), n2));
    return this.prepareUpdate().update(), this.board.isSuspendedUpdate && this.type === l.Z.OBJECT_TYPE_GLIDER && this.updateGlider(), this;
  }, setPositionByTransform: function(t2, e2) {
    var i3;
    return e2 = new h.Z(t2, e2, this.board), i3 = this.board.create("transform", e2.usrCoords.slice(1), { type: "translate" }), this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix ? this.transformations[this.transformations.length - 1].melt(i3) : this.addTransform(this, i3), this.prepareUpdate().update(), this;
  }, setPosition: function(t2, e2) {
    return this.setPositionDirectly(t2, e2);
  }, setGliderPosition: function(t2) {
    return this.type === l.Z.OBJECT_TYPE_GLIDER && (this.position = t2, this.board.update()), this;
  }, makeGlider: function(t2) {
    var e2, i3, r3, o2 = this.board.select(t2), n2 = false;
    if (o2.type === l.Z.OBJECT_TYPE_POLYGON) {
      for (e2 = Number.MAX_VALUE, i3 = 0; i3 < o2.borders.length; i3++)
        (r3 = s.Z.Math.Geometry.distPointLine(this.coords.usrCoords, o2.borders[i3].stdform)) < e2 && (e2 = r3, t2 = o2.borders[i3]);
      o2 = this.board.select(t2), n2 = true;
    }
    if (!c.Z.exists(o2))
      throw new Error("JSXGraph: slide object undefined.");
    if (o2.type === l.Z.OBJECT_TYPE_TICKS)
      throw new Error("JSXGraph: gliders on ticks are not possible.");
    return this.slideObject = this.board.select(t2), this.slideObjects.push(this.slideObject), this.addParents(t2), this.type = l.Z.OBJECT_TYPE_GLIDER, this.elType = "glider", this.visProp.snapwidth = -1, this.slideObject.addChild(this), this.isDraggable = true, this.onPolygon = n2, this.generatePolynomial = function() {
      return this.slideObject.generatePolynomial(this);
    }, this.updateGlider(), this.needsUpdateFromParent = true, this.updateGliderFromParent(), this;
  }, popSlideObject: function() {
    this.slideObjects.length > 0 && (this.slideObjects.pop(), this.slideObject.removeChild(this), 0 === this.slideObjects.length ? (this.type = this._org_type, this.type === l.Z.OBJECT_TYPE_POINT ? this.elType = "point" : this.elementClass === l.Z.OBJECT_CLASS_TEXT ? this.elType = "text" : this.type === l.Z.OBJECT_TYPE_IMAGE ? this.elType = "image" : this.type === l.Z.OBJECT_TYPE_FOREIGNOBJECT && (this.elType = "foreignobject"), this.slideObject = null) : this.slideObject = this.slideObjects[this.slideObjects.length - 1]);
  }, free: function() {
    var t2, e2;
    if (this.type !== l.Z.OBJECT_TYPE_GLIDER) {
      if (this.transformations.length = 0, delete this.updateConstraint, this.isConstrained = false, this.isDraggable)
        return;
      this.isDraggable = true, this.elementClass === l.Z.OBJECT_CLASS_POINT && (this.type = l.Z.OBJECT_TYPE_POINT, this.elType = "point"), this.XEval = function() {
        return this.coords.usrCoords[1];
      }, this.YEval = function() {
        return this.coords.usrCoords[2];
      }, this.ZEval = function() {
        return this.coords.usrCoords[0];
      }, this.Xjc = null, this.Yjc = null;
    }
    for (t2 in this.board.objects)
      this.board.objects.hasOwnProperty(t2) && (e2 = this.board.objects[t2]).descendants && (delete e2.descendants[this.id], delete e2.childElements[this.id], this.hasLabel && (delete e2.descendants[this.label.id], delete e2.childElements[this.label.id]));
    this.ancestors = {}, this.slideObject = null, this.slideObjects = [], this.elementClass === l.Z.OBJECT_CLASS_POINT ? (this.type = l.Z.OBJECT_TYPE_POINT, this.elType = "point") : this.elementClass === l.Z.OBJECT_CLASS_TEXT ? (this.type = this._org_type, this.elType = "text") : this.elementClass === l.Z.OBJECT_CLASS_OTHER && (this.type = this._org_type, this.elType = "image");
  }, addConstraint: function(t2) {
    var e2, i3, s2 = [], r3 = ["X", "Y"], o2 = function(t3) {
      return function() {
        return t3;
      };
    }, n2 = function(t3) {
      return function() {
        return t3.Value();
      };
    };
    for (this.elementClass === l.Z.OBJECT_CLASS_POINT && (this.type = l.Z.OBJECT_TYPE_CAS), this.isDraggable = false, e2 = 0; e2 < t2.length; e2++)
      i3 = t2[e2], c.Z.isString(i3) ? (s2[e2] = this.board.jc.snippet(i3, true, null, true), this.addParentsFromJCFunctions([s2[e2]]), 2 === t2.length && (this[r3[e2] + "jc"] = t2[e2])) : c.Z.isFunction(i3) ? s2[e2] = i3 : c.Z.isNumber(i3) ? s2[e2] = o2(i3) : c.Z.isObject(i3) && c.Z.isFunction(i3.Value) && (s2[e2] = n2(i3)), s2[e2].origin = i3;
    return 1 === t2.length ? this.updateConstraint = function() {
      var t3 = s2[0]();
      return c.Z.isArray(t3) ? this.coords.setCoordinates(l.Z.COORDS_BY_USER, t3) : this.coords = t3, this;
    } : 2 === t2.length ? (this.XEval = s2[0], this.YEval = s2[1], this.addParents([s2[0].origin, s2[1].origin]), this.updateConstraint = function() {
      return this.coords.setCoordinates(l.Z.COORDS_BY_USER, [this.XEval(), this.YEval()]), this;
    }) : (this.ZEval = s2[0], this.XEval = s2[1], this.YEval = s2[2], this.addParents([s2[0].origin, s2[1].origin, s2[2].origin]), this.updateConstraint = function() {
      return this.coords.setCoordinates(l.Z.COORDS_BY_USER, [this.ZEval(), this.XEval(), this.YEval()]), this;
    }), this.isConstrained = true, this.prepareUpdate().update(), this.board.isSuspendedUpdate || (this.updateVisibility().updateRenderer(), this.hasLabel && this.label.fullUpdate()), this;
  }, addAnchor: function(t2, e2) {
    this.relativeCoords = e2 ? new h.Z(l.Z.COORDS_BY_SCREEN, t2.slice(0, 2), this.board) : new h.Z(l.Z.COORDS_BY_USER, t2, this.board), this.element.addChild(this), e2 && this.addParents(this.element), this.XEval = function() {
      var t3, e3, i3;
      return c.Z.evaluate(this.visProp.islabel) ? (i3 = c.Z.evaluate(this.visProp.offset), t3 = parseFloat(i3[0]), e3 = this.element.getLabelAnchor(), new h.Z(l.Z.COORDS_BY_SCREEN, [t3 + this.relativeCoords.scrCoords[1] + e3.scrCoords[1], 0], this.board).usrCoords[1]) : (e3 = this.element.getTextAnchor(), this.relativeCoords.usrCoords[1] + e3.usrCoords[1]);
    }, this.YEval = function() {
      var t3, e3, i3;
      return c.Z.evaluate(this.visProp.islabel) ? (i3 = c.Z.evaluate(this.visProp.offset), t3 = -parseFloat(i3[1]), e3 = this.element.getLabelAnchor(), new h.Z(l.Z.COORDS_BY_SCREEN, [0, t3 + this.relativeCoords.scrCoords[2] + e3.scrCoords[2]], this.board).usrCoords[2]) : (e3 = this.element.getTextAnchor(), this.relativeCoords.usrCoords[2] + e3.usrCoords[2]);
    }, this.ZEval = c.Z.createFunction(1, this.board, ""), this.updateConstraint = function() {
      this.coords.setCoordinates(l.Z.COORDS_BY_USER, [this.ZEval(), this.XEval(), this.YEval()]);
    }, this.isConstrained = true, this.updateConstraint();
  }, updateTransform: function(t2) {
    var e2;
    if (0 === this.transformations.length)
      return this;
    for (e2 = 0; e2 < this.transformations.length; e2++)
      this.transformations[e2].update();
    return this;
  }, addTransform: function(t2, e2) {
    var i3, s2 = c.Z.isArray(e2) ? e2 : [e2], r3 = s2.length;
    for (0 === this.transformations.length && (this.baseElement = t2), i3 = 0; i3 < r3; i3++)
      this.transformations.push(s2[i3]);
    return this;
  }, startAnimation: function(t2, e2, i3) {
    var s2 = c.Z.evaluate(t2), r3 = c.Z.evaluate(e2), o2 = this;
    return i3 = c.Z.evaluate(i3) || 250, this.type !== l.Z.OBJECT_TYPE_GLIDER || c.Z.exists(this.intervalCode) || (this.intervalCode = window.setInterval(function() {
      o2._anim(s2, r3);
    }, i3), c.Z.exists(this.intervalCount) || (this.intervalCount = 0)), this;
  }, stopAnimation: function() {
    return c.Z.exists(this.intervalCode) && (window.clearInterval(this.intervalCode), delete this.intervalCode), this;
  }, moveAlong: function(t2, e2, i3) {
    i3 = i3 || {};
    var s2, r3, o2, a2, h2, d2 = [], u = [], p = e2 / this.board.attr.animationdelay, _ = function(e3, i4) {
      return function() {
        return t2[e3][i4];
      };
    };
    if (c.Z.isArray(t2)) {
      for (o2 = t2.length, s2 = 0; s2 < o2; s2++)
        c.Z.isPoint(t2[s2]) ? u[s2] = t2[s2] : u[s2] = { elementClass: l.Z.OBJECT_CLASS_POINT, X: _(s2, 0), Y: _(s2, 1) };
      if (0 === (e2 = e2 || 0))
        return this.setPosition(l.Z.COORDS_BY_USER, [u[u.length - 1].X(), u[u.length - 1].Y()]), this.board.update(this);
      if (!c.Z.exists(i3.interpolate) || i3.interpolate)
        for (r3 = n.Z.Neville(u), s2 = 0; s2 < p; s2++)
          d2[s2] = [], d2[s2][0] = r3[0]((p - s2) / p * r3[3]()), d2[s2][1] = r3[1]((p - s2) / p * r3[3]());
      else {
        for (o2 = t2.length - 1, s2 = 0; s2 < p; ++s2)
          h2 = s2 / p * o2 - (a2 = Math.floor(s2 / p * o2)), d2[s2] = [], d2[s2][0] = (1 - h2) * u[a2].X() + h2 * u[a2 + 1].X(), d2[s2][1] = (1 - h2) * u[a2].Y() + h2 * u[a2 + 1].Y();
        d2.push([u[o2].X(), u[o2].Y()]), d2.reverse();
      }
      this.animationPath = d2;
    } else
      c.Z.isFunction(t2) && (this.animationPath = t2, this.animationStart = (/* @__PURE__ */ new Date()).getTime());
    return this.animationCallback = i3.callback, this.board.addAnimation(this), this;
  }, moveTo: function(t2, e2, i3) {
    i3 = i3 || {}, t2 = new h.Z(l.Z.COORDS_BY_USER, t2, this.board);
    var s2, o2 = this.board.attr.animationdelay, n2 = Math.ceil(e2 / o2), a2 = [], d2 = this.coords.usrCoords[1], u = this.coords.usrCoords[2], p = t2.usrCoords[1] - d2, _ = t2.usrCoords[2] - u, f = function(t3) {
      return i3.effect && "<>" === i3.effect ? Math.pow(Math.sin(t3 / n2 * Math.PI / 2), 2) : t3 / n2;
    };
    if (!c.Z.exists(e2) || 0 === e2 || Math.abs(t2.usrCoords[0] - this.coords.usrCoords[0]) > r2.Z.eps)
      return this.setPosition(l.Z.COORDS_BY_USER, t2.usrCoords), this.board.update(this);
    if (!c.Z.exists(i3.callback) && Math.abs(p) < r2.Z.eps && Math.abs(_) < r2.Z.eps)
      return this;
    for (s2 = n2; s2 >= 0; s2--)
      a2[n2 - s2] = [t2.usrCoords[0], d2 + p * f(s2), u + _ * f(s2)];
    return this.animationPath = a2, this.animationCallback = i3.callback, this.board.addAnimation(this), this;
  }, visit: function(t2, e2, i3) {
    t2 = new h.Z(l.Z.COORDS_BY_USER, t2, this.board);
    var s2, r3, o2, n2 = this.board.attr.animationdelay, a2 = [], d2 = this.coords.usrCoords[1], u = this.coords.usrCoords[2], p = t2.usrCoords[1] - d2, _ = t2.usrCoords[2] - u, f = function(t3) {
      var e3 = t3 < o2 / 2 ? 2 * t3 / o2 : 2 * (o2 - t3) / o2;
      return i3.effect && "<>" === i3.effect ? Math.pow(Math.sin(e3 * Math.PI / 2), 2) : e3;
    };
    for (c.Z.isNumber(i3) ? i3 = { repeat: i3 } : (i3 = i3 || {}, c.Z.exists(i3.repeat) || (i3.repeat = 1)), o2 = Math.ceil(e2 / (n2 * i3.repeat)), r3 = 0; r3 < i3.repeat; r3++)
      for (s2 = o2; s2 >= 0; s2--)
        a2[r3 * (o2 + 1) + o2 - s2] = [t2.usrCoords[0], d2 + p * f(s2), u + _ * f(s2)];
    return this.animationPath = a2, this.animationCallback = i3.callback, this.board.addAnimation(this), this;
  }, _anim: function(t2, e2) {
    var i3, s2, r3, n2, a2, h2, c2, d2, u;
    return this.intervalCount += 1, this.intervalCount > e2 && (this.intervalCount = 0), this.slideObject.elementClass === l.Z.OBJECT_CLASS_LINE ? (c2 = this.slideObject.point1.coords.scrCoords, d2 = this.slideObject.point2.coords.scrCoords, i3 = Math.round((d2[1] - c2[1]) * this.intervalCount / e2), s2 = Math.round((d2[2] - c2[2]) * this.intervalCount / e2), t2 > 0 ? n2 = this.slideObject.point1 : (n2 = this.slideObject.point2, i3 *= -1, s2 *= -1), this.coords.setCoordinates(l.Z.COORDS_BY_SCREEN, [n2.coords.scrCoords[1] + i3, n2.coords.scrCoords[2] + s2])) : this.slideObject.elementClass === l.Z.OBJECT_CLASS_CURVE ? (a2 = t2 > 0 ? Math.round(this.intervalCount / e2 * this.board.canvasWidth) : Math.round((e2 - this.intervalCount) / e2 * this.board.canvasWidth), this.coords.setCoordinates(l.Z.COORDS_BY_SCREEN, [a2, 0]), u = o.Z.projectPointToCurve(this, this.slideObject, this.board), this.coords = u[0], this.position = u[1]) : this.slideObject.elementClass === l.Z.OBJECT_CLASS_CIRCLE && (r3 = 2 * Math.PI, r3 *= t2 < 0 ? this.intervalCount / e2 : (e2 - this.intervalCount) / e2, h2 = this.slideObject.Radius(), this.coords.setCoordinates(l.Z.COORDS_BY_USER, [this.slideObject.center.coords.usrCoords[1] + h2 * Math.cos(r3), this.slideObject.center.coords.usrCoords[2] + h2 * Math.sin(r3)])), this.board.update(this), this;
  }, getTextAnchor: function() {
    return this.coords;
  }, getLabelAnchor: function() {
    return this.coords;
  }, getParents: function() {
    var t2 = [this.Z(), this.X(), this.Y()];
    return 0 !== this.parents.length && (t2 = this.parents), this.type === l.Z.OBJECT_TYPE_GLIDER && (t2 = [this.X(), this.Y(), this.slideObject.id]), t2;
  } }), s.Z.CoordsElement.create = function(t2, e2, i3, s2, r3, o2) {
    var n2, a2, h2 = false;
    for (a2 = 0; a2 < i3.length; a2++)
      (c.Z.isFunction(i3[a2]) || c.Z.isString(i3[a2])) && (h2 = true);
    if (h2)
      (n2 = new t2(e2, [0, 0], s2, r3, o2)).addConstraint(i3);
    else if (c.Z.isNumber(i3[0]) && c.Z.isNumber(i3[1]))
      n2 = new t2(e2, i3, s2, r3, o2), c.Z.exists(s2.slideobject) ? n2.makeGlider(s2.slideobject) : n2.baseElement = n2, n2.isDraggable = true;
    else {
      if (!c.Z.isObject(i3[0]) || !c.Z.isTransformationOrArray(i3[1]))
        return false;
      (n2 = new t2(e2, [0, 0], s2, r3, o2)).addTransform(i3[0], i3[1]), n2.isDraggable = false;
    }
    return n2.handleSnapToGrid(), n2.handleSnapToPoints(), n2.handleAttractors(), n2.addParents(i3), n2;
  };
  const d = s.Z.CoordsElement;
}, 958: (t, e, i2) => {
  i2.d(e, { Z: () => u });
  var s = i2(765), r2 = i2(351), o = i2(705), n = i2(275), a = i2(309), h = i2(766), l = i2(88), c = i2(327), d = i2(109);
  s.Z.GeometryElement = function(t2, e2, i3, s2) {
    var o2, n2, a2;
    if (this.needsUpdate = true, this.isDraggable = false, this.isReal = true, this.childElements = {}, this.hasLabel = false, this.highlighted = false, this.notExistingParents = {}, this.traces = {}, this.numTraces = 0, this.transformations = [], this.baseElement = null, this.descendants = {}, this.ancestors = {}, this.parents = [], this.symbolic = {}, this.rendNode = null, this.elType = "", this.dump = true, this.subs = {}, this.inherits = [], this._pos = -1, this.stdform = [1, 0, 0, 0, 1, 1, 0, 0], this.methodMap = { setLabel: "setLabel", label: "label", setName: "setName", getName: "getName", addTransform: "addTransform", setProperty: "setAttribute", setAttribute: "setAttribute", addChild: "addChild", animate: "animate", on: "on", off: "off", trigger: "trigger", addTicks: "addTicks", removeTicks: "removeTicks", removeAllTicks: "removeAllTicks" }, this.quadraticform = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.visProp = {}, this.visPropCalc = { visible: false }, l.Z.eventify(this), this.mouseover = false, this.lastDragTime = /* @__PURE__ */ new Date(), arguments.length > 0) {
      for (n2 in this.board = t2, this.type = i3, this._org_type = i3, this.elementClass = s2 || r2.Z.OBJECT_CLASS_OTHER, this.id = e2.id, o2 = e2.name, d.Z.exists(o2) || (o2 = this.board.generateName(this)), "" !== o2 && (this.board.elementsByName[o2] = this), this.name = o2, this.needsRegularUpdate = e2.needsregularupdate, d.Z.clearVisPropOld(this), a2 = this.resolveShortcuts(e2))
        a2.hasOwnProperty(n2) && this._set(n2, a2[n2]);
      this.visProp.draft = a2.draft && a2.draft.draft;
    }
  }, s.Z.extend(s.Z.GeometryElement.prototype, { addChild: function(t2) {
    var e2, i3;
    for (e2 in this.childElements[t2.id] = t2, this.addDescendants(t2), t2.ancestors[this.id] = this, this.descendants)
      if (this.descendants.hasOwnProperty(e2))
        for (i3 in this.descendants[e2].ancestors[this.id] = this, this.ancestors)
          this.ancestors.hasOwnProperty(i3) && (this.descendants[e2].ancestors[this.ancestors[i3].id] = this.ancestors[i3]);
    for (e2 in this.ancestors)
      if (this.ancestors.hasOwnProperty(e2))
        for (i3 in this.descendants)
          this.descendants.hasOwnProperty(i3) && (this.ancestors[e2].descendants[this.descendants[i3].id] = this.descendants[i3]);
    return this;
  }, addDescendants: function(t2) {
    var e2;
    for (e2 in this.descendants[t2.id] = t2, t2.childElements)
      t2.childElements.hasOwnProperty(e2) && this.addDescendants(t2.childElements[e2]);
    return this;
  }, addParents: function(t2) {
    var e2, i3, s2;
    for (i3 = (s2 = d.Z.isArray(t2) ? t2 : arguments).length, e2 = 0; e2 < i3; ++e2)
      d.Z.exists(s2[e2]) && (d.Z.isId(this.board, s2[e2]) ? this.parents.push(s2[e2]) : d.Z.exists(s2[e2].id) && this.parents.push(s2[e2].id));
    this.parents = d.Z.uniqueArray(this.parents);
  }, setParents: function(t2) {
    this.parents = [], this.addParents(t2);
  }, addParentsFromJCFunctions: function(t2) {
    var e2, i3, s2;
    for (e2 = 0; e2 < t2.length; e2++)
      for (i3 in t2[e2].deps)
        s2 = t2[e2].deps[i3], this.addParents(s2), s2.addChild(this);
    return this;
  }, removeChild: function(t2) {
    return delete this.childElements[t2.id], this.removeDescendants(t2), delete t2.ancestors[this.id], this;
  }, removeDescendants: function(t2) {
    var e2;
    for (e2 in delete this.descendants[t2.id], t2.childElements)
      t2.childElements.hasOwnProperty(e2) && this.removeDescendants(t2.childElements[e2]);
    return this;
  }, countChildren: function() {
    var t2, e2, i3 = 0;
    for (t2 in e2 = this.childElements)
      e2.hasOwnProperty(t2) && t2.indexOf("Label") < 0 && i3++;
    return i3;
  }, getName: function() {
    return this.name;
  }, addTransform: function(t2) {
    return this;
  }, draggable: function() {
    return this.isDraggable && !d.Z.evaluate(this.visProp.fixed) && this.type !== r2.Z.OBJECT_TYPE_GLIDER;
  }, setPosition: function(t2, e2) {
    var i3, s2, o2, n2, a2 = [];
    if (!d.Z.exists(this.parents))
      return this;
    for (o2 = this.parents.length, s2 = 0; s2 < o2; ++s2)
      if (i3 = this.board.select(this.parents[s2]), d.Z.isPoint(i3)) {
        if (!i3.draggable())
          return this;
        a2.push(i3);
      }
    for (3 === e2.length && (e2 = e2.slice(1)), n2 = this.board.create("transform", e2, { type: "translate" }), (o2 = a2.length) > 0 ? n2.applyOnce(a2) : this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix ? this.transformations[this.transformations.length - 1].melt(n2) : this.addTransform(n2), s2 = 0; s2 < o2; ++s2)
      a2[s2].type === r2.Z.OBJECT_TYPE_GLIDER && a2[s2].updateGlider();
    return this;
  }, setPositionDirectly: function(t2, e2, i3) {
    var s2 = new o.Z(t2, e2, this.board, false), n2 = new o.Z(t2, i3, this.board, false), h2 = a.Z.subtract(s2.usrCoords, n2.usrCoords);
    return this.setPosition(r2.Z.COORDS_BY_USER, h2), this;
  }, generatePolynomial: function() {
    return [];
  }, animate: function(t2, e2, i3) {
    i3 = i3 || {};
    var s2, r3, o2, n2 = this.board.attr.animationdelay, a2 = Math.ceil(e2 / n2), h2 = this, l2 = function(t3, e3, i4) {
      var s3, r4, n3, l3, d2;
      for (s3 = c.Z.rgb2hsv(t3), n3 = ((r4 = c.Z.rgb2hsv(e3))[0] - s3[0]) / a2, l3 = (r4[1] - s3[1]) / a2, d2 = (r4[2] - s3[2]) / a2, h2.animationData[i4] = [], o2 = 0; o2 < a2; o2++)
        h2.animationData[i4][a2 - o2 - 1] = c.Z.hsv2rgb(s3[0] + (o2 + 1) * n3, s3[1] + (o2 + 1) * l3, s3[2] + (o2 + 1) * d2);
    }, u2 = function(t3, e3, i4, s3) {
      var r4, n3;
      if (t3 = parseFloat(t3), e3 = parseFloat(e3), !isNaN(t3) && !isNaN(e3))
        for (n3 = (e3 - t3) / a2, h2.animationData[i4] = [], o2 = 0; o2 < a2; o2++)
          r4 = t3 + (o2 + 1) * n3, h2.animationData[i4][a2 - o2 - 1] = s3 ? Math.floor(r4) : r4;
    };
    for (s2 in this.animationData = {}, t2)
      if (t2.hasOwnProperty(s2))
        switch (r3 = s2.toLowerCase()) {
          case "strokecolor":
          case "fillcolor":
            l2(this.visProp[r3], t2[s2], r3);
            break;
          case "size":
            if (!d.Z.isPoint(this))
              break;
            u2(this.visProp[r3], t2[s2], r3, true);
            break;
          case "strokeopacity":
          case "strokewidth":
          case "fillopacity":
            u2(this.visProp[r3], t2[s2], r3, false);
        }
    return this.animationCallback = i3.callback, this.board.addAnimation(this), this;
  }, update: function() {
    return d.Z.evaluate(this.visProp.trace) && this.cloneToBackground(), this;
  }, updateRenderer: function() {
    return this;
  }, fullUpdate: function(t2) {
    return this.prepareUpdate().update().updateVisibility(t2).updateRenderer();
  }, setDisplayRendNode: function(t2) {
    var e2, i3, s2, r3, o2;
    if (void 0 === t2 && (t2 = this.visPropCalc.visible), t2 === this.visPropOld.visible)
      return this;
    for (this.board.renderer.display(this, t2), i3 = this.inherits.length, s2 = 0; s2 < i3; s2++)
      if (o2 = this.inherits[s2], d.Z.isArray(o2))
        for (r3 = o2.length, e2 = 0; e2 < r3; e2++)
          d.Z.exists(o2[e2]) && d.Z.exists(o2[e2].rendNode) && "inherit" === d.Z.evaluate(o2[e2].visProp.visible) && o2[e2].setDisplayRendNode(t2);
      else
        d.Z.exists(o2) && d.Z.exists(o2.rendNode) && "inherit" === d.Z.evaluate(o2.visProp.visible) && o2.setDisplayRendNode(t2);
    return this.hasLabel && d.Z.exists(this.label) && d.Z.exists(this.label.rendNode) && "inherit" === d.Z.evaluate(this.label.visProp.visible) && this.label.setDisplayRendNode(t2), this;
  }, hide: function() {
    return this.setAttribute({ visible: false }), this;
  }, hideElement: function() {
    return this.hide(), this;
  }, show: function() {
    return this.setAttribute({ visible: true }), this;
  }, showElement: function() {
    return this.show(), this;
  }, updateVisibility: function(t2) {
    var e2, i3, s2, r3, o2, n2;
    if (this.needsUpdate) {
      for (void 0 !== t2 ? this.visPropCalc.visible = t2 : (n2 = d.Z.evaluate(this.visProp.visible), d.Z.exists(this.hiddenByParent) && this.hiddenByParent && (n2 = false), "inherit" !== n2 && (this.visPropCalc.visible = n2)), i3 = this.inherits.length, s2 = 0; s2 < i3; s2++)
        if (o2 = this.inherits[s2], d.Z.isArray(o2))
          for (r3 = o2.length, e2 = 0; e2 < r3; e2++)
            d.Z.exists(o2[e2]) && "inherit" === d.Z.evaluate(o2[e2].visProp.visible) && o2[e2].prepareUpdate().updateVisibility(this.visPropCalc.visible);
        else
          d.Z.exists(o2) && "inherit" === d.Z.evaluate(o2.visProp.visible) && o2.prepareUpdate().updateVisibility(this.visPropCalc.visible);
      d.Z.exists(this.label) && d.Z.exists(this.label.visProp) && d.Z.evaluate(this.label.visProp.visible) && this.label.prepareUpdate().updateVisibility(this.visPropCalc.visible);
    }
    return this;
  }, _set: function(t2, e2) {
    var i3;
    if (t2 = t2.toLocaleLowerCase(), this.visProp.hasOwnProperty(t2) && t2.indexOf("color") >= 0 && d.Z.isString(e2) && 9 === e2.length && "#" === e2.charAt(0))
      e2 = c.Z.rgba2rgbo(e2), this.visProp[t2] = e2[0], this.visProp[t2.replace("color", "opacity")] = e2[1];
    else if (null === e2 || !d.Z.isObject(e2) || d.Z.exists(e2.id) || d.Z.exists(e2.name))
      this.visProp[t2] = e2;
    else
      for (i3 in this.visProp[t2] = {}, e2)
        e2.hasOwnProperty(i3) && (this.visProp[t2][i3.toLocaleLowerCase()] = e2[i3]);
  }, resolveShortcuts: function(t2) {
    var e2, i3, s2, r3 = ["traceattributes", "traceAttributes"];
    for (e2 in h.Z.shortcuts)
      if (h.Z.shortcuts.hasOwnProperty(e2)) {
        if (d.Z.exists(t2[e2]))
          for (i3 = 0; i3 < h.Z.shortcuts[e2].length; i3++)
            d.Z.exists(t2[h.Z.shortcuts[e2][i3]]) || (t2[h.Z.shortcuts[e2][i3]] = t2[e2]);
        for (s2 = 0; s2 < r3.length; s2++)
          d.Z.isObject(t2[r3[s2]]) && (t2[r3[s2]] = this.resolveShortcuts(t2[r3[s2]]));
      }
    return t2;
  }, setLabel: function(t2) {
    this.hasLabel || this.setAttribute({ withlabel: true }), this.setLabelText(t2);
  }, setLabelText: function(t2) {
    return d.Z.exists(this.label) && (t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;"), this.label.setText(t2)), this;
  }, setName: function(t2) {
    t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;"), "slider" !== this.elType && this.setLabelText(t2), this.setAttribute({ name: t2 });
  }, setProperty: function() {
    s.Z.deprecated("setProperty()", "setAttribute()"), this.setAttribute.apply(this, arguments);
  }, setAttribute: function(t2) {
    var e2, i3, o2, n2, a2, h2, l2, u2, p, _ = {};
    for (e2 = 0; e2 < arguments.length; e2++)
      h2 = arguments[e2], d.Z.isString(h2) ? (u2 = h2.split(":"), _[d.Z.trim(u2[0])] = d.Z.trim(u2[1])) : d.Z.isArray(h2) ? _[h2[0]] = h2[1] : s.Z.extend(_, h2);
    for (e2 in _ = this.resolveShortcuts(_))
      if (_.hasOwnProperty(e2)) {
        if (n2 = e2.replace(/\s+/g, "").toLowerCase(), a2 = _[e2], d.Z.isObject(a2) && d.Z.exists(this.visProp[n2])) {
          if (this.visProp[n2] = d.Z.merge(this.visProp[n2], a2), this.type === r2.Z.OBJECT_TYPE_TICKS && d.Z.exists(this.labels))
            for (o2 = this.labels.length, i3 = 0; i3 < o2; i3++)
              this.labels[i3].setAttribute(a2);
          else if (d.Z.exists(this[n2]))
            if (d.Z.isArray(this[n2]))
              for (i3 = 0; i3 < this[n2].length; i3++)
                this[n2][i3].setAttribute(a2);
            else
              this[n2].setAttribute(a2);
          continue;
        }
        switch (p = this.visProp[n2], n2) {
          case "name":
            p = this.name, delete this.board.elementsByName[this.name], this.name = a2, this.board.elementsByName[this.name] = this;
            break;
          case "needsregularupdate":
            this.needsRegularUpdate = !("false" === a2 || false === a2), this.board.renderer.setBuffering(this, this.needsRegularUpdate ? "auto" : "static");
            break;
          case "labelcolor":
            l2 = (a2 = c.Z.rgba2rgbo(a2))[1], a2 = a2[0], 0 === l2 && d.Z.exists(this.label) && this.hasLabel && this.label.hideElement(), d.Z.exists(this.label) && this.hasLabel && (this.label.visProp.strokecolor = a2, this.board.renderer.setObjectStrokeColor(this.label, a2, l2)), this.elementClass === r2.Z.OBJECT_CLASS_TEXT && (this.visProp.strokecolor = a2, this.visProp.strokeopacity = l2, this.board.renderer.setObjectStrokeColor(this, a2, l2));
            break;
          case "infoboxtext":
            d.Z.isString(a2) ? this.infoboxText = a2 : this.infoboxText = false;
            break;
          case "visible":
            this.visProp.visible = "false" !== a2 && ("true" === a2 || a2), this.setDisplayRendNode(d.Z.evaluate(this.visProp.visible)), d.Z.evaluate(this.visProp.visible) && d.Z.exists(this.updateSize) && this.updateSize();
            break;
          case "face":
            d.Z.isPoint(this) && (this.visProp.face = a2, this.board.renderer.changePointStyle(this));
            break;
          case "trace":
            "false" === a2 || false === a2 ? (this.clearTrace(), this.visProp.trace = false) : this.visProp.trace = "pause" !== a2;
            break;
          case "gradient":
            this.visProp.gradient = a2, this.board.renderer.setGradient(this);
            break;
          case "gradientsecondcolor":
            a2 = c.Z.rgba2rgbo(a2), this.visProp.gradientsecondcolor = a2[0], this.visProp.gradientsecondopacity = a2[1], this.board.renderer.updateGradient(this);
            break;
          case "gradientsecondopacity":
            this.visProp.gradientsecondopacity = a2, this.board.renderer.updateGradient(this);
            break;
          case "withlabel":
            this.visProp.withlabel = a2, d.Z.evaluate(a2) ? (this.label || this.createLabel(), this.label.setAttribute({ visible: "inherit" })) : this.label && this.hasLabel && this.label.setAttribute({ visible: false }), this.hasLabel = a2;
            break;
          case "radius":
            this.type !== r2.Z.OBJECT_TYPE_ANGLE && this.type !== r2.Z.OBJECT_TYPE_SECTOR || this.setRadius(a2);
            break;
          case "rotate":
            (this.elementClass === r2.Z.OBJECT_CLASS_TEXT && "internal" === d.Z.evaluate(this.visProp.display) || this.type === r2.Z.OBJECT_TYPE_IMAGE) && this.addRotation(a2);
            break;
          case "ticksdistance":
            this.type === r2.Z.OBJECT_TYPE_TICKS && d.Z.isNumber(a2) && (this.ticksFunction = this.makeTicksFunction(a2));
            break;
          case "generatelabelvalue":
            this.type === r2.Z.OBJECT_TYPE_TICKS && d.Z.isFunction(a2) && (this.generateLabelValue = a2);
            break;
          case "onpolygon":
            this.type === r2.Z.OBJECT_TYPE_GLIDER && (this.onPolygon = !!a2);
            break;
          case "disabled":
            d.Z.exists(this.rendNodeTag) && (this.rendNodeTag.disabled = !!a2);
            break;
          case "checked":
            d.Z.exists(this.rendNodeTag) && (this.rendNodeCheckbox.checked = !!a2);
            break;
          case "maxlength":
            d.Z.exists(this.rendNodeTag) && (this.rendNodeTag.maxlength = !!a2);
            break;
          case "layer":
            this.board.renderer.setLayer(this, d.Z.evaluate(a2)), this._set(n2, a2);
            break;
          case "tabindex":
            d.Z.exists(this.rendNode) && (this.rendNode.setAttribute("tabindex", a2), this._set(n2, a2));
            break;
          default:
            d.Z.exists(this.visProp[n2]) && (!s.Z.Validator[n2] || s.Z.Validator[n2] && s.Z.Validator[n2](a2) || s.Z.Validator[n2] && d.Z.isFunction(a2) && s.Z.Validator[n2](a2())) && (a2 = (!a2.toLowerCase || "false" !== a2.toLowerCase()) && a2, this._set(n2, a2));
        }
        this.triggerEventHandlers(["attribute:" + n2], [p, a2, this]);
      }
    return this.triggerEventHandlers(["attribute"], [_, this]), d.Z.evaluate(this.visProp.needsregularupdate) ? this.board.update(this) : this.board.fullUpdate(), this;
  }, getProperty: function() {
    s.Z.deprecated("getProperty()", "getAttribute()"), this.getProperty.apply(this, arguments);
  }, getAttribute: function(t2) {
    var e2;
    switch (t2 = t2.toLowerCase()) {
      case "needsregularupdate":
        e2 = this.needsRegularUpdate;
        break;
      case "labelcolor":
        e2 = this.label.visProp.strokecolor;
        break;
      case "infoboxtext":
        e2 = this.infoboxText;
        break;
      case "withlabel":
        e2 = this.hasLabel;
        break;
      default:
        e2 = this.visProp[t2];
    }
    return e2;
  }, setDash: function(t2) {
    return this.setAttribute({ dash: t2 }), this;
  }, prepareUpdate: function() {
    return this.needsUpdate = true, this;
  }, remove: function() {
    return this.board.renderer.remove(this.board.renderer.getElementById(this.id)), this.hasLabel && this.board.renderer.remove(this.board.renderer.getElementById(this.label.id)), this;
  }, getTextAnchor: function() {
    return new o.Z(r2.Z.COORDS_BY_USER, [0, 0], this.board);
  }, getLabelAnchor: function() {
    return new o.Z(r2.Z.COORDS_BY_USER, [0, 0], this.board);
  }, setArrow: function(t2, e2) {
    return this.visProp.firstarrow = t2, this.visProp.lastarrow = e2, e2 && (this.type = r2.Z.OBJECT_TYPE_VECTOR, this.elType = "arrow"), this.prepareUpdate().update().updateVisibility().updateRenderer(), this;
  }, createGradient: function() {
    var t2 = d.Z.evaluate(this.visProp.gradient);
    "linear" !== t2 && "radial" !== t2 || this.board.renderer.setGradient(this);
  }, createLabel: function() {
    var t2, e2 = this;
    return s.Z.elements.text ? ((t2 = d.Z.deepCopy(this.visProp.label, null)).id = this.id + "Label", t2.isLabel = true, t2.anchor = this, t2.priv = this.visProp.priv, this.visProp.withlabel && (this.label = s.Z.elements.text(this.board, [0, 0, function() {
      return d.Z.isFunction(e2.name) ? e2.name() : e2.name;
    }], t2), this.label.needsUpdate = true, this.label.dump = false, this.label.fullUpdate(), this.hasLabel = true)) : s.Z.debug("JSXGraph: Can't create label: text element is not available. Make sure you include base/text"), this;
  }, highlight: function(t2) {
    return t2 = d.Z.def(t2, false), !d.Z.evaluate(this.visProp.highlight) || this.highlighted && !t2 || (this.highlighted = true, this.board.highlightedObjects[this.id] = this, this.board.renderer.highlight(this)), this;
  }, noHighlight: function() {
    return this.highlighted && (this.highlighted = false, delete this.board.highlightedObjects[this.id], this.board.renderer.noHighlight(this)), this;
  }, clearTrace: function() {
    var t2;
    for (t2 in this.traces)
      this.traces.hasOwnProperty(t2) && this.board.renderer.remove(this.traces[t2]);
    return this.numTraces = 0, this;
  }, cloneToBackground: function() {
    return this;
  }, bounds: function() {
    return [0, 0, 0, 0];
  }, normalize: function() {
    return this.stdform = n.Z.normalize(this.stdform), this;
  }, toJSON: function() {
    var t2, e2, i3 = ['{"name":', this.name];
    for (e2 in i3.push(', "id":' + this.id), t2 = [], this.visProp)
      this.visProp.hasOwnProperty(e2) && d.Z.exists(this.visProp[e2]) && t2.push('"' + e2 + '":' + this.visProp[e2]);
    return i3.push(', "visProp":{' + t2.toString() + "}"), i3.push("}"), i3.join("");
  }, addRotation: function(t2) {
    var e2, i3, s2, o2, n2, a2 = this;
    return (this.elementClass === r2.Z.OBJECT_CLASS_TEXT && "internal" === d.Z.evaluate(this.visProp.display) || this.type === r2.Z.OBJECT_TYPE_IMAGE) && 0 !== t2 && (e2 = this.board.create("transform", [function() {
      return -a2.X();
    }, function() {
      return -a2.Y();
    }], { type: "translate" }), i3 = this.board.create("transform", [function() {
      return a2.X();
    }, function() {
      return a2.Y();
    }], { type: "translate" }), s2 = this.board.create("transform", [function() {
      return a2.board.unitX / a2.board.unitY;
    }, function() {
      return 1;
    }], { type: "scale" }), o2 = this.board.create("transform", [function() {
      return a2.board.unitY / a2.board.unitX;
    }, function() {
      return 1;
    }], { type: "scale" }), n2 = this.board.create("transform", [function() {
      return d.Z.evaluate(t2) * Math.PI / 180;
    }], { type: "rotate" }), e2.bindTo(this), s2.bindTo(this), n2.bindTo(this), o2.bindTo(this), i3.bindTo(this)), this;
  }, highlightStrokeColor: function(t2) {
    return s.Z.deprecated("highlightStrokeColor()", "setAttribute()"), this.setAttribute({ highlightStrokeColor: t2 }), this;
  }, strokeColor: function(t2) {
    return s.Z.deprecated("strokeColor()", "setAttribute()"), this.setAttribute({ strokeColor: t2 }), this;
  }, strokeWidth: function(t2) {
    return s.Z.deprecated("strokeWidth()", "setAttribute()"), this.setAttribute({ strokeWidth: t2 }), this;
  }, fillColor: function(t2) {
    return s.Z.deprecated("fillColor()", "setAttribute()"), this.setAttribute({ fillColor: t2 }), this;
  }, highlightFillColor: function(t2) {
    return s.Z.deprecated("highlightFillColor()", "setAttribute()"), this.setAttribute({ highlightFillColor: t2 }), this;
  }, labelColor: function(t2) {
    return s.Z.deprecated("labelColor()", "setAttribute()"), this.setAttribute({ labelColor: t2 }), this;
  }, dash: function(t2) {
    return s.Z.deprecated("dash()", "setAttribute()"), this.setAttribute({ dash: t2 }), this;
  }, visible: function(t2) {
    return s.Z.deprecated("visible()", "setAttribute()"), this.setAttribute({ visible: t2 }), this;
  }, shadow: function(t2) {
    return s.Z.deprecated("shadow()", "setAttribute()"), this.setAttribute({ shadow: t2 }), this;
  }, getType: function() {
    return this.elType;
  }, getParents: function() {
    return d.Z.isArray(this.parents) ? this.parents : [];
  }, snapToGrid: function() {
    return this;
  }, snapToPoints: function() {
    return this;
  }, getAttributes: function() {
    var t2, e2 = d.Z.deepCopy(this.visProp), i3 = [], s2 = i3.length;
    for (e2.id = this.id, e2.name = this.name, t2 = 0; t2 < s2; t2++)
      delete e2[i3[t2]];
    return e2;
  }, hasPoint: function(t2, e2) {
    return false;
  }, addTicks: function(t2) {
    return "" !== t2.id && d.Z.exists(t2.id) || (t2.id = this.id + "_ticks_" + (this.ticks.length + 1)), this.board.renderer.drawTicks(t2), this.ticks.push(t2), t2.id;
  }, removeAllTicks: function() {
    var t2;
    if (d.Z.exists(this.ticks)) {
      for (t2 = this.ticks.length - 1; t2 >= 0; t2--)
        this.removeTicks(this.ticks[t2]);
      this.ticks = [], this.board.update();
    }
  }, removeTicks: function(t2) {
    var e2, i3;
    if (d.Z.exists(this.defaultTicks) && this.defaultTicks === t2 && (this.defaultTicks = null), d.Z.exists(this.ticks)) {
      for (e2 = this.ticks.length - 1; e2 >= 0; e2--)
        if (this.ticks[e2] === t2) {
          if (this.board.removeObject(this.ticks[e2]), this.ticks[e2].ticks)
            for (i3 = 0; i3 < this.ticks[e2].ticks.length; i3++)
              d.Z.exists(this.ticks[e2].labels[i3]) && this.board.removeObject(this.ticks[e2].labels[i3]);
          delete this.ticks[e2];
          break;
        }
    }
  }, getSnapSizes: function() {
    var t2, e2, i3;
    return t2 = d.Z.evaluate(this.visProp.snapsizex), e2 = d.Z.evaluate(this.visProp.snapsizey), t2 <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks && (t2 = (i3 = this.board.defaultAxes.x.defaultTicks).ticksDelta * (d.Z.evaluate(i3.visProp.minorticks) + 1)), e2 <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks && (e2 = (i3 = this.board.defaultAxes.y.defaultTicks).ticksDelta * (d.Z.evaluate(i3.visProp.minorticks) + 1)), [t2, e2];
  }, handleSnapToGrid: function(t2, e2) {
    var i3, o2, n2, a2, h2, l2, c2, u2, p, _, f, b = d.Z.evaluate(this.visProp.attracttogrid), g = d.Z.evaluate(this.visProp.attractorunit), m = d.Z.evaluate(this.visProp.attractordistance);
    return !d.Z.exists(this.coords) || d.Z.evaluate(this.visProp.fixed) || (d.Z.evaluate(this.visProp.snaptogrid) || b || true === t2) && (i3 = this.coords.usrCoords[1], o2 = this.coords.usrCoords[2], _ = (p = this.getSnapSizes())[0], f = p[1], _ > 0 && f > 0 && (u2 = this.board.getBoundingBox(), n2 = Math.round(i3 / _) * _, a2 = Math.round(o2 / f) * f, h2 = new s.Z.Coords(r2.Z.COORDS_BY_USER, [n2, a2], this.board), (!b || h2.distance("screen" === g ? r2.Z.COORDS_BY_SCREEN : r2.Z.COORDS_BY_USER, this.coords) < m) && (i3 = n2, o2 = a2, e2 || (l2 = Math.min(u2[0], u2[2]), c2 = Math.max(u2[0], u2[2]), i3 < l2 ? i3 += _ : i3 > c2 && (i3 -= _), l2 = Math.min(u2[1], u2[3]), c2 = Math.max(u2[1], u2[3]), o2 < l2 ? o2 += f : o2 > c2 && (o2 -= f)), this.coords.setCoordinates(r2.Z.COORDS_BY_USER, [i3, o2])))), this;
  }, getBoundingBox: function() {
    var t2, e2, i3, s2, o2, n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    if (this.type === r2.Z.OBJECT_TYPE_POLYGON) {
      if ((e2 = this.vertices.length - 1) <= 0)
        return n2;
      for (t2 = 0; t2 < e2; t2++)
        i3 = this.vertices[t2].X(), n2[0] = i3 < n2[0] ? i3 : n2[0], n2[2] = i3 > n2[2] ? i3 : n2[2], i3 = this.vertices[t2].Y(), n2[1] = i3 < n2[1] ? i3 : n2[1], n2[3] = i3 > n2[3] ? i3 : n2[3];
    } else if (this.elementClass === r2.Z.OBJECT_CLASS_CIRCLE)
      s2 = this.center.X(), o2 = this.center.Y(), n2 = [s2 - this.radius, o2 + this.radius, s2 + this.radius, o2 - this.radius];
    else if (this.elementClass === r2.Z.OBJECT_CLASS_CURVE) {
      if (0 === (e2 = this.vertices.length))
        return n2;
      for (t2 = 0; t2 < e2; t2++)
        i3 = this.points[t2].coords.usrCoords[1], n2[0] = i3 < n2[0] ? i3 : n2[0], n2[2] = i3 > n2[2] ? i3 : n2[2], i3 = this.points[t2].coords.usrCoords[1], n2[1] = i3 < n2[1] ? i3 : n2[1], n2[3] = i3 > n2[3] ? i3 : n2[3];
    }
    return n2;
  }, addEvent: s.Z.shortcut(s.Z.GeometryElement.prototype, "on"), removeEvent: s.Z.shortcut(s.Z.GeometryElement.prototype, "off"), __evt__over: function(t2) {
  }, __evt__mouseover: function(t2) {
  }, __evt__out: function(t2) {
  }, __evt__mouseout: function(t2) {
  }, __evt__move: function(t2) {
  }, __evt__mousemove: function(t2) {
  }, __evt__drag: function(t2) {
  }, __evt__mousedrag: function(t2) {
  }, __evt__pendrag: function(t2) {
  }, __evt__touchdrag: function(t2) {
  }, __evt__keydrag: function(t2) {
  }, __evt__down: function(t2) {
  }, __evt__mousedown: function(t2) {
  }, __evt__pendown: function(t2) {
  }, __evt__touchdown: function(t2) {
  }, __evt__up: function(t2) {
  }, __evt__mouseup: function(t2) {
  }, __evt__penup: function(t2) {
  }, __evt__touchup: function(t2) {
  }, __evt__attribute: function(t2, e2) {
  }, __evt__attribute_: function(t2, e2, i3) {
  }, __evt: function() {
  } });
  const u = s.Z.GeometryElement;
}, 573: (t, e, i2) => {
  i2.d(e, { Z: () => u });
  var s = i2(765), r2 = i2(351), o = i2(958), n = i2(632), a = i2(503), h = i2(109), l = i2(275), c = i2(218), d = function() {
    this._val = parseFloat(this.rendNodeRange.value), this.rendNodeOut.value = this.rendNodeRange.value, this.board.update();
  };
  s.Z.Text = function(t2, e2, i3, s2) {
    var o2;
    this.constructor(t2, i3, r2.Z.OBJECT_TYPE_TEXT, r2.Z.OBJECT_CLASS_TEXT), this.element = this.board.select(i3.anchor), this.coordsConstructor(e2, h.Z.evaluate(this.visProp.islabel)), this.content = "", this.plaintext = "", this.plaintextOld = null, this.orgText = "", this.needsSizeUpdate = false, this.hiddenByParent = false, this.size = [1, 1], this.id = this.board.setId(this, "T"), this.board.renderer.drawText(this), this.board.finalizeAdding(this), o2 = this.visProp.visible, this.visProp.visible = true, this.setText(s2), this.visProp.visible = o2, h.Z.isString(this.content) && this.notifyParents(this.content), this.elType = "text", this.methodMap = h.Z.deepCopy(this.methodMap, { setText: "setTextJessieCode", move: "setCoords" });
  }, s.Z.Text.prototype = new o.Z(), h.Z.copyPrototypeMethods(s.Z.Text, c.Z, "coordsConstructor"), s.Z.extend(s.Z.Text.prototype, { hasPoint: function(t2, e2) {
    var i3, s2, r3, o2, n2, a2, c2, d2;
    return h.Z.isObject(h.Z.evaluate(this.visProp.precision)) ? (c2 = this.board._inputDevice, d2 = h.Z.evaluate(this.visProp.precision[c2])) : d2 = this.board.options.precision.hasPoint, this.transformations.length > 0 && (t2 = (i3 = l.Z.matVecMult(l.Z.inverse(this.board.renderer.joinTransforms(this, this.transformations)), [1, t2, e2]))[1], e2 = i3[2]), s2 = (i3 = "right" === (n2 = this.getAnchorX()) ? this.coords.scrCoords[1] - this.size[0] : "middle" === n2 ? this.coords.scrCoords[1] - 0.5 * this.size[0] : this.coords.scrCoords[1]) + this.size[0], r3 = (o2 = "top" === (a2 = this.getAnchorY()) ? this.coords.scrCoords[2] + this.size[1] : "middle" === a2 ? this.coords.scrCoords[2] + 0.5 * this.size[1] : this.coords.scrCoords[2]) - this.size[1], "all" === h.Z.evaluate(this.visProp.dragarea) ? t2 >= i3 - d2 && t2 < s2 + d2 && e2 >= r3 - d2 && e2 <= o2 + d2 : e2 >= r3 - d2 && e2 <= o2 + d2 && (t2 >= i3 - d2 && t2 <= i3 + 2 * d2 || t2 >= s2 - 2 * d2 && t2 <= s2 + d2);
  }, _createFctUpdateText: function(t2) {
    var e2, i3, s2, r3 = h.Z.evaluate(this.visProp.parse), o2 = h.Z.evaluate(this.visProp.usemathjax), n2 = h.Z.evaluate(this.visProp.usekatex), a2 = false;
    if (this.orgText = t2, h.Z.isFunction(t2))
      this.updateText = function() {
        s2 = t2().toString(), this.plaintext = !r3 || o2 || n2 ? s2 : this.replaceSub(this.replaceSup(this.convertGeonextAndSketchometry2CSS(s2, false)));
      };
    else if (h.Z.isNumber(t2) ? this.content = h.Z.toFixed(t2, h.Z.evaluate(this.visProp.digits)) : h.Z.isString(t2) && r3 && (h.Z.evaluate(this.visProp.useasciimathml) ? this.content = "'`" + t2 + "`'" : o2 || n2 ? (this.content = this.valueTagToJessieCode(t2), this.content = this.content.replace(/\\/g, "\\\\")) : this.content = this.poorMansTeX(this.valueTagToJessieCode(t2)), a2 = true), a2) {
      for (i3 in (e2 = this.board.jc.snippet(this.content, true, "", false)).deps)
        this.addParents(e2.deps[i3]), e2.deps[i3].addChild(this);
      this.updateText = function() {
        this.plaintext = this.unescapeTicks(e2());
      };
    } else
      this.updateText = function() {
        this.plaintext = t2;
      };
  }, _setText: function(t2) {
    return this._createFctUpdateText(t2), this.updateText(), this.fullUpdate(), this.board.infobox && this.id === this.board.infobox.id || this.updateSize(), this;
  }, setTextJessieCode: function(t2) {
    var e2;
    return this.visProp.castext = t2, e2 = h.Z.isFunction(t2) ? function() {
      return h.Z.sanitizeHTML(t2());
    } : h.Z.isNumber(t2) ? t2 : h.Z.sanitizeHTML(t2), this._setText(e2);
  }, setText: function(t2) {
    return this._setText(t2);
  }, updateSize: function() {
    var t2, e2, i3, s2 = h.Z.evaluate(this.visProp.display);
    return a.Z.isBrowser && "no" !== this.board.renderer.type ? (i3 = this.rendNode, "html" === s2 || "vml" === this.board.renderer.type ? h.Z.exists(i3.offsetWidth) ? (e2 = this, window.setTimeout(function() {
      e2.size = [i3.offsetWidth, i3.offsetHeight], e2.needsUpdate = true, e2.updateRenderer();
    }, 0)) : this.size = this.crudeSizeEstimate() : "internal" === s2 && ("svg" === this.board.renderer.type ? (e2 = this, window.setTimeout(function() {
      try {
        t2 = i3.getBBox(), e2.size = [t2.width, t2.height], e2.needsUpdate = true, e2.updateRenderer();
      } catch (t3) {
      }
    }, 0)) : "canvas" === this.board.renderer.type && (this.size = this.crudeSizeEstimate())), this) : this;
  }, crudeSizeEstimate: function() {
    var t2 = parseFloat(h.Z.evaluate(this.visProp.fontsize));
    return [t2 * this.plaintext.length * 0.45, 0.9 * t2];
  }, utf8_decode: function(t2) {
    return t2.replace(/&#x(\w+);/g, function(t3, e2) {
      return String.fromCharCode(parseInt(e2, 16));
    });
  }, replaceSub: function(t2) {
    if (!t2.indexOf)
      return t2;
    for (var e2, i3 = t2.indexOf("_{"); i3 >= 0; )
      (e2 = (t2 = t2.substr(0, i3) + t2.substr(i3).replace(/_\{/, "<sub>")).substr(i3).indexOf("}")) >= 0 && (t2 = t2.substr(0, e2) + t2.substr(e2).replace(/\}/, "</sub>")), i3 = t2.indexOf("_{");
    for (i3 = t2.indexOf("_"); i3 >= 0; )
      i3 = (t2 = t2.substr(0, i3) + t2.substr(i3).replace(/_(.?)/, "<sub>$1</sub>")).indexOf("_");
    return t2;
  }, replaceSup: function(t2) {
    if (!t2.indexOf)
      return t2;
    for (var e2, i3 = t2.indexOf("^{"); i3 >= 0; )
      (e2 = (t2 = t2.substr(0, i3) + t2.substr(i3).replace(/\^\{/, "<sup>")).substr(i3).indexOf("}")) >= 0 && (t2 = t2.substr(0, e2) + t2.substr(e2).replace(/\}/, "</sup>")), i3 = t2.indexOf("^{");
    for (i3 = t2.indexOf("^"); i3 >= 0; )
      i3 = (t2 = t2.substr(0, i3) + t2.substr(i3).replace(/\^(.?)/, "<sup>$1</sup>")).indexOf("^");
    return t2;
  }, getSize: function() {
    return this.size;
  }, setCoords: function(t2, e2) {
    var i3, s2, o2;
    return h.Z.isArray(t2) && t2.length > 1 && (e2 = t2[1], t2 = t2[0]), h.Z.evaluate(this.visProp.islabel) && h.Z.exists(this.element) ? (s2 = (t2 - (i3 = this.element.getLabelAnchor()).usrCoords[1]) * this.board.unitX, o2 = -(e2 - i3.usrCoords[2]) * this.board.unitY, this.relativeCoords.setCoordinates(r2.Z.COORDS_BY_SCREEN, [s2, o2])) : this.coords.setCoordinates(r2.Z.COORDS_BY_USER, [t2, e2]), this.fullUpdate(), this;
  }, update: function(t2) {
    return this.needsUpdate ? (this.updateCoords(t2), this.updateText(), "internal" === h.Z.evaluate(this.visProp.display) && h.Z.isString(this.plaintext) && (this.plaintext = this.utf8_decode(this.plaintext)), this.checkForSizeUpdate(), this.needsSizeUpdate && this.updateSize(), this) : this;
  }, checkForSizeUpdate: function() {
    this.board.infobox && this.id === this.board.infobox.id ? this.needsSizeUpdate = false : (this.needsSizeUpdate = this.plaintextOld !== this.plaintext, this.needsSizeUpdate && (this.plaintextOld = this.plaintext));
  }, updateRenderer: function() {
    return h.Z.evaluate(this.visProp.autoposition) && this.setAutoPosition().updateConstraint(), this.updateRendererGeneric("updateText");
  }, expandShortMath: function(t2) {
    return t2.replace(/([)0-9.])\s*([(a-zA-Z_])/g, "$1*$2");
  }, generateTerm: function(t2, e2, i3) {
    var s2, r3, o2, a2, l2 = '""';
    if (o2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = (t2 = t2 || "").replace(/\r/g, "")).replace(/\n/g, "")).replace(/"/g, "'")).replace(/'/g, "\\'")).replace(/&amp;arc;/g, "&ang;")).replace(/<arc\s*\/>/g, "&ang;")).replace(/&lt;arc\s*\/&gt;/g, "&ang;")).replace(/&lt;sqrt\s*\/&gt;/g, "&radic;")).replace(/&lt;value&gt;/g, "<value>")).replace(/&lt;\/value&gt;/g, "</value>")).indexOf("<value>"), a2 = t2.indexOf("</value>"), o2 >= 0)
      for (; o2 >= 0; )
        l2 += ' + "' + this.replaceSub(this.replaceSup(t2.slice(0, o2))) + '"', r3 = (r3 = t2.slice(o2 + 7, a2)).replace(/\s+/g, ""), true === e2 && (r3 = this.expandShortMath(r3)), (s2 = (s2 = (s2 = i3 ? r3 : n.Z.geonext2JS(r3, this.board)).replace(/\\"/g, "'")).replace(/\\'/g, "'")).indexOf("toFixed") < 0 && h.Z.isNumber(h.Z.bind(this.board.jc.snippet(s2, true, "", false), this)()) ? l2 += "+(" + s2 + ").toFixed(" + h.Z.evaluate(this.visProp.digits) + ")" : l2 += "+(" + s2 + ")", o2 = (t2 = t2.slice(a2 + 8)).indexOf("<value>"), a2 = t2.indexOf("</value>");
    return l2 += ' + "' + this.replaceSub(this.replaceSup(t2)) + '"', l2 = (l2 = (l2 = this.convertGeonextAndSketchometry2CSS(l2)).replace(/&amp;/g, "&")).replace(/"/g, "'");
  }, valueTagToJessieCode: function(t2) {
    var e2, i3, s2, r3, o2 = [], n2 = '"';
    if (s2 = (t2 = (t2 = (t2 = (t2 = (t2 = t2 || "").replace(/\r/g, "")).replace(/\n/g, "")).replace(/&lt;value&gt;/g, "<value>")).replace(/&lt;\/value&gt;/g, "</value>")).indexOf("<value>"), r3 = t2.indexOf("</value>"), s2 >= 0)
      for (; s2 >= 0; )
        o2.push(n2 + this.escapeTicks(t2.slice(0, s2)) + n2), i3 = (i3 = t2.slice(s2 + 7, r3)).replace(/\s+/g, ""), (e2 = (e2 = i3 = this.expandShortMath(i3)).replace(/\\"/g, "'").replace(/\\'/g, "'")).indexOf("toFixed") < 0 && h.Z.isNumber(h.Z.bind(this.board.jc.snippet(e2, true, "", false), this)()) ? o2.push("(" + e2 + ").toFixed(" + h.Z.evaluate(this.visProp.digits) + ")") : o2.push("(" + e2 + ")"), s2 = (t2 = t2.slice(r3 + 8)).indexOf("<value>"), r3 = t2.indexOf("</value>");
    return o2.push(n2 + this.escapeTicks(t2) + n2), o2.join(" + ").replace(/&amp;/g, "&");
  }, poorMansTeX: function(t2) {
    return t2 = t2.replace(/<arc\s*\/*>/g, "&ang;").replace(/&lt;arc\s*\/*&gt;/g, "&ang;").replace(/<sqrt\s*\/*>/g, "&radic;").replace(/&lt;sqrt\s*\/*&gt;/g, "&radic;"), this.convertGeonextAndSketchometry2CSS(this.replaceSub(this.replaceSup(t2)), true);
  }, escapeTicks: function(t2) {
    return t2.replace(/"/g, "%22").replace(/'/g, "%27");
  }, unescapeTicks: function(t2) {
    return t2.replace(/%22/g, '"').replace(/%27/g, "'");
  }, convertGeonext2CSS: function(t2) {
    return h.Z.isString(t2) && (t2 = (t2 = (t2 = (t2 = t2.replace(/(<|&lt;)overline(>|&gt;)/g, "<span style=text-decoration:overline;>")).replace(/(<|&lt;)\/overline(>|&gt;)/g, "</span>")).replace(/(<|&lt;)arrow(>|&gt;)/g, "<span style=text-decoration:overline;>")).replace(/(<|&lt;)\/arrow(>|&gt;)/g, "</span>")), t2;
  }, convertSketchometry2CSS: function(t2, e2) {
    var i3 = '<span class="sketcho sketcho-inherit sketcho-', s2 = '"></span>';
    return h.Z.isString(t2) && (e2 && (i3 = this.escapeTicks(i3), s2 = this.escapeTicks(s2)), t2 = (t2 = t2.replace(/(<|&lt;)sketchofont(>|&gt;)/g, i3)).replace(/(<|&lt;)\/sketchofont(>|&gt;)/g, s2)), t2;
  }, convertGeonextAndSketchometry2CSS: function(t2, e2) {
    return t2 = this.convertGeonext2CSS(t2), t2 = this.convertSketchometry2CSS(t2, e2);
  }, notifyParents: function(t2) {
    var e2, i3 = null;
    t2 = (t2 = t2.replace(/&lt;value&gt;/g, "<value>")).replace(/&lt;\/value&gt;/g, "</value>");
    do {
      null !== (i3 = (e2 = /<value>([\w\s*/^\-+()[\],<>=!]+)<\/value>/).exec(t2)) && (n.Z.findDependencies(this, i3[1], this.board), t2 = (t2 = t2.substr(i3.index)).replace(e2, ""));
    } while (null !== i3);
    return this;
  }, getParents: function() {
    var t2;
    return t2 = void 0 !== this.relativeCoords ? [this.relativeCoords.usrCoords[1], this.relativeCoords.usrCoords[2], this.orgText] : [this.Z(), this.X(), this.Y(), this.orgText], 0 !== this.parents.length && (t2 = this.parents), t2;
  }, bounds: function() {
    var t2 = this.coords.usrCoords;
    return h.Z.evaluate(this.visProp.islabel) || 0 === this.board.unitY || 0 === this.board.unitX ? [0, 0, 0, 0] : [t2[1], t2[2] + this.size[1] / this.board.unitY, t2[1] + this.size[0] / this.board.unitX, t2[2]];
  }, getAnchorX: function() {
    var t2 = h.Z.evaluate(this.visProp.anchorx);
    if ("auto" === t2)
      switch (this.visProp.position) {
        case "top":
        case "bot":
          return "middle";
        case "rt":
        case "lrt":
        case "urt":
          return "left";
        default:
          return "right";
      }
    return t2;
  }, getAnchorY: function() {
    var t2 = h.Z.evaluate(this.visProp.anchory);
    if ("auto" === t2)
      switch (this.visProp.position) {
        case "top":
        case "ulft":
        case "urt":
          return "bottom";
        case "bot":
        case "lrt":
        case "llft":
          return "top";
        default:
          return "middle";
      }
    return t2;
  }, getNumberofConflicts: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2, h2 = 0;
    for (a2 = this.board.options.precision.hasPoint, this.board.options.precision.hasPoint = 0.25 * (i3 + s2), r3 = 0, n2 = this.board.objectsList.length; r3 < n2; r3++)
      (o2 = this.board.objectsList[r3]).visPropCalc.visible && "axis" !== o2.elType && "ticks" !== o2.elType && o2 !== this.board.infobox && o2 !== this && o2.hasPoint(t2, e2) && h2++;
    return this.board.options.precision.hasPoint = a2, h2;
  }, setAutoPosition: function() {
    var t2, e2, i3, s2, r3, o2, n2, a2, l2, c2, d2, u2, p, _, f, b, g = this.size[0], m = this.size[1], v = { conflicts: 1 / 0, angle: 0, r: 0 }, Z = 2 * Math.PI / 12;
    if (this === this.board.infobox || !this.visPropCalc.visible || !h.Z.evaluate(this.visProp.islabel) || !this.element)
      return this;
    if (c2 = h.Z.evaluate(this.visProp.offset), i3 = (r3 = this.element.getLabelAnchor()).scrCoords[1], s2 = r3.scrCoords[2], p = c2[0], _ = c2[1], 0 === (l2 = this.getNumberofConflicts(i3 + p, s2 - _, g, m)))
      return this;
    for (a2 = 0.2 * (d2 = 12), o2 = Math.atan2(_, p), v.conflicts = l2, v.angle = o2, v.r = d2; v.conflicts > 0 && d2 < 28; ) {
      for (u2 = 1, n2 = o2 + Z; u2 < 12 && v.conflicts > 0 && (t2 = i3 + d2 * (f = Math.cos(n2)), e2 = s2 - d2 * (b = Math.sin(n2)), (l2 = this.getNumberofConflicts(t2, e2, g, m)) < v.conflicts && (v.conflicts = l2, v.angle = n2, v.r = d2), 0 !== v.conflicts); u2++)
        n2 += Z;
      d2 += a2;
    }
    return d2 = v.r, f = Math.cos(v.angle), b = Math.sin(v.angle), this.visProp.offset = [d2 * f, d2 * b], this.visProp.anchorx = f < -0.2 ? "right" : f > 0.2 ? "left" : "middle", this;
  } }), s.Z.createText = function(t2, e2, i3) {
    var r3, o2 = h.Z.copyAttributes(i3, t2.options, "text"), n2 = e2.slice(0, -1), a2 = e2[e2.length - 1];
    if (o2.anchor = o2.parent || o2.anchor, !(r3 = c.Z.create(s.Z.Text, t2, n2, o2, a2)))
      throw new Error("JSXGraph: Can't create text with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
    return 0 !== o2.rotate && "internal" === o2.display && r3.addRotation(o2.rotate), r3;
  }, s.Z.registerElement("text", s.Z.createText), s.Z.createHTMLSlider = function(t2, e2, i3) {
    var r3, o2, n2 = h.Z.copyAttributes(i3, t2.options, "htmlslider");
    if (2 !== e2.length || 2 !== e2[0].length || 3 !== e2[1].length)
      throw new Error("JSXGraph: Can't create htmlslider with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parents are: [[x,y], [min, start, max]]");
    n2.anchor = n2.parent || n2.anchor, n2.fixed = n2.fixed || true, o2 = [e2[0][0], e2[0][1], '<form style="display:inline"><input type="range" /><span></span><input type="text" /></form>'], (r3 = s.Z.createText(t2, o2, n2)).type = h.Z.OBJECT_TYPE_HTMLSLIDER, r3.rendNodeForm = r3.rendNode.childNodes[0], r3.rendNodeRange = r3.rendNodeForm.childNodes[0], r3.rendNodeRange.min = e2[1][0], r3.rendNodeRange.max = e2[1][2], r3.rendNodeRange.step = n2.step, r3.rendNodeRange.value = e2[1][1], r3.rendNodeLabel = r3.rendNodeForm.childNodes[1], r3.rendNodeLabel.id = r3.rendNode.id + "_label", n2.withlabel && (r3.rendNodeLabel.innerHTML = r3.name + "="), r3.rendNodeOut = r3.rendNodeForm.childNodes[2], r3.rendNodeOut.value = e2[1][1];
    try {
      r3.rendNodeForm.id = r3.rendNode.id + "_form", r3.rendNodeRange.id = r3.rendNode.id + "_range", r3.rendNodeOut.id = r3.rendNode.id + "_out";
    } catch (t3) {
      s.Z.debug(t3);
    }
    return r3.rendNodeRange.style.width = n2.widthrange + "px", r3.rendNodeRange.style.verticalAlign = "middle", r3.rendNodeOut.style.width = n2.widthout + "px", r3._val = e2[1][1], s.Z.supportsVML() ? a.Z.addEvent(r3.rendNodeForm, "change", d, r3) : a.Z.addEvent(r3.rendNodeForm, "input", d, r3), r3.Value = function() {
      return this._val;
    }, r3;
  }, s.Z.registerElement("htmlslider", s.Z.createHTMLSlider);
  const u = s.Z.Text;
}, 765: (t, e, i2) => {
  i2.d(e, { Z: () => r2 });
  var s = {};
  "object" != typeof JXG || JXG.extend || (s = JXG), s.extend = function(t2, e2, i3, s2) {
    var r3;
    for (r3 in i3 = i3 || false, s2 = s2 || false, e2)
      (!i3 || i3 && e2.hasOwnProperty(r3)) && (t2[s2 ? r3.toLowerCase() : r3] = e2[r3]);
  }, s.defineConstant = function(t2, e2, i3, r3) {
    (r3 = r3 || false) && s.exists(t2[e2]) || Object.defineProperty(t2, e2, { value: i3, writable: false, enumerable: true, configurable: false });
  }, s.extendConstants = function(t2, e2, i3, s2) {
    var r3, o;
    for (r3 in i3 = i3 || false, s2 = s2 || false, e2)
      (!i3 || i3 && e2.hasOwnProperty(r3)) && (o = s2 ? r3.toUpperCase() : r3, this.defineConstant(t2, o, e2[r3]));
  }, s.extend(s, { boards: {}, readers: {}, elements: {}, registerElement: function(t2, e2) {
    t2 = t2.toLowerCase(), this.elements[t2] = e2;
  }, registerReader: function(t2, e2) {
    var i3, s2;
    for (i3 = 0; i3 < e2.length; i3++)
      s2 = e2[i3].toLowerCase(), "function" != typeof this.readers[s2] && (this.readers[s2] = t2);
  }, shortcut: function(t2, e2) {
    return function() {
      return t2[e2].apply(this, arguments);
    };
  }, getRef: function(t2, e2) {
    return s.deprecated("JXG.getRef()", "Board.select()"), t2.select(e2);
  }, getReference: function(t2, e2) {
    return s.deprecated("JXG.getReference()", "Board.select()"), t2.select(e2);
  }, getBoardByContainerId: function(t2) {
    var e2;
    for (e2 in JXG.boards)
      if (JXG.boards.hasOwnProperty(e2) && JXG.boards[e2].container === t2)
        return JXG.boards[e2];
    return null;
  }, deprecated: function(t2, e2) {
    var i3 = t2 + " is deprecated.";
    e2 && (i3 += " Please use " + e2 + " instead."), s.warn(i3);
  }, warn: function(t2) {
    "object" == typeof window && window.console && console.warn ? console.warn("WARNING:", t2) : "object" == typeof document && document.getElementById("warning") && (document.getElementById("debug").innerHTML += "WARNING: " + t2 + "<br />");
  }, debugInt: function(t2) {
    var e2, i3;
    for (e2 = 0; e2 < arguments.length; e2++)
      i3 = arguments[e2], "object" == typeof window && window.console && console.log ? console.log(i3) : "object" == typeof document && document.getElementById("debug") && (document.getElementById("debug").innerHTML += i3 + "<br/>");
  }, debugWST: function(t2) {
    var e2 = new Error();
    s.debugInt.apply(this, arguments), e2 && e2.stack && (s.debugInt("stacktrace"), s.debugInt(e2.stack.split("\n").slice(1).join("\n")));
  }, debugLine: function(t2) {
    var e2 = new Error();
    s.debugInt.apply(this, arguments), e2 && e2.stack && s.debugInt("Called from", e2.stack.split("\n").slice(2, 3).join("\n"));
  }, debug: function(t2) {
    s.debugInt.apply(this, arguments);
  } });
  const r2 = s;
}, 922: (t, e, i2) => {
  i2.d(e, { Z: () => c });
  var s = i2(765), r2 = i2(351), o = i2(705), n = i2(275), a = i2(336), h = i2(109), l = i2(421);
  n.Z.Geometry = {}, s.Z.extend(n.Z.Geometry, { angle: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2 = [], l2 = [], c2 = [];
    return s.Z.deprecated("Geometry.angle()", "Geometry.rad()"), t2.coords ? (h2[0] = t2.coords.usrCoords[1], h2[1] = t2.coords.usrCoords[2]) : (h2[0] = t2[0], h2[1] = t2[1]), e2.coords ? (l2[0] = e2.coords.usrCoords[1], l2[1] = e2.coords.usrCoords[2]) : (l2[0] = e2[0], l2[1] = e2[1]), i3.coords ? (c2[0] = i3.coords.usrCoords[1], c2[1] = i3.coords.usrCoords[2]) : (c2[0] = i3[0], c2[1] = i3[1]), r3 = h2[0] - l2[0], o2 = h2[1] - l2[1], n2 = c2[0] - l2[0], a2 = c2[1] - l2[1], Math.atan2(r3 * a2 - o2 * n2, r3 * n2 + o2 * a2);
  }, trueAngle: function(t2, e2, i3) {
    return 57.29577951308232 * this.rad(t2, e2, i3);
  }, rad: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2, l2;
    return t2.coords ? (s2 = t2.coords.usrCoords[1], r3 = t2.coords.usrCoords[2]) : (s2 = t2[0], r3 = t2[1]), e2.coords ? (o2 = e2.coords.usrCoords[1], n2 = e2.coords.usrCoords[2]) : (o2 = e2[0], n2 = e2[1]), i3.coords ? (a2 = i3.coords.usrCoords[1], h2 = i3.coords.usrCoords[2]) : (a2 = i3[0], h2 = i3[1]), (l2 = Math.atan2(h2 - n2, a2 - o2) - Math.atan2(r3 - n2, s2 - o2)) < 0 && (l2 += 6.283185307179586), l2;
  }, angleBisector: function(t2, e2, i3, s2) {
    var n2, a2, l2, c2, d, u = t2.coords.usrCoords, p = e2.coords.usrCoords, _ = i3.coords.usrCoords;
    return h.Z.exists(s2) || (s2 = t2.board), 0 === p[0] ? new o.Z(r2.Z.COORDS_BY_USER, [1, 0.5 * (u[1] + _[1]), 0.5 * (u[2] + _[2])], s2) : (c2 = u[1] - p[1], d = u[2] - p[2], n2 = Math.atan2(d, c2), c2 = _[1] - p[1], d = _[2] - p[2], l2 = 0.5 * (n2 + (a2 = Math.atan2(d, c2))), n2 > a2 && (l2 += Math.PI), c2 = Math.cos(l2) + p[1], d = Math.sin(l2) + p[2], new o.Z(r2.Z.COORDS_BY_USER, [1, c2, d], s2));
  }, reflection: function(t2, e2, i3) {
    var s2, n2, a2, l2, c2, d, u = e2.coords.usrCoords, p = t2.point1.coords.usrCoords, _ = t2.point2.coords.usrCoords;
    return h.Z.exists(i3) || (i3 = e2.board), l2 = _[1] - p[1], c2 = _[2] - p[2], s2 = u[1] - p[1], d = (l2 * (u[2] - p[2]) - c2 * s2) / (l2 * l2 + c2 * c2), n2 = u[1] + 2 * d * c2, a2 = u[2] - 2 * d * l2, new o.Z(r2.Z.COORDS_BY_USER, [n2, a2], i3);
  }, rotation: function(t2, e2, i3, s2) {
    var n2, a2, l2, c2, d, u, p = e2.coords.usrCoords, _ = t2.coords.usrCoords;
    return h.Z.exists(s2) || (s2 = e2.board), n2 = p[1] - _[1], a2 = p[2] - _[2], d = n2 * (l2 = Math.cos(i3)) - a2 * (c2 = Math.sin(i3)) + _[1], u = n2 * c2 + a2 * l2 + _[2], new o.Z(r2.Z.COORDS_BY_USER, [d, u], s2);
  }, perpendicular: function(t2, e2, i3) {
    var s2, a2, l2, c2, d, u = t2.point1.coords.usrCoords, p = t2.point2.coords.usrCoords, _ = e2.coords.usrCoords;
    return h.Z.exists(i3) || (i3 = e2.board), e2 === t2.point1 ? (s2 = u[1] + p[2] - u[2], a2 = u[2] - p[1] + u[1], d = u[0] * p[0], Math.abs(d) < n.Z.eps && (s2 = p[2], a2 = -p[1]), c2 = [d, s2, a2], l2 = true) : e2 === t2.point2 ? (s2 = p[1] + u[2] - p[2], a2 = p[2] - u[1] + p[1], d = u[0] * p[0], Math.abs(d) < n.Z.eps && (s2 = u[2], a2 = -u[1]), c2 = [d, s2, a2], l2 = false) : Math.abs(n.Z.innerProduct(_, t2.stdform, 3)) < n.Z.eps ? (s2 = _[1] + p[2] - _[2], a2 = _[2] - p[1] + _[1], d = p[0], Math.abs(d) < n.Z.eps && (s2 = p[2], a2 = -p[1]), l2 = true, Math.abs(d) > n.Z.eps && Math.abs(s2 - _[1]) < n.Z.eps && Math.abs(a2 - _[2]) < n.Z.eps && (s2 = _[1] + u[2] - _[2], a2 = _[2] - u[1] + _[1], l2 = false), c2 = [d, s2, a2]) : (c2 = [0, t2.stdform[1], t2.stdform[2]], c2 = n.Z.crossProduct(c2, _), c2 = n.Z.crossProduct(c2, t2.stdform), l2 = true), [new o.Z(r2.Z.COORDS_BY_USER, c2, i3), l2];
  }, circumcenterMidpoint: function() {
    s.Z.deprecated("Geometry.circumcenterMidpoint()", "Geometry.circumcenter()"), this.circumcenter.apply(this, arguments);
  }, circumcenter: function(t2, e2, i3, s2) {
    var a2, l2, c2, d, u = t2.coords.usrCoords, p = e2.coords.usrCoords, _ = i3.coords.usrCoords;
    return h.Z.exists(s2) || (s2 = t2.board), a2 = [p[0] - u[0], -p[2] + u[2], p[1] - u[1]], l2 = [0.5 * (u[0] + p[0]), 0.5 * (u[1] + p[1]), 0.5 * (u[2] + p[2])], c2 = n.Z.crossProduct(a2, l2), a2 = [_[0] - p[0], -_[2] + p[2], _[1] - p[1]], l2 = [0.5 * (p[0] + _[0]), 0.5 * (p[1] + _[1]), 0.5 * (p[2] + _[2])], d = n.Z.crossProduct(a2, l2), new o.Z(r2.Z.COORDS_BY_USER, n.Z.crossProduct(c2, d), s2);
  }, distance: function(t2, e2, i3) {
    var s2, r3 = 0;
    for (i3 || (i3 = Math.min(t2.length, e2.length)), s2 = 0; s2 < i3; s2++)
      r3 += (t2[s2] - e2[s2]) * (t2[s2] - e2[s2]);
    return Math.sqrt(r3);
  }, affineDistance: function(t2, e2, i3) {
    var s2;
    return (s2 = this.distance(t2, e2, i3)) > n.Z.eps && (Math.abs(t2[0]) < n.Z.eps || Math.abs(e2[0]) < n.Z.eps) ? 1 / 0 : s2;
  }, affineRatio: function(t2, e2, i3) {
    var s2;
    return h.Z.exists(t2.usrCoords) && (t2 = t2.usrCoords), h.Z.exists(e2.usrCoords) && (e2 = e2.usrCoords), h.Z.exists(i3.usrCoords) && (i3 = i3.usrCoords), s2 = e2[1] - t2[1], Math.abs(s2) > n.Z.eps ? (i3[1] - t2[1]) / s2 : (i3[2] - t2[2]) / (e2[2] - t2[2]);
  }, sortVertices: function(t2) {
    for (var e2, i3 = l.Z.each(t2, l.Z.coordsArray), s2 = i3.length, r3 = null; i3[0][0] === i3[s2 - 1][0] && i3[0][1] === i3[s2 - 1][1] && i3[0][2] === i3[s2 - 1][2]; )
      r3 = i3.pop(), s2--;
    return e2 = i3[0], i3.sort(function(t3, i4) {
      return (t3[2] === e2[2] && t3[1] === e2[1] ? -1 / 0 : Math.atan2(t3[2] - e2[2], t3[1] - e2[1])) - (i4[2] === e2[2] && i4[1] === e2[1] ? -1 / 0 : Math.atan2(i4[2] - e2[2], i4[1] - e2[1]));
    }), null !== r3 && i3.push(r3), i3;
  }, signedTriangle: function(t2, e2, i3) {
    var s2 = l.Z.coordsArray(t2), r3 = l.Z.coordsArray(e2), o2 = l.Z.coordsArray(i3);
    return 0.5 * ((r3[1] - s2[1]) * (o2[2] - s2[2]) - (r3[2] - s2[2]) * (o2[1] - s2[1]));
  }, signedPolygon: function(t2, e2) {
    var i3, s2, r3 = 0, o2 = l.Z.each(t2, l.Z.coordsArray);
    for (void 0 === e2 && (e2 = true), e2 ? o2.unshift(o2[o2.length - 1]) : o2 = this.sortVertices(o2), s2 = o2.length, i3 = 1; i3 < s2; i3++)
      r3 += o2[i3 - 1][1] * o2[i3][2] - o2[i3][1] * o2[i3 - 1][2];
    return 0.5 * r3;
  }, GrahamScan: function(t2) {
    var e2, i3 = 1, s2 = l.Z.each(t2, l.Z.coordsArray), r3 = s2.length;
    for (r3 = (s2 = this.sortVertices(s2)).length, e2 = 2; e2 < r3; e2++) {
      for (; this.signedTriangle(s2[i3 - 1], s2[i3], s2[e2]) <= 0; ) {
        if (i3 > 1)
          i3 -= 1;
        else if (e2 === r3 - 1)
          break;
        e2 += 1;
      }
      i3 += 1, s2 = h.Z.swap(s2, i3, e2);
    }
    return s2.slice(0, i3);
  }, calcStraight: function(t2, e2, i3, s2) {
    var o2, a2, l2, c2, d, u, p, _, f, b;
    if (h.Z.exists(s2) || (s2 = 10), u = h.Z.evaluate(t2.visProp.straightfirst), p = h.Z.evaluate(t2.visProp.straightlast), Math.abs(e2.scrCoords[0]) < n.Z.eps && (u = true), Math.abs(i3.scrCoords[0]) < n.Z.eps && (p = true), (u || p) && ((_ = [])[0] = t2.stdform[0] - t2.stdform[1] * t2.board.origin.scrCoords[1] / t2.board.unitX + t2.stdform[2] * t2.board.origin.scrCoords[2] / t2.board.unitY, _[1] = t2.stdform[1] / t2.board.unitX, _[2] = -t2.stdform[2] / t2.board.unitY, !isNaN(_[0] + _[1] + _[2]))) {
      if (o2 = !u && Math.abs(e2.usrCoords[0]) >= n.Z.eps && e2.scrCoords[1] >= 0 && e2.scrCoords[1] <= t2.board.canvasWidth && e2.scrCoords[2] >= 0 && e2.scrCoords[2] <= t2.board.canvasHeight, a2 = !p && Math.abs(i3.usrCoords[0]) >= n.Z.eps && i3.scrCoords[1] >= 0 && i3.scrCoords[1] <= t2.board.canvasWidth && i3.scrCoords[2] >= 0 && i3.scrCoords[2] <= t2.board.canvasHeight, c2 = (l2 = this.meetLineBoard(_, t2.board, s2))[0], d = l2[1], !o2 && !a2) {
        if (!u && p && !this.isSameDirection(e2, i3, c2) && !this.isSameDirection(e2, i3, d))
          return;
        if (u && !p && !this.isSameDirection(i3, e2, c2) && !this.isSameDirection(i3, e2, d))
          return;
      }
      o2 ? a2 || (b = this.isSameDir(e2, i3, c2, d) ? d : c2) : a2 ? f = this.isSameDir(e2, i3, c2, d) ? c2 : d : this.isSameDir(e2, i3, c2, d) ? (f = c2, b = d) : (b = c2, f = d), f && e2.setCoordinates(r2.Z.COORDS_BY_USER, f.usrCoords), b && i3.setCoordinates(r2.Z.COORDS_BY_USER, b.usrCoords);
    }
  }, calcLineDelimitingPoints: function(t2, e2, i3) {
    var s2, o2, a2, l2, c2, d, u, p, _, f, b;
    if (c2 = h.Z.evaluate(t2.visProp.straightfirst), d = h.Z.evaluate(t2.visProp.straightlast), Math.abs(e2.scrCoords[0]) < n.Z.eps && (c2 = true), Math.abs(i3.scrCoords[0]) < n.Z.eps && (d = true), (u = [])[0] = t2.stdform[0] - t2.stdform[1] * t2.board.origin.scrCoords[1] / t2.board.unitX + t2.stdform[2] * t2.board.origin.scrCoords[2] / t2.board.unitY, u[1] = t2.stdform[1] / t2.board.unitX, u[2] = -t2.stdform[2] / t2.board.unitY, !isNaN(u[0] + u[1] + u[2])) {
      if (f = !c2, b = !d, o2 = t2.board.getBoundingBox(), t2.getSlope() >= 0 ? (a2 = this.projectPointToLine({ coords: { usrCoords: [1, o2[2], o2[1]] } }, t2, t2.board), l2 = this.projectPointToLine({ coords: { usrCoords: [1, o2[0], o2[3]] } }, t2, t2.board)) : (a2 = this.projectPointToLine({ coords: { usrCoords: [1, o2[0], o2[1]] } }, t2, t2.board), l2 = this.projectPointToLine({ coords: { usrCoords: [1, o2[2], o2[3]] } }, t2, t2.board)), !f && !b) {
        if (!c2 && !d) {
          if (s2 = e2.distance(r2.Z.COORDS_BY_USER, i3), Math.abs(e2.distance(r2.Z.COORDS_BY_USER, a2) + a2.distance(r2.Z.COORDS_BY_USER, i3) - s2) > n.Z.eps)
            return;
          if (Math.abs(e2.distance(r2.Z.COORDS_BY_USER, l2) + l2.distance(r2.Z.COORDS_BY_USER, i3) - s2) > n.Z.eps)
            return;
        }
        if (!c2 && d && !this.isSameDirection(e2, i3, a2) && !this.isSameDirection(e2, i3, l2))
          return;
        if (c2 && !d && !this.isSameDirection(i3, e2, a2) && !this.isSameDirection(i3, e2, l2))
          return;
      }
      f ? b || (_ = this.isSameDir(e2, i3, a2, l2) ? l2 : a2) : b ? p = this.isSameDir(e2, i3, a2, l2) ? a2 : l2 : this.isSameDir(e2, i3, a2, l2) ? (p = a2, _ = l2) : (_ = a2, p = l2), p && e2.setCoordinates(r2.Z.COORDS_BY_USER, p.usrCoords), _ && i3.setCoordinates(r2.Z.COORDS_BY_USER, _.usrCoords);
    }
  }, calcLabelQuadrant: function(t2) {
    return t2 < 0 && (t2 += 2 * Math.PI), ["rt", "urt", "top", "ulft", "lft", "llft", "lrt"][Math.floor((t2 + Math.PI / 8) / (Math.PI / 4)) % 8];
  }, isSameDir: function(t2, e2, i3, s2) {
    var r3 = e2.usrCoords[1] - t2.usrCoords[1], o2 = e2.usrCoords[2] - t2.usrCoords[2], a2 = s2.usrCoords[1] - i3.usrCoords[1], h2 = s2.usrCoords[2] - i3.usrCoords[2];
    return Math.abs(e2.usrCoords[0]) < n.Z.eps && (r3 = e2.usrCoords[1], o2 = e2.usrCoords[2]), Math.abs(t2.usrCoords[0]) < n.Z.eps && (r3 = -t2.usrCoords[1], o2 = -t2.usrCoords[2]), r3 * a2 + o2 * h2 >= 0;
  }, isSameDirection: function(t2, e2, i3) {
    var s2, r3, o2, a2, h2 = false;
    return s2 = e2.usrCoords[1] - t2.usrCoords[1], r3 = e2.usrCoords[2] - t2.usrCoords[2], o2 = i3.usrCoords[1] - t2.usrCoords[1], a2 = i3.usrCoords[2] - t2.usrCoords[2], Math.abs(s2) < n.Z.eps && (s2 = 0), Math.abs(r3) < n.Z.eps && (r3 = 0), Math.abs(o2) < n.Z.eps && (o2 = 0), Math.abs(a2) < n.Z.eps && (a2 = 0), (s2 >= 0 && o2 >= 0 || s2 <= 0 && o2 <= 0) && (h2 = r3 >= 0 && a2 >= 0 || r3 <= 0 && a2 <= 0), h2;
  }, det3p: function(t2, e2, i3) {
    return (t2[1] - i3[1]) * (e2[2] - i3[2]) - (e2[1] - i3[1]) * (t2[2] - i3[2]);
  }, windingNumber: function(t2, e2, i3) {
    var s2, r3, o2, a2, l2, c2, d = 0, u = e2.length, p = t2[1], _ = t2[2], f = 0;
    if (0 === u)
      return 0;
    if ((i3 = i3 || false) && (f = 1), isNaN(p) || isNaN(_))
      return 1;
    if (h.Z.exists(e2[0].coords) ? (s2 = e2[0].coords, r3 = e2[u - 1].coords) : (s2 = e2[0], r3 = e2[u - 1]), s2.usrCoords[1] === p && s2.usrCoords[2] === _)
      return 1;
    for (c2 = 0; c2 < u - f; c2++)
      if (h.Z.exists(e2[c2].coords) ? (r3 = e2[c2].coords.usrCoords, o2 = e2[(c2 + 1) % u].coords.usrCoords) : (r3 = e2[c2].usrCoords, o2 = e2[(c2 + 1) % u].usrCoords), !(0 === r3[0] || 0 === o2[0] || isNaN(r3[1]) || isNaN(o2[1]) || isNaN(r3[2]) || isNaN(o2[2]))) {
        if (o2[2] === _) {
          if (o2[1] === p)
            return 1;
          if (r3[2] === _ && o2[1] > p == r3[1] < p)
            return 0;
        }
        if (r3[2] < _ != o2[2] < _)
          if (l2 = 2 * (o2[2] > r3[2] ? 1 : 0) - 1, r3[1] >= p)
            if (o2[1] > p)
              d += l2;
            else {
              if (0 === (a2 = this.det3p(r3, o2, t2)))
                return 0;
              a2 > 0 + n.Z.eps == o2[2] > r3[2] && (d += l2);
            }
          else
            o2[1] > p && (a2 = this.det3p(r3, o2, t2)) > 0 + n.Z.eps == o2[2] > r3[2] && (d += l2);
      }
    return d;
  }, pnpoly: function(t2, e2, i3, s2) {
    var n2, a2, l2, c2, d, u, p, _, f = i3, b = false;
    for (s2 === r2.Z.COORDS_BY_USER ? (c2 = (u = new o.Z(r2.Z.COORDS_BY_USER, [t2, e2], this.board)).scrCoords[1], d = u.scrCoords[2]) : (c2 = t2, d = e2), n2 = 0, a2 = (l2 = i3.length) - 2; n2 < l2 - 1; a2 = n2++)
      p = h.Z.exists(f[n2].coords) ? f[n2].coords : f[n2], _ = h.Z.exists(f[a2].coords) ? f[a2].coords : f[a2], p.scrCoords[2] > d != _.scrCoords[2] > d && c2 < (_.scrCoords[1] - p.scrCoords[1]) * (d - p.scrCoords[2]) / (_.scrCoords[2] - p.scrCoords[2]) + p.scrCoords[1] && (b = !b);
    return b;
  }, intersectionFunction: function(t2, e2, i3, a2, l2, c2) {
    var d, u, p = this;
    return d = e2.elementClass === r2.Z.OBJECT_CLASS_CURVE && (e2.type === r2.Z.OBJECT_TYPE_ARC || e2.type === r2.Z.OBJECT_TYPE_SECTOR), u = i3.elementClass === r2.Z.OBJECT_CLASS_CURVE && (i3.type === r2.Z.OBJECT_TYPE_ARC || i3.type === r2.Z.OBJECT_TYPE_SECTOR), e2.elementClass !== r2.Z.OBJECT_CLASS_CURVE && i3.elementClass !== r2.Z.OBJECT_CLASS_CURVE || e2.elementClass !== r2.Z.OBJECT_CLASS_CURVE && e2.elementClass !== r2.Z.OBJECT_CLASS_CIRCLE || i3.elementClass !== r2.Z.OBJECT_CLASS_CURVE && i3.elementClass !== r2.Z.OBJECT_CLASS_CIRCLE ? e2.elementClass === r2.Z.OBJECT_CLASS_CURVE && !d && i3.elementClass === r2.Z.OBJECT_CLASS_LINE || i3.elementClass === r2.Z.OBJECT_CLASS_CURVE && !u && e2.elementClass === r2.Z.OBJECT_CLASS_LINE ? function() {
      return p.meetCurveLine(e2, i3, a2, e2.board, h.Z.evaluate(c2));
    } : e2.type === r2.Z.OBJECT_TYPE_POLYGON || i3.type === r2.Z.OBJECT_TYPE_POLYGON ? e2.elementClass === r2.Z.OBJECT_CLASS_LINE ? function() {
      var t3, s2 = h.Z.evaluate(e2.visProp.straightfirst), r3 = h.Z.evaluate(e2.visProp.straightlast), o2 = h.Z.evaluate(i3.visProp.straightfirst), n2 = h.Z.evaluate(i3.visProp.straightlast);
      return t3 = !(h.Z.evaluate(c2) || s2 && r3 && o2 && n2), p.meetPolygonLine(i3, e2, a2, e2.board, t3);
    } : i3.elementClass === r2.Z.OBJECT_CLASS_LINE ? function() {
      var t3, s2 = h.Z.evaluate(e2.visProp.straightfirst), r3 = h.Z.evaluate(e2.visProp.straightlast), o2 = h.Z.evaluate(i3.visProp.straightfirst), n2 = h.Z.evaluate(i3.visProp.straightlast);
      return t3 = !(h.Z.evaluate(c2) || s2 && r3 && o2 && n2), p.meetPolygonLine(e2, i3, a2, e2.board, t3);
    } : function() {
      return p.meetPathPath(e2, i3, a2, e2.board);
    } : e2.elementClass === r2.Z.OBJECT_CLASS_LINE && i3.elementClass === r2.Z.OBJECT_CLASS_LINE ? function() {
      var t3, s2, n2 = h.Z.evaluate(e2.visProp.straightfirst), l3 = h.Z.evaluate(e2.visProp.straightlast), d2 = h.Z.evaluate(i3.visProp.straightfirst), u2 = h.Z.evaluate(i3.visProp.straightlast);
      return h.Z.evaluate(c2) || n2 && l3 && d2 && u2 ? p.meet(e2.stdform, i3.stdform, a2, e2.board) : (t3 = p.meetSegmentSegment(e2.point1.coords.usrCoords, e2.point2.coords.usrCoords, i3.point1.coords.usrCoords, i3.point2.coords.usrCoords), s2 = !n2 && t3[1] < 0 || !l3 && t3[1] > 1 || !d2 && t3[2] < 0 || !u2 && t3[2] > 1 ? [0, NaN, NaN] : t3[0], new o.Z(r2.Z.COORDS_BY_USER, s2, e2.board));
    } : function() {
      var t3, l3, _, f = p.meet(e2.stdform, i3.stdform, a2, e2.board), b = true;
      return h.Z.evaluate(c2) ? f : (e2.elementClass !== r2.Z.OBJECT_CLASS_LINE || (t3 = h.Z.evaluate(e2.visProp.straightfirst), l3 = h.Z.evaluate(e2.visProp.straightlast), t3 && l3 || (_ = p.affineRatio(e2.point1.coords, e2.point2.coords, f), !(!l3 && _ > 1 + n.Z.eps || !t3 && _ < 0 - n.Z.eps)))) && (i3.elementClass !== r2.Z.OBJECT_CLASS_LINE || (t3 = h.Z.evaluate(i3.visProp.straightfirst), l3 = h.Z.evaluate(i3.visProp.straightlast), t3 && l3 || (_ = p.affineRatio(i3.point1.coords, i3.point2.coords, f), !(!l3 && _ > 1 + n.Z.eps || !t3 && _ < 0 - n.Z.eps)))) ? d && ((b = p.coordsOnArc(e2, f)) && u && (b = p.coordsOnArc(i3, f)), !b) ? new o.Z(s.Z.COORDS_BY_USER, [0, NaN, NaN], e2.board) : f : new o.Z(s.Z.COORDS_BY_USER, [0, NaN, NaN], e2.board);
    } : function() {
      return p.meetCurveCurve(e2, i3, a2, l2, e2.board);
    };
  }, coordsOnArc: function(t2, e2) {
    var i3 = this.rad(t2.radiuspoint, t2.center, e2.usrCoords.slice(1)), s2 = 0, r3 = this.rad(t2.radiuspoint, t2.center, t2.anglepoint), o2 = h.Z.evaluate(t2.visProp.selection);
    return ("minor" === o2 && r3 > Math.PI || "major" === o2 && r3 < Math.PI) && (s2 = r3, r3 = 2 * Math.PI), !(i3 < s2 || i3 > r3);
  }, meet: function(t2, e2, i3, s2) {
    var r3 = n.Z.eps;
    return Math.abs(t2[3]) < r3 && Math.abs(e2[3]) < r3 ? this.meetLineLine(t2, e2, i3, s2) : Math.abs(t2[3]) >= r3 && Math.abs(e2[3]) < r3 ? this.meetLineCircle(e2, t2, i3, s2) : Math.abs(t2[3]) < r3 && Math.abs(e2[3]) >= r3 ? this.meetLineCircle(t2, e2, i3, s2) : this.meetCircleCircle(t2, e2, i3, s2);
  }, meetLineBoard: function(t2, e2, i3) {
    var s2, a2, l2, c2, d = [];
    for (h.Z.exists(i3) || (i3 = 0), d[0] = n.Z.crossProduct(t2, [i3, 0, 1]), d[1] = n.Z.crossProduct(t2, [i3, 1, 0]), d[2] = n.Z.crossProduct(t2, [-i3 - e2.canvasHeight, 0, 1]), d[3] = n.Z.crossProduct(t2, [-i3 - e2.canvasWidth, 1, 0]), l2 = 0; l2 < 4; l2++)
      if (Math.abs(d[l2][0]) > n.Z.eps) {
        for (c2 = 2; c2 > 0; c2--)
          d[l2][c2] /= d[l2][0];
        d[l2][0] = 1;
      }
    return Math.abs(d[1][0]) < n.Z.eps ? (s2 = d[0], a2 = d[2]) : Math.abs(d[0][0]) < n.Z.eps ? (s2 = d[1], a2 = d[3]) : d[1][2] < 0 ? (s2 = d[0], a2 = d[3][2] > e2.canvasHeight ? d[2] : d[3]) : d[1][2] > e2.canvasHeight ? (s2 = d[2], a2 = d[3][2] < 0 ? d[0] : d[3]) : (s2 = d[1], a2 = d[3][2] < 0 ? d[0] : d[3][2] > e2.canvasHeight ? d[2] : d[3]), [s2 = new o.Z(r2.Z.COORDS_BY_SCREEN, s2.slice(1), e2), a2 = new o.Z(r2.Z.COORDS_BY_SCREEN, a2.slice(1), e2)];
  }, meetLineLine: function(t2, e2, i3, s2) {
    var a2 = isNaN(t2[5] + e2[5]) ? [0, 0, 0] : n.Z.crossProduct(t2, e2);
    return new o.Z(r2.Z.COORDS_BY_USER, a2, s2);
  }, meetLineCircle: function(t2, e2, i3, s2) {
    var a2, l2, c2, d, u, p, _, f, b;
    return e2[4] < n.Z.eps ? Math.abs(n.Z.innerProduct([1, e2[6], e2[7]], t2, 3)) < n.Z.eps ? new o.Z(r2.Z.COORDS_BY_USER, e2.slice(6, 8), s2) : new o.Z(r2.Z.COORDS_BY_USER, [NaN, NaN], s2) : (c2 = e2[0], l2 = e2.slice(1, 3), a2 = e2[3], d = t2[0], u = t2.slice(1, 3), p = a2, (f = (_ = l2[0] * u[1] - l2[1] * u[0]) * _ - 4 * p * (a2 * d * d - (l2[0] * u[0] + l2[1] * u[1]) * d + c2)) > -n.Z.eps * n.Z.eps ? (b = [(-_ + (f = Math.sqrt(Math.abs(f)))) / (2 * p), (-_ - f) / (2 * p)], 0 === h.Z.evaluate(i3) ? new o.Z(r2.Z.COORDS_BY_USER, [-b[0] * -u[1] - d * u[0], -b[0] * u[0] - d * u[1]], s2) : new o.Z(r2.Z.COORDS_BY_USER, [-b[1] * -u[1] - d * u[0], -b[1] * u[0] - d * u[1]], s2)) : new o.Z(r2.Z.COORDS_BY_USER, [0, 0, 0], s2));
  }, meetCircleCircle: function(t2, e2, i3, s2) {
    var a2;
    return t2[4] < n.Z.eps ? Math.abs(this.distance(t2.slice(6, 2), e2.slice(6, 8)) - e2[4]) < n.Z.eps ? new o.Z(r2.Z.COORDS_BY_USER, t2.slice(6, 8), s2) : new o.Z(r2.Z.COORDS_BY_USER, [0, 0, 0], s2) : e2[4] < n.Z.eps ? Math.abs(this.distance(e2.slice(6, 2), t2.slice(6, 8)) - t2[4]) < n.Z.eps ? new o.Z(r2.Z.COORDS_BY_USER, e2.slice(6, 8), s2) : new o.Z(r2.Z.COORDS_BY_USER, [0, 0, 0], s2) : (a2 = [e2[3] * t2[0] - t2[3] * e2[0], e2[3] * t2[1] - t2[3] * e2[1], e2[3] * t2[2] - t2[3] * e2[2], 0, 1, 1 / 0, 1 / 0, 1 / 0], a2 = n.Z.normalize(a2), this.meetLineCircle(a2, t2, i3, s2));
  }, meetCurveCurve: function(t2, e2, i3, s2, n2, l2) {
    var c2;
    return c2 = h.Z.exists(l2) && "newton" === l2 ? a.Z.generalizedNewton(t2, e2, h.Z.evaluate(i3), s2) : 3 === t2.bezierDegree || 3 === e2.bezierDegree ? this.meetBezierCurveRedBlueSegments(t2, e2, i3) : this.meetCurveRedBlueSegments(t2, e2, i3), new o.Z(r2.Z.COORDS_BY_USER, c2, n2);
  }, meetCurveLine: function(t2, e2, i3, s2, o2) {
    var n2, a2;
    return h.Z.exists(s2) || (s2 = t2.board), t2.elementClass === r2.Z.OBJECT_CLASS_CURVE ? (n2 = t2, a2 = e2) : (n2 = e2, a2 = t2), this.meetCurveLineDiscrete(n2, a2, i3, s2, !o2);
  }, meetCurveLineContinuous: function(t2, e2, i3, s2, h2) {
    var l2, c2, d, u, p, _, f, b, g, m, v, Z, C, y = n.Z.eps, P = n.Z.eps;
    for (u = this.meetCurveLineDiscrete(t2, e2, i3, s2, h2), p = u.usrCoords[1], _ = u.usrCoords[2], c2 = function(e3) {
      var i4, s3;
      return e3 > t2.maxX() || e3 < t2.minX() ? 1 / 0 : (i4 = p - t2.X(e3)) * i4 + (s3 = _ - t2.Y(e3)) * s3;
    }, d = function(i4) {
      var s3 = e2.stdform[0] + e2.stdform[1] * t2.X(i4) + e2.stdform[2] * t2.Y(i4);
      return s3 * s3;
    }, b = (t2.maxX() - t2.minX()) / 50, g = t2.minX(), Z = 1e-4, v = NaN, m = 0; m < 50 && (l2 = a.Z.root(c2, [Math.max(g, t2.minX()), Math.min(g + b, t2.maxX())]), !((C = Math.abs(c2(l2))) <= Z && (v = l2, (Z = C) < y))); m++)
      g += b;
    return l2 = v, C = d(l2 = a.Z.root(d, [Math.max(l2 - b, t2.minX()), Math.min(l2 + b, t2.maxX())])), f = isNaN(C) || Math.abs(C) > P ? 0 : 1, new o.Z(r2.Z.COORDS_BY_USER, [f, t2.X(l2), t2.Y(l2)], s2);
  }, meetCurveLineDiscrete: function(t2, e2, i3, s2, a2) {
    var l2, c2, d, u, p, _, f, b = h.Z.evaluate(i3), g = e2.point1.coords.usrCoords, m = e2.point2.coords.usrCoords, v = 0, Z = t2.numberPoints, C = h.Z.evaluate(e2.visProp.straightfirst), y = h.Z.evaluate(e2.visProp.straightlast);
    for (_ = new o.Z(r2.Z.COORDS_BY_USER, [0, NaN, NaN], s2), 0 === g[0] ? g = [1, m[1] + e2.stdform[2], m[2] - e2.stdform[1]] : 0 === m[0] && (m = [1, g[1] + e2.stdform[2], g[2] - e2.stdform[1]]), u = t2.points[0].usrCoords, l2 = 1; l2 < Z; l2 += t2.bezierDegree)
      if (d = u.slice(0), u = t2.points[l2].usrCoords, this.distance(d, u) > n.Z.eps) {
        for (f = 3 === t2.bezierDegree ? this.meetBeziersegmentBeziersegment([t2.points[l2 - 1].usrCoords.slice(1), t2.points[l2].usrCoords.slice(1), t2.points[l2 + 1].usrCoords.slice(1), t2.points[l2 + 2].usrCoords.slice(1)], [g.slice(1), m.slice(1)], a2) : [this.meetSegmentSegment(d, u, g, m)], c2 = 0; c2 < f.length; c2++)
          if (0 <= (p = f[c2])[1] && p[1] <= 1) {
            if (v === b)
              return a2 && (!C && p[2] < 0 || !y && p[2] > 1) ? _ : _ = new o.Z(r2.Z.COORDS_BY_USER, p[0], s2);
            v += 1;
          }
      }
    return _;
  }, meetCurveRedBlueSegments: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, l2, c2, d, u, p = h.Z.evaluate(i3), _ = 0, f = e2.numberPoints, b = t2.numberPoints;
    if (f <= 1 || b <= 1)
      return [0, NaN, NaN];
    for (s2 = 1; s2 < b; s2++)
      for (o2 = t2.points[s2 - 1].usrCoords, n2 = t2.points[s2].usrCoords, d = Math.min(o2[1], n2[1]), u = Math.max(o2[1], n2[1]), l2 = e2.points[0].usrCoords, r3 = 1; r3 < f; r3++)
        if (a2 = l2, l2 = e2.points[r3].usrCoords, Math.min(a2[1], l2[1]) < u && Math.max(a2[1], l2[1]) > d && (c2 = this.meetSegmentSegment(o2, n2, a2, l2))[1] >= 0 && c2[2] >= 0 && (c2[1] < 1 && c2[2] < 1 || s2 === b - 1 && 1 === c2[1] || r3 === f - 1 && 1 === c2[2])) {
          if (_ === p)
            return c2[0];
          _++;
        }
    return [0, NaN, NaN];
  }, meetSegmentSegment: function(t2, e2, i3, s2) {
    var r3, o2, a2, h2 = n.Z.crossProduct(t2, e2), l2 = n.Z.crossProduct(i3, s2), c2 = n.Z.crossProduct(h2, l2);
    return Math.abs(c2[0]) < n.Z.eps ? [c2, 1 / 0, 1 / 0] : (c2[1] /= c2[0], c2[2] /= c2[0], c2[0] /= c2[0], a2 = t2[o2 = Math.abs(e2[1] - e2[0] * t2[1]) < n.Z.eps ? 2 : 1] / t2[0], r3 = (c2[o2] - a2) / (0 !== e2[0] ? e2[o2] / e2[0] - a2 : e2[o2]), a2 = i3[o2 = Math.abs(s2[1] - s2[0] * i3[1]) < n.Z.eps ? 2 : 1] / i3[0], [c2, r3, (c2[o2] - a2) / (0 !== s2[0] ? s2[o2] / s2[0] - a2 : s2[o2])]);
  }, meetPathPath: function(t2, e2, i3, a2) {
    var l2, c2, d, u, p = h.Z.evaluate(i3);
    return (d = (l2 = s.Z.Math.Clip._getPath(t2, a2)).length) > 0 && this.distance(l2[0].coords.usrCoords, l2[d - 1].coords.usrCoords, 3) < n.Z.eps && l2.pop(), (d = (c2 = s.Z.Math.Clip._getPath(e2, a2)).length) > 0 && this.distance(c2[0].coords.usrCoords, c2[d - 1].coords.usrCoords, 3) < n.Z.eps * n.Z.eps && c2.pop(), i3 < 0 || s.Z.Math.Clip.isEmptyCase(l2, c2, "intersection") ? new o.Z(r2.Z.COORDS_BY_USER, [0, 0, 0], a2) : (s.Z.Math.Clip.makeDoublyLinkedList(l2), s.Z.Math.Clip.makeDoublyLinkedList(c2), p < (u = s.Z.Math.Clip.findIntersections(l2, c2, a2)[0]).length ? u[p].coords : new o.Z(r2.Z.COORDS_BY_USER, [0, 0, 0], a2));
  }, meetPolygonLine: function(t2, e2, i3, s2, n2) {
    var a2, l2, c2, d = h.Z.evaluate(i3), u = [0, 0, 0], p = t2.borders.length, _ = [];
    for (a2 = 0; a2 < p; a2++)
      c2 = t2.borders[a2], l2 = this.meetSegmentSegment(c2.point1.coords.usrCoords, c2.point2.coords.usrCoords, e2.point1.coords.usrCoords, e2.point2.coords.usrCoords), (!n2 || l2[2] >= 0 && l2[2] < 1) && l2[1] >= 0 && l2[1] < 1 && _.push(l2[0]);
    return d >= 0 && d < _.length && (u = _[d]), new o.Z(r2.Z.COORDS_BY_USER, u, s2);
  }, _bezierSplit: function(t2) {
    var e2, i3, s2, r3, o2, n2;
    return e2 = [0.5 * (t2[0][0] + t2[1][0]), 0.5 * (t2[0][1] + t2[1][1])], i3 = [0.5 * (t2[1][0] + t2[2][0]), 0.5 * (t2[1][1] + t2[2][1])], s2 = [0.5 * (t2[2][0] + t2[3][0]), 0.5 * (t2[2][1] + t2[3][1])], n2 = [0.5 * ((r3 = [0.5 * (e2[0] + i3[0]), 0.5 * (e2[1] + i3[1])])[0] + (o2 = [0.5 * (i3[0] + s2[0]), 0.5 * (i3[1] + s2[1])])[0]), 0.5 * (r3[1] + o2[1])], [[t2[0], e2, r3, n2], [n2, o2, s2, t2[3]]];
  }, _bezierBbox: function(t2) {
    var e2 = [];
    return 4 === t2.length ? (e2[0] = Math.min(t2[0][0], t2[1][0], t2[2][0], t2[3][0]), e2[1] = Math.max(t2[0][1], t2[1][1], t2[2][1], t2[3][1]), e2[2] = Math.max(t2[0][0], t2[1][0], t2[2][0], t2[3][0]), e2[3] = Math.min(t2[0][1], t2[1][1], t2[2][1], t2[3][1])) : (e2[0] = Math.min(t2[0][0], t2[1][0]), e2[1] = Math.max(t2[0][1], t2[1][1]), e2[2] = Math.max(t2[0][0], t2[1][0]), e2[3] = Math.min(t2[0][1], t2[1][1])), e2;
  }, _bezierOverlap: function(t2, e2) {
    return t2[2] >= e2[0] && t2[0] <= e2[2] && t2[1] >= e2[3] && t2[3] <= e2[1];
  }, _bezierListConcat: function(t2, e2, i3, s2) {
    var r3, o2 = h.Z.exists(s2), n2 = 0, a2 = e2.length, l2 = t2.length;
    for (l2 > 0 && a2 > 0 && (1 === t2[l2 - 1][1] && 0 === e2[0][1] || o2 && 1 === t2[l2 - 1][2] && 0 === e2[0][2]) && (n2 = 1), r3 = n2; r3 < a2; r3++)
      o2 && (e2[r3][2] *= 0.5, e2[r3][2] += s2), e2[r3][1] *= 0.5, e2[r3][1] += i3, t2.push(e2[r3]);
  }, _bezierMeetSubdivision: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2, l2, c2, d, u, p, _, f = [];
    return r3 = this._bezierBbox(e2), s2 = this._bezierBbox(t2), this._bezierOverlap(r3, s2) ? i3 < 5 ? (h2 = (o2 = this._bezierSplit(t2))[0], l2 = o2[1], n2 = (o2 = this._bezierSplit(e2))[0], a2 = o2[1], this._bezierListConcat(f, this._bezierMeetSubdivision(h2, n2, i3 + 1), 0, 0), this._bezierListConcat(f, this._bezierMeetSubdivision(h2, a2, i3 + 1), 0, 0.5), this._bezierListConcat(f, this._bezierMeetSubdivision(l2, n2, i3 + 1), 0.5, 0), this._bezierListConcat(f, this._bezierMeetSubdivision(l2, a2, i3 + 1), 0.5, 0.5), f) : (p = [1].concat(t2[0]), _ = [1].concat(t2[3]), d = [1].concat(e2[0]), u = [1].concat(e2[3]), (c2 = this.meetSegmentSegment(p, _, d, u))[1] >= 0 && c2[2] >= 0 && c2[1] <= 1 && c2[2] <= 1 ? [c2] : []) : [];
  }, _bezierLineMeetSubdivision: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2, h2, l2, c2, d, u, p, _ = [];
    return r3 = this._bezierBbox(e2), o2 = this._bezierBbox(t2), s2 && !this._bezierOverlap(o2, r3) ? [] : i3 < 5 ? (a2 = (n2 = this._bezierSplit(t2))[0], h2 = n2[1], this._bezierListConcat(_, this._bezierLineMeetSubdivision(a2, e2, i3 + 1), 0), this._bezierListConcat(_, this._bezierLineMeetSubdivision(h2, e2, i3 + 1), 0.5), _) : (u = [1].concat(t2[0]), p = [1].concat(t2[3]), c2 = [1].concat(e2[0]), d = [1].concat(e2[1]), (l2 = this.meetSegmentSegment(u, p, c2, d))[1] >= 0 && l2[1] <= 1 && (!s2 || l2[2] >= 0 && l2[2] <= 1) ? [l2] : []);
  }, meetBeziersegmentBeziersegment: function(t2, e2, i3) {
    var s2, r3, o2;
    for ((s2 = 4 === t2.length && 4 === e2.length ? this._bezierMeetSubdivision(t2, e2, 0) : this._bezierLineMeetSubdivision(t2, e2, 0, i3)).sort(function(t3, e3) {
      return 1e7 * (t3[1] - e3[1]) + (t3[2] - e3[2]);
    }), r3 = [], o2 = 0; o2 < s2.length; o2++)
      0 !== o2 && s2[o2][1] === s2[o2 - 1][1] && s2[o2][2] === s2[o2 - 1][2] || r3.push(s2[o2]);
    return r3;
  }, meetBezierCurveRedBlueSegments: function(t2, e2, i3) {
    var s2, o2, a2, l2, c2, d, u, p, _, f, b = h.Z.evaluate(i3), g = 0, m = 0, v = e2.numberPoints, Z = t2.numberPoints, C = [];
    if (v < e2.bezierDegree + 1 || Z < t2.bezierDegree + 1)
      return [0, NaN, NaN];
    for (v -= e2.bezierDegree, Z -= t2.bezierDegree, t2.type === r2.Z.OBJECT_TYPE_SECTOR && (g = 3, Z -= 3), e2.type === r2.Z.OBJECT_TYPE_SECTOR && (m = 3, v -= 3), o2 = g; o2 < Z; o2 += t2.bezierDegree)
      for (d = [(s2 = t2.points)[o2].usrCoords.slice(1), s2[o2 + 1].usrCoords.slice(1)], 3 === t2.bezierDegree && (d[2] = s2[o2 + 2].usrCoords.slice(1), d[3] = s2[o2 + 3].usrCoords.slice(1)), p = this._bezierBbox(d), a2 = m; a2 < v; a2 += e2.bezierDegree)
        if (u = [(s2 = e2.points)[a2].usrCoords.slice(1), s2[a2 + 1].usrCoords.slice(1)], 3 === e2.bezierDegree && (u[2] = s2[a2 + 2].usrCoords.slice(1), u[3] = s2[a2 + 3].usrCoords.slice(1)), _ = this._bezierBbox(u), this._bezierOverlap(p, _)) {
          if (0 === (f = this.meetBeziersegmentBeziersegment(d, u)).length)
            continue;
          for (l2 = 0; l2 < f.length; l2++)
            (c2 = f[l2])[1] < -n.Z.eps || c2[1] > 1 + n.Z.eps || c2[2] < -n.Z.eps || c2[2] > 1 + n.Z.eps || C.push(c2);
          if (C.length > b)
            return C[b][0];
        }
    return C.length > b ? C[b][0] : [0, NaN, NaN];
  }, bezierSegmentEval: function(t2, e2) {
    var i3, s2, r3, o2 = 1 - t2;
    return s2 = 0, r3 = 0, s2 += (i3 = o2 * o2 * o2) * e2[0][0], r3 += i3 * e2[0][1], s2 += (i3 = 3 * t2 * o2 * o2) * e2[1][0], r3 += i3 * e2[1][1], s2 += (i3 = 3 * t2 * t2 * o2) * e2[2][0], r3 += i3 * e2[2][1], [1, s2 += (i3 = t2 * t2 * t2) * e2[3][0], r3 += i3 * e2[3][1]];
  }, bezierArc: function(t2, e2, i3, s2, r3) {
    var o2, a2, h2, l2, c2, d, u, p, _, f, b, g, m, v, Z, C, y, P = 0.5 * Math.PI, E = e2[1], O = e2[2], x = e2[0], w = [], S = [];
    for (c2 = this.distance(e2, t2), E /= x, O /= x, d = this.rad(t2.slice(1), e2.slice(1), i3.slice(1)), -1 === r3 && (d = 2 * Math.PI - d), (o2 = t2)[1] /= o2[0], o2[2] /= o2[0], o2[0] /= o2[0], l2 = o2.slice(0), s2 ? (w = [E, E + 0.333 * (o2[1] - E), E + 0.666 * (o2[1] - E), o2[1]], S = [O, O + 0.333 * (o2[2] - O), O + 0.666 * (o2[2] - O), o2[2]]) : (w = [o2[1]], S = [o2[2]]); d > n.Z.eps; )
      d > P ? (u = P, d -= P) : (u = d, d = 0), y = [[1, 0, 0], [E * (1 - (p = Math.cos(r3 * u))) + O * (_ = Math.sin(r3 * u)), p, -_], [O * (1 - p) - E * _, _, p]], l2 = [(Z = n.Z.matVecMult(y, o2))[0] / Z[0], Z[1] / Z[0], Z[2] / Z[0]], f = o2[1] - E, b = o2[2] - O, g = l2[1] - E, m = l2[2] - O, C = Math.sqrt((f + g) * (f + g) + (b + m) * (b + m)), v = Math.abs(m - b) > n.Z.eps ? (f + g) * (c2 / C - 0.5) / (m - b) * 8 / 3 : (b + m) * (c2 / C - 0.5) / (f - g) * 8 / 3, a2 = [1, o2[1] - v * b, o2[2] + v * f], h2 = [1, l2[1] + v * m, l2[2] - v * g], w = w.concat([a2[1], h2[1], l2[1]]), S = S.concat([a2[2], h2[2], l2[2]]), o2 = l2.slice(0);
    return s2 && (w = w.concat([l2[1] + 0.333 * (E - l2[1]), l2[1] + 0.666 * (E - l2[1]), E]), S = S.concat([l2[2] + 0.333 * (O - l2[2]), l2[2] + 0.666 * (O - l2[2]), O])), [w, S];
  }, projectPointToCircle: function(t2, e2, i3) {
    var s2, a2, l2, c2, d, u = e2.center.coords.usrCoords;
    return h.Z.exists(i3) || (i3 = t2.board), h.Z.isPoint(t2) ? (s2 = t2.coords.distance(r2.Z.COORDS_BY_USER, e2.center.coords), a2 = t2.coords.usrCoords) : (s2 = t2.distance(r2.Z.COORDS_BY_USER, e2.center.coords), a2 = t2.usrCoords), Math.abs(s2) < n.Z.eps && (s2 = n.Z.eps), d = e2.Radius() / s2, l2 = u[1] + d * (a2[1] - u[1]), c2 = u[2] + d * (a2[2] - u[2]), new o.Z(r2.Z.COORDS_BY_USER, [l2, c2], i3);
  }, projectPointToLine: function(t2, e2, i3) {
    var s2, a2 = [0, e2.stdform[1], e2.stdform[2]];
    return h.Z.exists(i3) || (i3 = h.Z.exists(t2.coords) ? t2.board : e2.board), s2 = h.Z.exists(t2.coords) ? t2.coords.usrCoords : t2.usrCoords, a2 = n.Z.crossProduct(a2, s2), new o.Z(r2.Z.COORDS_BY_USER, n.Z.crossProduct(a2, e2.stdform), i3);
  }, projectCoordsToSegment: function(t2, e2, i3) {
    var s2, r3 = [i3[1] - e2[1], i3[2] - e2[2]], o2 = [t2[1] - e2[1], t2[2] - e2[2]];
    return Math.abs(r3[0]) < n.Z.eps && Math.abs(r3[1]) < n.Z.eps ? [e2, 0] : (s2 = n.Z.innerProduct(o2, r3), [[1, (s2 /= n.Z.innerProduct(r3, r3)) * r3[0] + e2[1], s2 * r3[1] + e2[2]], s2]);
  }, projectCoordsToBeziersegment: function(t2, e2, i3) {
    var r3;
    return r3 = s.Z.Math.Numerics.fminbr(function(s2) {
      var r4 = [1, e2.X(i3 + s2), e2.Y(i3 + s2)];
      return r4[1] -= t2[1], r4[2] -= t2[2], r4[1] * r4[1] + r4[2] * r4[2];
    }, [0, 1]), [[1, e2.X(r3 + i3), e2.Y(r3 + i3)], r3];
  }, projectPointToCurve: function(t2, e2, i3) {
    h.Z.exists(i3) || (i3 = t2.board);
    var s2 = t2.X(), r3 = t2.Y(), o2 = t2.position || 0;
    return this.projectCoordsToCurve(s2, r3, o2, e2, i3);
  }, projectCoordsToCurve: function(t2, e2, i3, s2, n2) {
    var l2, c2, d, u, p, _, f, b, g, m, v, Z, C, y, P, E, O, x, w, S, T = Number.POSITIVE_INFINITY;
    if (h.Z.exists(n2) || (n2 = s2.board), "plot" === h.Z.evaluate(s2.visProp.curvetype)) {
      if (i3 = 0, p = T, l2 = 0 === s2.numberPoints ? [0, 1, 1] : [s2.Z(0), s2.X(0), s2.Y(0)], s2.numberPoints > 1)
        for (b = [1, t2, e2], 3 === s2.bezierDegree ? u = 0 : v = [s2.Z(0), s2.X(0), s2.Y(0)], d = 0; d < s2.numberPoints - 1; d++)
          3 === s2.bezierDegree ? C = this.projectCoordsToBeziersegment(b, s2, u) : (Z = [s2.Z(d + 1), s2.X(d + 1), s2.Y(d + 1)], C = this.projectCoordsToSegment(b, v, Z)), f = C[1], g = C[0], 0 <= f && f <= 1 ? (_ = this.distance(g, b), m = d + f) : f < 0 ? (g = v, _ = this.distance(v, b), m = d) : f > 1 && d === s2.numberPoints - 2 && (g = Z, _ = this.distance(g, b), m = s2.numberPoints - 1), _ < p && (p = _, i3 = m, l2 = g), 3 === s2.bezierDegree ? (u++, d += 2) : v = Z;
      c2 = new o.Z(r2.Z.COORDS_BY_USER, l2, n2);
    } else {
      for (y = function(i4) {
        var r3, o2;
        return i4 < s2.minX() || i4 > s2.maxX() ? 1 / 0 : (r3 = t2 - s2.X(i4)) * r3 + (o2 = e2 - s2.Y(i4)) * o2;
      }, O = y(i3), w = s2.minX(), x = ((S = s2.maxX()) - w) / 50, P = w, d = 0; d < 50; d++)
        ((E = y(P)) < O || O === 1 / 0 || isNaN(O)) && (i3 = P, O = E), P += x;
      i3 = (i3 = (i3 = a.Z.fminbr(y, [Math.max(i3 - x, w), Math.min(i3 + x, S)])) < w ? w : i3) > S ? S : i3, c2 = new o.Z(r2.Z.COORDS_BY_USER, [s2.X(i3), s2.Y(i3)], n2);
    }
    return [s2.updateTransform(c2), i3];
  }, projectCoordsToPolygon: function(t2, e2) {
    var i3, r3, o2, n2, a2, h2 = e2.vertices.length, l2 = 1 / 0;
    for (i3 = 0; i3 < h2 - 1; i3++)
      0 <= (o2 = s.Z.Math.Geometry.projectCoordsToSegment(t2, e2.vertices[i3].coords.usrCoords, e2.vertices[i3 + 1].coords.usrCoords))[1] && o2[1] <= 1 ? (r3 = s.Z.Math.Geometry.distance(o2[0], t2, 3), n2 = o2[0]) : o2[1] < 0 ? (r3 = s.Z.Math.Geometry.distance(e2.vertices[i3].coords.usrCoords, t2, 3), n2 = e2.vertices[i3].coords.usrCoords) : (r3 = s.Z.Math.Geometry.distance(e2.vertices[i3 + 1].coords.usrCoords, t2, 3), n2 = e2.vertices[i3 + 1].coords.usrCoords), r3 < l2 && (a2 = n2.slice(0), l2 = r3);
    return a2;
  }, projectPointToTurtle: function(t2, e2, i3) {
    var s2, n2, a2, l2, c2, d, u, p, _, f, b = 0, g = 0, m = Number.POSITIVE_INFINITY, v = e2.objects.length;
    for (h.Z.exists(i3) || (i3 = t2.board), c2 = 0; c2 < v; c2++)
      (u = e2.objects[c2]).elementClass === r2.Z.OBJECT_CLASS_CURVE && (s2 = (_ = this.projectPointToCurve(t2, u))[0], f = _[1], (d = this.distance(s2.usrCoords, t2.coords.usrCoords)) < m && (a2 = s2.usrCoords[1], l2 = s2.usrCoords[2], n2 = f, m = d, p = u, g = b), b += u.numberPoints);
    return s2 = new o.Z(r2.Z.COORDS_BY_USER, [a2, l2], i3), [p.updateTransform(s2), n2 + g];
  }, projectPointToPoint: function(t2, e2) {
    return e2.coords;
  }, projectPointToBoard: function(t2, e2) {
    var i3, s2, r3, o2 = e2 || t2.board, a2 = [[1, 1, 0, 0, 3, 0, 1], [-1, 2, 1, 0, 1, 2, 1], [-1, 1, 2, 2, 1, 2, 3], [1, 2, 3, 0, 3, 2, 3]], h2 = t2.coords || t2, l2 = o2.getBoundingBox();
    for (i3 = 0; i3 < 4; i3++)
      (r3 = a2[i3])[0] * h2.usrCoords[r3[1]] < r3[0] * l2[r3[2]] && ((s2 = n.Z.crossProduct([1, l2[r3[3]], l2[r3[4]]], [1, l2[r3[5]], l2[r3[6]]]))[3] = 0, s2 = n.Z.normalize(s2), h2 = this.projectPointToLine({ coords: h2 }, { stdform: s2 }, o2));
    return h2;
  }, distPointLine: function(t2, e2) {
    var i3, s2 = e2[1], r3 = e2[2], o2 = e2[0];
    return Math.abs(s2) + Math.abs(r3) < n.Z.eps ? Number.POSITIVE_INFINITY : (i3 = s2 * t2[1] + r3 * t2[2] + o2, s2 *= s2, r3 *= r3, Math.abs(i3) / Math.sqrt(s2 + r3));
  }, reuleauxPolygon: function(t2, e2) {
    var i3, s2 = 2 * Math.PI, r3 = s2 / e2, o2 = (e2 - 1) / 2, a2 = 0, h2 = function(h3, l2) {
      return function(c2, d) {
        var u = (c2 % s2 + s2) % s2, p = Math.floor(u / r3) % e2;
        return d || (a2 = t2[0].Dist(t2[o2]), i3 = n.Z.Geometry.rad([t2[0].X() + 1, t2[0].Y()], t2[0], t2[o2 % e2])), isNaN(p) ? p : (u = 0.5 * u + p * r3 * 0.5 + i3, t2[p][h3]() + a2 * Math[l2](u));
      };
    };
    return [h2("X", "cos"), h2("Y", "sin"), 0, s2];
  }, meet3Planes: function(t2, e2, i3, s2, r3, o2) {
    var a2, h2, l2, c2, d, u = [0, 0, 0];
    for (a2 = n.Z.crossProduct(r3, t2), h2 = n.Z.crossProduct(t2, i3), l2 = n.Z.crossProduct(i3, r3), c2 = n.Z.innerProduct(t2, l2, 3), d = 0; d < 3; d++)
      u[d] = (e2 * l2[d] + s2 * a2[d] + o2 * h2[d]) / c2;
    return u;
  }, meetPlanePlane: function(t2, e2, i3, s2) {
    var r3, o2, a2, l2 = [0, 0, 0], c2 = [0, 0, 0];
    for (r3 = 0; r3 < 3; r3++)
      l2[r3] = h.Z.evaluate(t2[r3]), c2[r3] = h.Z.evaluate(e2[r3]);
    for (o2 = n.Z.crossProduct(l2, c2), r3 = 0; r3 < 3; r3++)
      l2[r3] = h.Z.evaluate(i3[r3]), c2[r3] = h.Z.evaluate(s2[r3]);
    return a2 = n.Z.crossProduct(l2, c2), n.Z.crossProduct(o2, a2);
  }, project3DTo3DPlane: function(t2, e2, i3) {
    var s2, r3;
    return i3 = i3 || [0, 0, 0], s2 = n.Z.norm(e2), r3 = (n.Z.innerProduct(t2, e2, 3) - n.Z.innerProduct(i3, e2, 3)) / s2, n.Z.axpy(-r3, e2, t2);
  }, getPlaneBounds: function(t2, e2, i3, s2, r3) {
    var o2, n2, h2, l2, c2;
    return t2[2] + e2[0] !== 0 ? (h2 = [[t2[0], e2[0]], [t2[1], e2[1]]], l2 = [s2 - i3[0], s2 - i3[1]], o2 = (c2 = a.Z.Gauss(h2, l2))[0], n2 = c2[1], l2 = [r3 - i3[0], r3 - i3[1]], [o2, (c2 = a.Z.Gauss(h2, l2))[0], n2, c2[1]]) : null;
  } });
  const c = n.Z.Geometry;
}, 785: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(275), o = i2(109);
  s.Z.Math.DoubleBits = function() {
    var t2, e2, i3, s2, r3, o2, n2, a2, h2 = new Float64Array(1), l = new Uint32Array(h2.buffer);
    void 0 !== Float64Array && (h2[0] = 1, 1072693248 === l[1] ? (t2 = function(t3) {
      return h2[0] = t3, [l[0], l[1]];
    }, e2 = function(t3, e3) {
      return l[0] = t3, l[1] = e3, h2[0];
    }, i3 = function(t3) {
      return h2[0] = t3, l[0];
    }, s2 = function(t3) {
      return h2[0] = t3, l[1];
    }, this.doubleBits = t2, this.pack = e2, this.lo = i3, this.hi = s2) : 1072693248 === l[0] && (r3 = function(t3) {
      return h2[0] = t3, [l[1], l[0]];
    }, o2 = function(t3, e3) {
      return l[1] = t3, l[0] = e3, h2[0];
    }, n2 = function(t3) {
      return h2[0] = t3, l[1];
    }, a2 = function(t3) {
      return h2[0] = t3, l[0];
    }, this.doubleBits = r3, this.pack = o2, this.lo = n2, this.hi = a2));
  }, s.Z.extend(s.Z.Math.DoubleBits.prototype, { sign: function(t2) {
    return this.hi(t2) >>> 31;
  }, exponent: function(t2) {
    return (this.hi(t2) << 1 >>> 21) - 1023;
  }, fraction: function(t2) {
    var e2 = this.lo(t2), i3 = this.hi(t2), s2 = 1048575 & i3;
    return 2146435072 & i3 && (s2 += 1 << 20), [e2, s2];
  }, denormalized: function(t2) {
    return !(2146435072 & this.hi(t2));
  } });
  var n = new s.Z.Math.DoubleBits(), a = function(t2, e2) {
    if (void 0 !== t2 && void 0 !== e2) {
      if (r2.Z.IntervalArithmetic.isInterval(t2)) {
        if (!r2.Z.IntervalArithmetic.isSingleton(t2))
          throw new TypeError("JXG.Math.IntervalArithmetic: interval `lo` must be a singleton");
        this.lo = t2.lo;
      } else
        this.lo = t2;
      if (r2.Z.IntervalArithmetic.isInterval(e2)) {
        if (!r2.Z.IntervalArithmetic.isSingleton(e2))
          throw new TypeError("JXG.Math.IntervalArithmetic: interval `hi` must be a singleton");
        this.hi = e2.hi;
      } else
        this.hi = e2;
    } else {
      if (void 0 !== t2)
        return Array.isArray(t2) ? new a(t2[0], t2[1]) : new a(t2, t2);
      this.lo = this.hi = 0;
    }
  };
  s.Z.extend(a.prototype, { print: function() {
    console.log("[", this.lo, this.hi, "]");
  }, set: function(t2, e2) {
    return this.lo = t2, this.hi = e2, this;
  }, bounded: function(t2, e2) {
    return this.set(r2.Z.IntervalArithmetic.prev(t2), r2.Z.IntervalArithmetic.next(e2));
  }, boundedSingleton: function(t2) {
    return this.bounded(t2, t2);
  }, assign: function(t2, e2) {
    if ("number" != typeof t2 || "number" != typeof e2)
      throw new TypeError("JXG.Math.Interval#assign: arguments must be numbers");
    return isNaN(t2) || isNaN(e2) || t2 > e2 ? this.setEmpty() : this.set(t2, e2);
  }, setEmpty: function() {
    return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
  }, setWhole: function() {
    return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
  }, open: function(t2, e2) {
    return this.assign(r2.Z.IntervalArithmetic.next(t2), r2.Z.IntervalArithmetic.prev(e2));
  }, halfOpenLeft: function(t2, e2) {
    return this.assign(r2.Z.IntervalArithmetic.next(t2), e2);
  }, halfOpenRight: function(t2, e2) {
    return this.assign(t2, r2.Z.IntervalArithmetic.prev(e2));
  }, toArray: function() {
    return [this.lo, this.hi];
  }, clone: function() {
    return new a().set(this.lo, this.hi);
  } }), s.Z.Math.IntervalArithmetic = { Interval: function(t2, e2) {
    return new a(t2, e2);
  }, isInterval: function(t2) {
    return null !== t2 && "object" == typeof t2 && "number" == typeof t2.lo && "number" == typeof t2.hi;
  }, isSingleton: function(t2) {
    return t2.lo === t2.hi;
  }, add: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), new a(this.addLo(t2.lo, e2.lo), this.addHi(t2.hi, e2.hi));
  }, sub: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), new a(this.subLo(t2.lo, e2.hi), this.subHi(t2.hi, e2.lo));
  }, mul: function(t2, e2) {
    var i3, s2, r3, n2, h2;
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), this.isEmpty(t2) || this.isEmpty(e2) ? this.EMPTY.clone() : (i3 = t2.lo, s2 = t2.hi, r3 = e2.lo, n2 = e2.hi, h2 = new a(), i3 < 0 ? s2 > 0 ? r3 < 0 ? n2 > 0 ? (h2.lo = Math.min(this.mulLo(i3, n2), this.mulLo(s2, r3)), h2.hi = Math.max(this.mulHi(i3, r3), this.mulHi(s2, n2))) : (h2.lo = this.mulLo(s2, r3), h2.hi = this.mulHi(i3, r3)) : n2 > 0 ? (h2.lo = this.mulLo(i3, n2), h2.hi = this.mulHi(s2, n2)) : (h2.lo = 0, h2.hi = 0) : r3 < 0 ? n2 > 0 ? (h2.lo = this.mulLo(i3, n2), h2.hi = this.mulHi(i3, r3)) : (h2.lo = this.mulLo(s2, n2), h2.hi = this.mulHi(i3, r3)) : n2 > 0 ? (h2.lo = this.mulLo(i3, n2), h2.hi = this.mulHi(s2, r3)) : (h2.lo = 0, h2.hi = 0) : s2 > 0 ? r3 < 0 ? n2 > 0 ? (h2.lo = this.mulLo(s2, r3), h2.hi = this.mulHi(s2, n2)) : (h2.lo = this.mulLo(s2, r3), h2.hi = this.mulHi(i3, n2)) : n2 > 0 ? (h2.lo = this.mulLo(i3, r3), h2.hi = this.mulHi(s2, n2)) : (h2.lo = 0, h2.hi = 0) : (h2.lo = 0, h2.hi = 0), h2);
  }, div: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), this.isEmpty(t2) || this.isEmpty(e2) ? this.EMPTY.clone() : this.zeroIn(e2) ? 0 !== e2.lo ? 0 !== e2.hi ? this.divZero(t2) : this.divNegative(t2, e2.lo) : 0 !== e2.hi ? this.divPositive(t2, e2.hi) : this.EMPTY.clone() : this.divNonZero(t2, e2);
  }, positive: function(t2) {
    return new a(t2.lo, t2.hi);
  }, negative: function(t2) {
    return o.Z.isNumber(t2) ? new a(-t2) : new a(-t2.hi, -t2.lo);
  }, isEmpty: function(t2) {
    return t2.lo > t2.hi;
  }, isWhole: function(t2) {
    return t2.lo === -1 / 0 && t2.hi === 1 / 0;
  }, zeroIn: function(t2) {
    return this.hasValue(t2, 0);
  }, hasValue: function(t2, e2) {
    return !this.isEmpty(t2) && (t2.lo <= e2 && e2 <= t2.hi);
  }, hasInterval: function(t2, e2) {
    return !!this.isEmpty(t2) || !this.isEmpty(e2) && e2.lo <= t2.lo && t2.hi <= e2.hi;
  }, intervalsOverlap: function(t2, e2) {
    return !this.isEmpty(t2) && !this.isEmpty(e2) && (t2.lo <= e2.lo && e2.lo <= t2.hi || e2.lo <= t2.lo && t2.lo <= e2.hi);
  }, divNonZero: function(t2, e2) {
    var i3 = t2.lo, s2 = t2.hi, r3 = e2.lo, o2 = e2.hi, n2 = new a();
    return s2 < 0 ? o2 < 0 ? (n2.lo = this.divLo(s2, r3), n2.hi = this.divHi(i3, o2)) : (n2.lo = this.divLo(i3, r3), n2.hi = this.divHi(s2, o2)) : i3 < 0 ? o2 < 0 ? (n2.lo = this.divLo(s2, o2), n2.hi = this.divHi(i3, o2)) : (n2.lo = this.divLo(i3, r3), n2.hi = this.divHi(s2, r3)) : o2 < 0 ? (n2.lo = this.divLo(s2, o2), n2.hi = this.divHi(i3, r3)) : (n2.lo = this.divLo(i3, o2), n2.hi = this.divHi(s2, r3)), n2;
  }, divPositive: function(t2, e2) {
    return 0 === t2.lo && 0 === t2.hi ? t2 : this.zeroIn(t2) ? this.WHOLE : t2.hi < 0 ? new a(Number.NEGATIVE_INFINITY, this.divHi(t2.hi, e2)) : new a(this.divLo(t2.lo, e2), Number.POSITIVE_INFINITY);
  }, divNegative: function(t2, e2) {
    return 0 === t2.lo && 0 === t2.hi ? t2 : this.zeroIn(t2) ? this.WHOLE : t2.hi < 0 ? new a(this.divLo(t2.hi, e2), Number.POSITIVE_INFINITY) : new a(Number.NEGATIVE_INFINITY, this.divHi(t2.lo, e2));
  }, divZero: function(t2) {
    return 0 === t2.lo && 0 === t2.hi ? t2 : this.WHOLE;
  }, fmod: function(t2, e2) {
    var i3, s2;
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), this.isEmpty(t2) || this.isEmpty(e2) ? this.EMPTY.clone() : (i3 = t2.lo < 0 ? e2.lo : e2.hi, s2 = (s2 = t2.lo / i3) < 0 ? Math.ceil(s2) : Math.floor(s2), this.sub(t2, this.mul(e2, new a(s2))));
  }, multiplicativeInverse: function(t2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : this.zeroIn(t2) ? 0 !== t2.lo ? 0 !== t2.hi ? this.WHOLE : new a(Number.NEGATIVE_INFINITY, this.divHi(1, t2.lo)) : 0 !== t2.hi ? new a(this.divLo(1, t2.hi), Number.POSITIVE_INFINITY) : this.EMPTY.clone() : new a(this.divLo(1, t2.hi), this.divHi(1, t2.lo));
  }, pow: function(t2, e2) {
    var i3, s2;
    if (o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2))
      return this.EMPTY.clone();
    if (this.isInterval(e2)) {
      if (!this.isSingleton(e2))
        return this.EMPTY.clone();
      e2 = e2.lo;
    }
    return 0 === e2 ? 0 === t2.lo && 0 === t2.hi ? this.EMPTY.clone() : this.ONE.clone() : e2 < 0 ? this.pow(this.multiplicativeInverse(t2), -e2) : e2 % 1 == 0 ? t2.hi < 0 ? (i3 = this.powLo(-t2.hi, e2), s2 = this.powHi(-t2.lo, e2), 1 == (1 & e2) ? new a(-s2, -i3) : new a(i3, s2)) : t2.lo < 0 ? 1 == (1 & e2) ? new a(-this.powLo(-t2.lo, e2), this.powHi(t2.hi, e2)) : new a(0, this.powHi(Math.max(-t2.lo, t2.hi), e2)) : new a(this.powLo(t2.lo, e2), this.powHi(t2.hi, e2)) : (console.warn("power is not an integer, you should use nth-root instead, returning an empty interval"), this.EMPTY.clone());
  }, sqrt: function(t2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.nthRoot(t2, 2);
  }, nthRoot: function(t2, e2) {
    var i3, s2, r3, n2, h2;
    if (o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) || e2 < 0)
      return this.EMPTY.clone();
    if (this.isInterval(e2)) {
      if (!this.isSingleton(e2))
        return this.EMPTY.clone();
      e2 = e2.lo;
    }
    return i3 = 1 / e2, t2.hi < 0 ? e2 % 1 == 0 && 1 == (1 & e2) ? (s2 = this.powHi(-t2.lo, i3), r3 = this.powLo(-t2.hi, i3), new a(-s2, -r3)) : this.EMPTY.clone() : t2.lo < 0 ? (n2 = this.powHi(t2.hi, i3), e2 % 1 == 0 && 1 == (1 & e2) ? (h2 = -this.powHi(-t2.lo, i3), new a(h2, n2)) : new a(0, n2)) : new a(this.powLo(t2.lo, i3), this.powHi(t2.hi, i3));
  }, exp: function(t2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : new a(this.expLo(t2.lo), this.expHi(t2.hi));
  }, log: function(t2) {
    var e2;
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : (e2 = t2.lo <= 0 ? Number.NEGATIVE_INFINITY : this.logLo(t2.lo), new a(e2, this.logHi(t2.hi)));
  }, ln: function(t2) {
    return this.log(t2);
  }, log10: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : this.div(this.log(t2), this.log(new a(10, 10)));
  }, log2: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : this.div(this.log(t2), this.log(new a(2, 2)));
  }, hull: function(t2, e2) {
    var i3 = this.isEmpty(t2), s2 = this.isEmpty(e2);
    return i3 && s2 ? this.EMPTY.clone() : i3 ? e2.clone() : s2 ? t2.clone() : new a(Math.min(t2.lo, e2.lo), Math.max(t2.hi, e2.hi));
  }, intersection: function(t2, e2) {
    var i3, s2;
    return this.isEmpty(t2) || this.isEmpty(e2) ? this.EMPTY.clone() : (i3 = Math.max(t2.lo, e2.lo)) <= (s2 = Math.min(t2.hi, e2.hi)) ? new a(i3, s2) : this.EMPTY.clone();
  }, union: function(t2, e2) {
    if (!this.intervalsOverlap(t2, e2))
      throw new Error("Interval#unions do not overlap");
    return new a(Math.min(t2.lo, e2.lo), Math.max(t2.hi, e2.hi));
  }, difference: function(t2, e2) {
    if (this.isEmpty(t2) || this.isWhole(e2))
      return this.EMPTY.clone();
    if (this.intervalsOverlap(t2, e2)) {
      if (t2.lo < e2.lo && e2.hi < t2.hi)
        throw new Error("Interval.difference: difference creates multiple intervals");
      return e2.lo <= t2.lo && e2.hi === 1 / 0 || e2.hi >= t2.hi && e2.lo === -1 / 0 ? this.EMPTY.clone() : e2.lo <= t2.lo ? new a().halfOpenLeft(e2.hi, t2.hi) : new a().halfOpenRight(t2.lo, e2.lo);
    }
    return t2.clone();
  }, width: function(t2) {
    return this.isEmpty(t2) ? 0 : this.subHi(t2.hi, t2.lo);
  }, abs: function(t2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : t2.lo >= 0 ? t2.clone() : t2.hi <= 0 ? this.negative(t2) : new a(0, Math.max(-t2.lo, t2.hi));
  }, max: function(t2, e2) {
    var i3 = this.isEmpty(t2), s2 = this.isEmpty(e2);
    return i3 && s2 ? this.EMPTY.clone() : i3 ? e2.clone() : s2 ? t2.clone() : new a(Math.max(t2.lo, e2.lo), Math.max(t2.hi, e2.hi));
  }, min: function(t2, e2) {
    var i3 = this.isEmpty(t2), s2 = this.isEmpty(e2);
    return i3 && s2 ? this.EMPTY.clone() : i3 ? e2.clone() : s2 ? t2.clone() : new a(Math.min(t2.lo, e2.lo), Math.min(t2.hi, e2.hi));
  }, onlyInfinity: function(t2) {
    return !isFinite(t2.lo) && t2.lo === t2.hi;
  }, _handleNegative: function(t2) {
    var e2;
    return t2.lo < 0 && (t2.lo === -1 / 0 ? (t2.lo = 0, t2.hi = 1 / 0) : (e2 = Math.ceil(-t2.lo / this.piTwiceLow), t2.lo += this.piTwiceLow * e2, t2.hi += this.piTwiceLow * e2)), t2;
  }, cos: function(t2) {
    var e2, i3, s2, r3, o2, n2, h2, l;
    return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : (e2 = new a().set(t2.lo, t2.hi), this._handleNegative(e2), i3 = this.PI_TWICE, s2 = this.fmod(e2, i3), this.width(s2) >= i3.lo ? new a(-1, 1) : s2.lo >= this.piHigh ? (r3 = this.cos(this.sub(s2, this.PI)), this.negative(r3)) : (o2 = s2.lo, n2 = s2.hi, h2 = this.cosLo(n2), l = this.cosHi(o2), n2 <= this.piLow ? new a(h2, l) : n2 <= i3.lo ? new a(-1, Math.max(h2, l)) : new a(-1, 1)));
  }, sin: function(t2) {
    return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : this.cos(this.sub(t2, this.PI_HALF));
  }, tan: function(t2) {
    var e2, i3, s2;
    return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : (e2 = new a().set(t2.lo, t2.hi), this._handleNegative(e2), s2 = this.PI, (i3 = this.fmod(e2, s2)).lo >= this.piHalfLow && (i3 = this.sub(i3, s2)), i3.lo <= -this.piHalfLow || i3.hi >= this.piHalfLow ? this.WHOLE.clone() : new a(this.tanLo(i3.lo), this.tanHi(i3.hi)));
  }, asin: function(t2) {
    var e2, i3;
    return this.isEmpty(t2) || t2.hi < -1 || t2.lo > 1 ? this.EMPTY.clone() : (e2 = t2.lo <= -1 ? -this.piHalfHigh : this.asinLo(t2.lo), i3 = t2.hi >= 1 ? this.piHalfHigh : this.asinHi(t2.hi), new a(e2, i3));
  }, acos: function(t2) {
    var e2, i3;
    return this.isEmpty(t2) || t2.hi < -1 || t2.lo > 1 ? this.EMPTY.clone() : (e2 = t2.hi >= 1 ? 0 : this.acosLo(t2.hi), i3 = t2.lo <= -1 ? this.piHigh : this.acosHi(t2.lo), new a(e2, i3));
  }, atan: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : new a(this.atanLo(t2.lo), this.atanHi(t2.hi));
  }, sinh: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : new a(this.sinhLo(t2.lo), this.sinhHi(t2.hi));
  }, cosh: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : t2.hi < 0 ? new a(this.coshLo(t2.hi), this.coshHi(t2.lo)) : t2.lo >= 0 ? new a(this.coshLo(t2.lo), this.coshHi(t2.hi)) : new a(1, this.coshHi(-t2.lo > t2.hi ? t2.lo : t2.hi));
  }, tanh: function(t2) {
    return this.isEmpty(t2) ? this.EMPTY.clone() : new a(this.tanhLo(t2.lo), this.tanhHi(t2.hi));
  }, equal: function(t2, e2) {
    return this.isEmpty(t2) ? this.isEmpty(e2) : !this.isEmpty(e2) && t2.lo === e2.lo && t2.hi === e2.hi;
  }, notEqual: function(t2, e2) {
    return this.isEmpty(t2) ? !this.isEmpty(e2) : this.isEmpty(e2) || t2.hi < e2.lo || t2.lo > e2.hi;
  }, lt: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), !this.isEmpty(t2) && !this.isEmpty(e2) && t2.hi < e2.lo;
  }, gt: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), !this.isEmpty(t2) && !this.isEmpty(e2) && t2.lo > e2.hi;
  }, leq: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), !this.isEmpty(t2) && !this.isEmpty(e2) && t2.hi <= e2.lo;
  }, geq: function(t2, e2) {
    return o.Z.isNumber(t2) && (t2 = this.Interval(t2)), o.Z.isNumber(e2) && (e2 = this.Interval(e2)), !this.isEmpty(t2) && !this.isEmpty(e2) && t2.lo >= e2.hi;
  }, piLow: 3.141592653589793, piHigh: 3.1415926535897936, piHalfLow: 1.5707963267948966, piHalfHigh: 1.5707963267948968, piTwiceLow: 6.283185307179586, piTwiceHigh: 6.283185307179587, identity: function(t2) {
    return t2;
  }, _prev: function(t2) {
    return t2 === 1 / 0 ? t2 : this.nextafter(t2, -1 / 0);
  }, _next: function(t2) {
    return t2 === -1 / 0 ? t2 : this.nextafter(t2, 1 / 0);
  }, prev: function(t2) {
    return this._prev(t2);
  }, next: function(t2) {
    return this._next(t2);
  }, toInteger: function(t2) {
    return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
  }, addLo: function(t2, e2) {
    return this.prev(t2 + e2);
  }, addHi: function(t2, e2) {
    return this.next(t2 + e2);
  }, subLo: function(t2, e2) {
    return this.prev(t2 - e2);
  }, subHi: function(t2, e2) {
    return this.next(t2 - e2);
  }, mulLo: function(t2, e2) {
    return this.prev(t2 * e2);
  }, mulHi: function(t2, e2) {
    return this.next(t2 * e2);
  }, divLo: function(t2, e2) {
    return this.prev(t2 / e2);
  }, divHi: function(t2, e2) {
    return this.next(t2 / e2);
  }, intLo: function(t2) {
    return this.toInteger(this.prev(t2));
  }, intHi: function(t2) {
    return this.toInteger(this.next(t2));
  }, logLo: function(t2) {
    return this.prev(Math.log(t2));
  }, logHi: function(t2) {
    return this.next(Math.log(t2));
  }, expLo: function(t2) {
    return this.prev(Math.exp(t2));
  }, expHi: function(t2) {
    return this.next(Math.exp(t2));
  }, sinLo: function(t2) {
    return this.prev(Math.sin(t2));
  }, sinHi: function(t2) {
    return this.next(Math.sin(t2));
  }, cosLo: function(t2) {
    return this.prev(Math.cos(t2));
  }, cosHi: function(t2) {
    return this.next(Math.cos(t2));
  }, tanLo: function(t2) {
    return this.prev(Math.tan(t2));
  }, tanHi: function(t2) {
    return this.next(Math.tan(t2));
  }, asinLo: function(t2) {
    return this.prev(Math.asin(t2));
  }, asinHi: function(t2) {
    return this.next(Math.asin(t2));
  }, acosLo: function(t2) {
    return this.prev(Math.acos(t2));
  }, acosHi: function(t2) {
    return this.next(Math.acos(t2));
  }, atanLo: function(t2) {
    return this.prev(Math.atan(t2));
  }, atanHi: function(t2) {
    return this.next(Math.atan(t2));
  }, sinhLo: function(t2) {
    return this.prev(r2.Z.sinh(t2));
  }, sinhHi: function(t2) {
    return this.next(r2.Z.sinh(t2));
  }, coshLo: function(t2) {
    return this.prev(r2.Z.cosh(t2));
  }, coshHi: function(t2) {
    return this.next(r2.Z.cosh(t2));
  }, tanhLo: function(t2) {
    return this.prev(r2.Z.tanh(t2));
  }, tanhHi: function(t2) {
    return this.next(r2.Z.tanh(t2));
  }, sqrtLo: function(t2) {
    return this.prev(Math.sqrt(t2));
  }, sqrtHi: function(t2) {
    return this.next(Math.sqrt(t2));
  }, powLo: function(t2, e2) {
    var i3;
    if (e2 % 1 != 0)
      return this.prev(Math.pow(t2, e2));
    for (i3 = 1 == (1 & e2) ? t2 : 1, e2 >>= 1; e2 > 0; )
      t2 = this.mulLo(t2, t2), 1 == (1 & e2) && (i3 = this.mulLo(t2, i3)), e2 >>= 1;
    return i3;
  }, powHi: function(t2, e2) {
    var i3;
    if (e2 % 1 != 0)
      return this.next(Math.pow(t2, e2));
    for (i3 = 1 == (1 & e2) ? t2 : 1, e2 >>= 1; e2 > 0; )
      t2 = this.mulHi(t2, t2), 1 == (1 & e2) && (i3 = this.mulHi(t2, i3)), e2 >>= 1;
    return i3;
  }, disable: function() {
    this.next = this.prev = this.identity;
  }, enable: function() {
    this.prev = function(t2) {
      return this._prev(t2);
    }, this.next = function(t2) {
      return this._next(t2);
    };
  }, SMALLEST_DENORM: Math.pow(2, -1074), UINT_MAX: -1 >>> 0, nextafter: function(t2, e2) {
    var i3, s2;
    return isNaN(t2) || isNaN(e2) ? NaN : t2 === e2 ? t2 : 0 === t2 ? e2 < 0 ? -this.SMALLEST_DENORM : this.SMALLEST_DENORM : (s2 = n.hi(t2), i3 = n.lo(t2), e2 > t2 == t2 > 0 ? i3 === this.UINT_MAX ? (s2 += 1, i3 = 0) : i3 += 1 : 0 === i3 ? (i3 = this.UINT_MAX, s2 -= 1) : i3 -= 1, n.pack(i3, s2));
  } }, s.Z.Math.IntervalArithmetic.PI = new a(r2.Z.IntervalArithmetic.piLow, r2.Z.IntervalArithmetic.piHigh), s.Z.Math.IntervalArithmetic.PI_HALF = new a(r2.Z.IntervalArithmetic.piHalfLow, r2.Z.IntervalArithmetic.piHalfHigh), s.Z.Math.IntervalArithmetic.PI_TWICE = new a(r2.Z.IntervalArithmetic.piTwiceLow, r2.Z.IntervalArithmetic.piTwiceHigh), s.Z.Math.IntervalArithmetic.ZERO = new a(0), s.Z.Math.IntervalArithmetic.ONE = new a(1), s.Z.Math.IntervalArithmetic.WHOLE = new a().setWhole(), s.Z.Math.IntervalArithmetic.EMPTY = new a().setEmpty();
  const h = s.Z.Math.IntervalArithmetic;
}, 275: (t, e, i2) => {
  i2.d(e, { Z: () => a });
  var s, r2 = i2(765), o = i2(109), n = function(t2) {
    var e2, i3;
    return t2.memo || (e2 = {}, i3 = Array.prototype.join, t2.memo = function() {
      var r3 = i3.call(arguments);
      return e2[r3] !== s ? e2[r3] : e2[r3] = t2.apply(this, arguments);
    }), t2.memo;
  };
  r2.Z.Math = { eps: 1e-6, relDif: function(t2, e2) {
    var i3 = Math.abs(t2), s2 = Math.abs(e2);
    return 0 === (s2 = Math.max(i3, s2)) ? 0 : Math.abs(t2 - e2) / s2;
  }, mod: function(t2, e2) {
    return t2 - Math.floor(t2 / e2) * e2;
  }, vector: function(t2, e2) {
    var i3, s2;
    for (e2 = e2 || 0, i3 = [], s2 = 0; s2 < t2; s2++)
      i3[s2] = e2;
    return i3;
  }, matrix: function(t2, e2, i3) {
    var s2, r3, o2;
    for (i3 = i3 || 0, e2 = e2 || t2, s2 = [], r3 = 0; r3 < t2; r3++)
      for (s2[r3] = [], o2 = 0; o2 < e2; o2++)
        s2[r3][o2] = i3;
    return s2;
  }, identity: function(t2, e2) {
    var i3, r3;
    for (e2 === s && "number" != typeof e2 && (e2 = t2), i3 = this.matrix(t2, e2), r3 = 0; r3 < Math.min(t2, e2); r3++)
      i3[r3][r3] = 1;
    return i3;
  }, frustum: function(t2, e2, i3, s2, r3, o2) {
    var n2 = this.matrix(4, 4);
    return n2[0][0] = 2 * r3 / (e2 - t2), n2[0][1] = 0, n2[0][2] = (e2 + t2) / (e2 - t2), n2[0][3] = 0, n2[1][0] = 0, n2[1][1] = 2 * r3 / (s2 - i3), n2[1][2] = (s2 + i3) / (s2 - i3), n2[1][3] = 0, n2[2][0] = 0, n2[2][1] = 0, n2[2][2] = -(o2 + r3) / (o2 - r3), n2[2][3] = -o2 * r3 * 2 / (o2 - r3), n2[3][0] = 0, n2[3][1] = 0, n2[3][2] = -1, n2[3][3] = 0, n2;
  }, projection: function(t2, e2, i3, s2) {
    var r3 = i3 * Math.tan(t2 / 2), o2 = r3 * e2;
    return this.frustum(-o2, o2, -r3, r3, i3, s2);
  }, matVecMult: function(t2, e2) {
    var i3, s2, r3, o2 = t2.length, n2 = e2.length, a2 = [];
    if (3 === n2)
      for (i3 = 0; i3 < o2; i3++)
        a2[i3] = t2[i3][0] * e2[0] + t2[i3][1] * e2[1] + t2[i3][2] * e2[2];
    else
      for (i3 = 0; i3 < o2; i3++) {
        for (s2 = 0, r3 = 0; r3 < n2; r3++)
          s2 += t2[i3][r3] * e2[r3];
        a2[i3] = s2;
      }
    return a2;
  }, matMatMult: function(t2, e2) {
    var i3, s2, r3, o2, n2 = t2.length, a2 = n2 > 0 ? e2[0].length : 0, h = e2.length, l = this.matrix(n2, a2);
    for (i3 = 0; i3 < n2; i3++)
      for (s2 = 0; s2 < a2; s2++) {
        for (r3 = 0, o2 = 0; o2 < h; o2++)
          r3 += t2[i3][o2] * e2[o2][s2];
        l[i3][s2] = r3;
      }
    return l;
  }, transpose: function(t2) {
    var e2, i3, s2, r3, o2;
    for (r3 = t2.length, o2 = t2.length > 0 ? t2[0].length : 0, e2 = this.matrix(o2, r3), i3 = 0; i3 < o2; i3++)
      for (s2 = 0; s2 < r3; s2++)
        e2[i3][s2] = t2[s2][i3];
    return e2;
  }, inverse: function(t2) {
    var e2, i3, s2, r3, o2, n2, a2, h = t2.length, l = [], c = [], d = [];
    for (e2 = 0; e2 < h; e2++) {
      for (l[e2] = [], i3 = 0; i3 < h; i3++)
        l[e2][i3] = t2[e2][i3];
      c[e2] = e2;
    }
    for (i3 = 0; i3 < h; i3++) {
      for (o2 = Math.abs(l[i3][i3]), n2 = i3, e2 = i3 + 1; e2 < h; e2++)
        Math.abs(l[e2][i3]) > o2 && (o2 = Math.abs(l[e2][i3]), n2 = e2);
      if (o2 <= this.eps)
        return [];
      if (n2 > i3) {
        for (s2 = 0; s2 < h; s2++)
          a2 = l[i3][s2], l[i3][s2] = l[n2][s2], l[n2][s2] = a2;
        a2 = c[i3], c[i3] = c[n2], c[n2] = a2;
      }
      for (r3 = 1 / l[i3][i3], e2 = 0; e2 < h; e2++)
        l[e2][i3] *= r3;
      for (l[i3][i3] = r3, s2 = 0; s2 < h; s2++)
        if (s2 !== i3) {
          for (e2 = 0; e2 < h; e2++)
            e2 !== i3 && (l[e2][s2] -= l[e2][i3] * l[i3][s2]);
          l[i3][s2] = -r3 * l[i3][s2];
        }
    }
    for (e2 = 0; e2 < h; e2++) {
      for (s2 = 0; s2 < h; s2++)
        d[c[s2]] = l[e2][s2];
      for (s2 = 0; s2 < h; s2++)
        l[e2][s2] = d[s2];
    }
    return l;
  }, innerProduct: function(t2, e2, i3) {
    var r3, n2 = 0;
    for (i3 !== s && o.Z.isNumber(i3) || (i3 = t2.length), r3 = 0; r3 < i3; r3++)
      n2 += t2[r3] * e2[r3];
    return n2;
  }, crossProduct: function(t2, e2) {
    return [t2[1] * e2[2] - t2[2] * e2[1], t2[2] * e2[0] - t2[0] * e2[2], t2[0] * e2[1] - t2[1] * e2[0]];
  }, norm: function(t2, e2) {
    var i3, r3 = 0;
    for (e2 !== s && o.Z.isNumber(e2) || (e2 = t2.length), i3 = 0; i3 < e2; i3++)
      r3 += t2[i3] * t2[i3];
    return Math.sqrt(r3);
  }, axpy: function(t2, e2, i3) {
    var s2, r3 = e2.length, o2 = [];
    for (s2 = 0; s2 < r3; s2++)
      o2[s2] = t2 * e2[s2] + i3[s2];
    return o2;
  }, factorial: n(function(t2) {
    return t2 < 0 ? NaN : 0 === (t2 = Math.floor(t2)) || 1 === t2 ? 1 : t2 * this.factorial(t2 - 1);
  }), binomial: n(function(t2, e2) {
    var i3, s2;
    if (e2 > t2 || e2 < 0)
      return NaN;
    if (e2 = Math.round(e2), t2 = Math.round(t2), 0 === e2 || e2 === t2)
      return 1;
    for (i3 = 1, s2 = 0; s2 < e2; s2++)
      i3 *= t2 - s2, i3 /= s2 + 1;
    return i3;
  }), cosh: Math.cosh || function(t2) {
    return 0.5 * (Math.exp(t2) + Math.exp(-t2));
  }, sinh: Math.sinh || function(t2) {
    return 0.5 * (Math.exp(t2) - Math.exp(-t2));
  }, acosh: Math.acosh || function(t2) {
    return Math.log(t2 + Math.sqrt(t2 * t2 - 1));
  }, asinh: Math.asinh || function(t2) {
    return t2 === -1 / 0 ? t2 : Math.log(t2 + Math.sqrt(t2 * t2 + 1));
  }, cot: function(t2) {
    return 1 / Math.tan(t2);
  }, acot: function(t2) {
    return (t2 >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(t2);
  }, nthroot: function(t2, e2) {
    var i3 = 1 / e2;
    return e2 <= 0 || Math.floor(e2) !== e2 ? NaN : 0 === t2 ? 0 : t2 > 0 ? Math.exp(i3 * Math.log(t2)) : e2 % 2 == 1 ? -Math.exp(i3 * Math.log(-t2)) : NaN;
  }, cbrt: Math.cbrt || function(t2) {
    return this.nthroot(t2, 3);
  }, pow: function(t2, e2) {
    return 0 === t2 ? 0 === e2 ? 1 : 0 : Math.floor(e2) === e2 ? Math.pow(t2, e2) : t2 > 0 ? Math.exp(e2 * Math.log(t2)) : NaN;
  }, ratpow: function(t2, e2, i3) {
    var s2;
    return 0 === e2 ? 1 : 0 === i3 ? NaN : (s2 = this.gcd(e2, i3), this.nthroot(this.pow(t2, e2 / s2), i3 / s2));
  }, log10: function(t2) {
    return Math.log(t2) / Math.log(10);
  }, log2: function(t2) {
    return Math.log(t2) / Math.log(2);
  }, log: function(t2, e2) {
    return void 0 !== e2 && o.Z.isNumber(e2) ? Math.log(t2) / Math.log(e2) : Math.log(t2);
  }, sign: Math.sign || function(t2) {
    return 0 === (t2 = +t2) || isNaN(t2) ? t2 : t2 > 0 ? 1 : -1;
  }, squampow: function(t2, e2) {
    var i3;
    if (Math.floor(e2) === e2) {
      for (i3 = 1, e2 < 0 && (t2 = 1 / t2, e2 *= -1); 0 !== e2; )
        1 & e2 && (i3 *= t2), e2 >>= 1, t2 *= t2;
      return i3;
    }
    return this.pow(t2, e2);
  }, gcd: function(t2, e2) {
    var i3;
    if (t2 = Math.abs(t2), e2 = Math.abs(e2), !o.Z.isNumber(t2) || !o.Z.isNumber(e2))
      return NaN;
    for (e2 > t2 && (i3 = t2, t2 = e2, e2 = i3); ; ) {
      if (0 === (t2 %= e2))
        return e2;
      if (0 === (e2 %= t2))
        return t2;
    }
  }, lcm: function(t2, e2) {
    var i3;
    return o.Z.isNumber(t2) && o.Z.isNumber(e2) ? 0 !== (i3 = t2 * e2) ? i3 / this.gcd(t2, e2) : 0 : NaN;
  }, erf: function(t2) {
    return this.ProbFuncs.erf(t2);
  }, erfc: function(t2) {
    return this.ProbFuncs.erfc(t2);
  }, erfi: function(t2) {
    return this.ProbFuncs.erfi(t2);
  }, ndtr: function(t2) {
    return this.ProbFuncs.ndtr(t2);
  }, ndtri: function(t2) {
    return this.ProbFuncs.ndtri(t2);
  }, lt: function(t2, e2) {
    return t2 < e2;
  }, leq: function(t2, e2) {
    return t2 <= e2;
  }, gt: function(t2, e2) {
    return t2 > e2;
  }, geq: function(t2, e2) {
    return t2 >= e2;
  }, eq: function(t2, e2) {
    return t2 === e2;
  }, neq: function(t2, e2) {
    return t2 !== e2;
  }, and: function(t2, e2) {
    return t2 && e2;
  }, not: function(t2) {
    return !t2;
  }, or: function(t2, e2) {
    return t2 || e2;
  }, xor: function(t2, e2) {
    return (t2 || e2) && !(t2 && e2);
  }, normalize: function(t2) {
    var e2, i3, s2 = 2 * t2[3], r3 = t2[4] / s2;
    return t2[5] = r3, t2[6] = -t2[1] / s2, t2[7] = -t2[2] / s2, isFinite(r3) ? Math.abs(r3) >= 1 ? (t2[0] = (t2[6] * t2[6] + t2[7] * t2[7] - r3 * r3) / (2 * r3), t2[1] = -t2[6] / r3, t2[2] = -t2[7] / r3, t2[3] = 1 / (2 * r3), t2[4] = 1) : (i3 = r3 <= 0 ? -1 : 1, t2[0] = i3 * (t2[6] * t2[6] + t2[7] * t2[7] - r3 * r3) * 0.5, t2[1] = -i3 * t2[6], t2[2] = -i3 * t2[7], t2[3] = i3 / 2, t2[4] = i3 * r3) : (e2 = Math.sqrt(t2[1] * t2[1] + t2[2] * t2[2]), t2[0] /= e2, t2[1] /= e2, t2[2] /= e2, t2[3] = 0, t2[4] = 1), t2;
  }, toGL: function(t2) {
    var e2, i3, s2;
    if (e2 = "function" == typeof Float32Array ? new Float32Array(16) : new Array(16), 4 !== t2.length && 4 !== t2[0].length)
      return e2;
    for (i3 = 0; i3 < 4; i3++)
      for (s2 = 0; s2 < 4; s2++)
        e2[i3 + 4 * s2] = t2[i3][s2];
    return e2;
  }, Vieta: function(t2) {
    var e2, i3, s2, r3 = t2.length, o2 = [];
    for (o2 = t2.slice(), e2 = 1; e2 < r3; ++e2) {
      for (s2 = o2[e2], o2[e2] *= o2[e2 - 1], i3 = e2 - 1; i3 >= 1; --i3)
        o2[i3] += o2[i3 - 1] * s2;
      o2[0] += s2;
    }
    return o2;
  } };
  const a = r2.Z.Math;
}, 336: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(109), o = i2(503), n = i2(275), a = { rk4: { s: 4, A: [[0, 0, 0, 0], [0.5, 0, 0, 0], [0, 0.5, 0, 0], [0, 0, 1, 0]], b: [1 / 6, 1 / 3, 1 / 3, 1 / 6], c: [0, 0.5, 0.5, 1] }, heun: { s: 2, A: [[0, 0], [1, 0]], b: [0.5, 0.5], c: [0, 1] }, euler: { s: 1, A: [[0]], b: [1], c: [0] } };
  n.Z.Numerics = { Gauss: function(t2, e2) {
    var i3, s2, o2, a2, h2, l = n.Z.eps, c = t2.length > 0 ? t2[0].length : 0;
    if (c !== e2.length || c !== t2.length)
      throw new Error("JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A.");
    for (a2 = [], h2 = e2.slice(0, c), i3 = 0; i3 < c; i3++)
      a2[i3] = t2[i3].slice(0, c);
    for (s2 = 0; s2 < c; s2++) {
      for (i3 = c - 1; i3 > s2; i3--)
        if (Math.abs(a2[i3][s2]) > l)
          if (Math.abs(a2[s2][s2]) < l)
            r2.Z.swap(a2, i3, s2), r2.Z.swap(h2, i3, s2);
          else
            for (a2[i3][s2] /= a2[s2][s2], h2[i3] -= a2[i3][s2] * h2[s2], o2 = s2 + 1; o2 < c; o2++)
              a2[i3][o2] -= a2[i3][s2] * a2[s2][o2];
      if (Math.abs(a2[s2][s2]) < l)
        throw new Error("JXG.Math.Numerics.Gauss(): The given matrix seems to be singular.");
    }
    return this.backwardSolve(a2, h2, true), h2;
  }, backwardSolve: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2;
    for (s2 = i3 ? e2 : e2.slice(0, e2.length), r3 = t2.length, o2 = t2.length > 0 ? t2[0].length : 0, n2 = r3 - 1; n2 >= 0; n2--) {
      for (a2 = o2 - 1; a2 > n2; a2--)
        s2[n2] -= t2[n2][a2] * s2[a2];
      s2[n2] /= t2[n2][n2];
    }
    return s2;
  }, gaussBareiss: function(t2) {
    var e2, i3, s2, r3, o2, a2, h2, l, c, d = n.Z.eps;
    if ((h2 = t2.length) <= 0)
      return 0;
    for (t2[0].length < h2 && (h2 = t2[0].length), l = [], r3 = 0; r3 < h2; r3++)
      l[r3] = t2[r3].slice(0, h2);
    for (i3 = 1, s2 = 1, e2 = 0; e2 < h2 - 1; e2++) {
      if (a2 = l[e2][e2], Math.abs(a2) < d) {
        for (r3 = e2 + 1; r3 < h2 && !(Math.abs(l[r3][e2]) >= d); r3++)
          ;
        if (r3 === h2)
          return 0;
        for (o2 = e2; o2 < h2; o2++)
          c = l[r3][o2], l[r3][o2] = l[e2][o2], l[e2][o2] = c;
        s2 = -s2, a2 = l[e2][e2];
      }
      for (r3 = e2 + 1; r3 < h2; r3++)
        for (o2 = e2 + 1; o2 < h2; o2++)
          c = a2 * l[r3][o2] - l[r3][e2] * l[e2][o2], l[r3][o2] = c / i3;
      i3 = a2;
    }
    return s2 * l[h2 - 1][h2 - 1];
  }, det: function(t2) {
    return 2 === t2.length && 2 === t2[0].length ? t2[0][0] * t2[1][1] - t2[1][0] * t2[0][1] : this.gaussBareiss(t2);
  }, Jacobi: function(t2) {
    var e2, i3, s2, r3, o2, a2, h2, l, c, d = n.Z.eps * n.Z.eps, u = 0, p = t2.length, _ = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], f = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], b = 0;
    for (e2 = 0; e2 < p; e2++) {
      for (i3 = 0; i3 < p; i3++)
        _[e2][i3] = 0, f[e2][i3] = t2[e2][i3], u += Math.abs(f[e2][i3]);
      _[e2][e2] = 1;
    }
    if (1 === p)
      return [f, _];
    if (u <= 0)
      return [f, _];
    u /= p * p;
    do {
      for (l = 0, c = 0, i3 = 1; i3 < p; i3++)
        for (e2 = 0; e2 < i3; e2++)
          if ((r3 = Math.abs(f[e2][i3])) > c && (c = r3), l += r3, r3 >= d) {
            for (r3 = 0.5 * Math.atan2(2 * f[e2][i3], f[e2][e2] - f[i3][i3]), o2 = Math.sin(r3), a2 = Math.cos(r3), s2 = 0; s2 < p; s2++)
              h2 = f[s2][e2], f[s2][e2] = a2 * h2 + o2 * f[s2][i3], f[s2][i3] = -o2 * h2 + a2 * f[s2][i3], h2 = _[s2][e2], _[s2][e2] = a2 * h2 + o2 * _[s2][i3], _[s2][i3] = -o2 * h2 + a2 * _[s2][i3];
            for (f[e2][e2] = a2 * f[e2][e2] + o2 * f[i3][e2], f[i3][i3] = -o2 * f[e2][i3] + a2 * f[i3][i3], f[e2][i3] = 0, s2 = 0; s2 < p; s2++)
              f[e2][s2] = f[s2][e2], f[i3][s2] = f[s2][i3];
          }
      b += 1;
    } while (Math.abs(l) / u > d && b < 2e3);
    return [f, _];
  }, NewtonCotes: function(t2, e2, i3) {
    var s2, o2, n2, a2 = 0, h2 = i3 && r2.Z.isNumber(i3.number_of_nodes) ? i3.number_of_nodes : 28, l = { trapez: true, simpson: true, milne: true }, c = i3 && i3.integration_type && l.hasOwnProperty(i3.integration_type) && l[i3.integration_type] ? i3.integration_type : "milne", d = (t2[1] - t2[0]) / h2;
    switch (c) {
      case "trapez":
        for (a2 = 0.5 * (e2(t2[0]) + e2(t2[1])), s2 = t2[0], o2 = 0; o2 < h2 - 1; o2++)
          a2 += e2(s2 += d);
        a2 *= d;
        break;
      case "simpson":
        if (h2 % 2 > 0)
          throw new Error("JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2.");
        for (n2 = h2 / 2, a2 = e2(t2[0]) + e2(t2[1]), s2 = t2[0], o2 = 0; o2 < n2 - 1; o2++)
          a2 += 2 * e2(s2 += 2 * d);
        for (s2 = t2[0] - d, o2 = 0; o2 < n2; o2++)
          a2 += 4 * e2(s2 += 2 * d);
        a2 *= d / 3;
        break;
      default:
        if (h2 % 4 > 0)
          throw new Error("JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4");
        for (n2 = 0.25 * h2, a2 = 7 * (e2(t2[0]) + e2(t2[1])), s2 = t2[0], o2 = 0; o2 < n2 - 1; o2++)
          a2 += 14 * e2(s2 += 4 * d);
        for (s2 = t2[0] - 3 * d, o2 = 0; o2 < n2; o2++)
          a2 += 32 * (e2(s2 += 4 * d) + e2(s2 + 2 * d));
        for (s2 = t2[0] - 2 * d, o2 = 0; o2 < n2; o2++)
          a2 += 12 * e2(s2 += 4 * d);
        a2 *= 2 * d / 45;
    }
    return a2;
  }, Romberg: function(t2, e2, i3) {
    var s2, o2, n2, a2, h2, l, c, d, u = [], p = 0, _ = 1 / 0, f = i3 && r2.Z.isNumber(i3.max_iterations) ? i3.max_iterations : 20, b = i3 && r2.Z.isNumber(i3.eps) ? i3.eps : i3.eps || 1e-7;
    for (s2 = t2[0], n2 = (o2 = t2[1]) - s2, h2 = 1, u[0] = 0.5 * n2 * (e2(s2) + e2(o2)), l = 0; l < f; ++l) {
      for (a2 = 0, n2 *= 0.5, h2 *= 2, d = 1, c = 1; c < h2; c += 2)
        a2 += e2(s2 + c * n2);
      for (u[l + 1] = 0.5 * u[l] + a2 * n2, p = u[l + 1], c = l - 1; c >= 0; --c)
        d *= 4, u[c] = u[c + 1] + (u[c + 1] - u[c]) / (d - 1), p = u[c];
      if (Math.abs(p - _) < b * Math.abs(p))
        break;
      _ = p;
    }
    return p;
  }, GaussLegendre: function(t2, e2, i3) {
    var s2, o2, n2, a2, h2, l, c, d, u = 0, p = [], _ = [], f = i3 && r2.Z.isNumber(i3.n) ? i3.n : 12;
    if (f > 18 && (f = 18), p[2] = [0.5773502691896257], _[2] = [1], p[4] = [0.33998104358485626, 0.8611363115940526], _[4] = [0.6521451548625461, 0.34785484513745385], p[6] = [0.2386191860831969, 0.6612093864662645, 0.932469514203152], _[6] = [0.46791393457269104, 0.3607615730481386, 0.17132449237917036], p[8] = [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363], _[8] = [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626], p[10] = [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717], _[10] = [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814], p[12] = [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192], _[12] = [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183], p[14] = [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123], _[14] = [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186], p[16] = [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499], _[16] = [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096], p[18] = [0.0847750130417353, 0.2518862256915055, 0.41175116146284263, 0.5597708310739475, 0.6916870430603532, 0.8037049589725231, 0.8926024664975557, 0.9558239495713977, 0.9915651684209309], _[18] = [0.1691423829631436, 0.16427648374583273, 0.15468467512626524, 0.14064291467065065, 0.12255520671147846, 0.10094204410628717, 0.07642573025488905, 0.0497145488949698, 0.02161601352648331], p[3] = [0, 0.7745966692414834], _[3] = [0.8888888888888888, 0.5555555555555556], p[5] = [0, 0.5384693101056831, 0.906179845938664], _[5] = [0.5688888888888889, 0.47862867049936647, 0.23692688505618908], p[7] = [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585], _[7] = [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697], p[9] = [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261], _[9] = [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441], p[11] = [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057], _[11] = [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366], p[13] = [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881], _[13] = [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588], p[15] = [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854], _[15] = [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727], p[17] = [0, 0.17848418149584785, 0.3512317634538763, 0.5126905370864769, 0.6576711592166907, 0.7815140038968014, 0.8802391537269859, 0.9506755217687678, 0.9905754753144174], _[17] = [0.17944647035620653, 0.17656270536699264, 0.16800410215645004, 0.15404576107681028, 0.13513636846852548, 0.11188384719340397, 0.08503614831717918, 0.0554595293739872, 0.02414830286854793], s2 = t2[0], o2 = t2[1], a2 = f + 1 >> 1, c = p[f], d = _[f], l = 0.5 * (o2 - s2), h2 = 0.5 * (o2 + s2), true & f)
      for (u = d[0] * e2(h2), n2 = 1; n2 < a2; ++n2)
        u += d[n2] * (e2(h2 + l * c[n2]) + e2(h2 - l * c[n2]));
    else
      for (u = 0, n2 = 0; n2 < a2; ++n2)
        u += d[n2] * (e2(h2 + l * c[n2]) + e2(h2 - l * c[n2]));
    return l * u;
  }, _rescale_error: function(t2, e2, i3) {
    var s2, r3, o2 = 2220446049250313e-31;
    return t2 = Math.abs(t2), 0 !== i3 && 0 !== t2 && (t2 = (s2 = Math.pow(200 * t2 / i3, 1.5)) < 1 ? i3 * s2 : i3), e2 > 20041683600089728e-310 && (r3 = 50 * o2 * e2) > t2 && (t2 = r3), t2;
  }, _gaussKronrod: function(t2, e2, i3, s2, r3, o2, n2) {
    var a2, h2, l, c, d, u, p, _, f, b, g, m = t2[0], v = t2[1], Z = 0.5 * (m + v), C = 0.5 * (v - m), y = Math.abs(C), P = e2(Z), E = 0, O = P * o2[i3 - 1], x = Math.abs(O), w = 0, S = [], T = [];
    for (i3 % 2 == 0 && (E = P * r3[i3 / 2 - 1]), a2 = Math.floor((i3 - 1) / 2), d = 0; d < a2; d++)
      b = (_ = e2(Z - (p = C * s2[u = 2 * d + 1]))) + (f = e2(Z + p)), S[u] = _, T[u] = f, E += r3[d] * b, O += o2[u] * b, x += o2[u] * (Math.abs(_) + Math.abs(f));
    for (a2 = Math.floor(i3 / 2), d = 0; d < a2; d++)
      _ = e2(Z - (p = C * s2[g = 2 * d])), f = e2(Z + p), S[g] = _, T[g] = f, O += o2[g] * (_ + f), x += o2[g] * (Math.abs(_) + Math.abs(f));
    for (l = 0.5 * O, w = o2[i3 - 1] * Math.abs(P - l), d = 0; d < i3 - 1; d++)
      w += o2[d] * (Math.abs(S[d] - l) + Math.abs(T[d] - l));
    return c = (O - E) * C, x *= y, w *= y, h2 = O *= C, n2.abserr = this._rescale_error(c, x, w), n2.resabs = x, n2.resasc = w, h2;
  }, GaussKronrod15: function(t2, e2, i3) {
    return this._gaussKronrod(t2, e2, 8, [0.9914553711208126, 0.9491079123427585, 0.8648644233597691, 0.7415311855993945, 0.5860872354676911, 0.4058451513773972, 0.20778495500789848, 0], [0.1294849661688697, 0.27970539148927664, 0.3818300505051189, 0.4179591836734694], [0.022935322010529224, 0.06309209262997856, 0.10479001032225019, 0.14065325971552592, 0.1690047266392679, 0.19035057806478542, 0.20443294007529889, 0.20948214108472782], i3);
  }, GaussKronrod21: function(t2, e2, i3) {
    return this._gaussKronrod(t2, e2, 11, [0.9956571630258081, 0.9739065285171717, 0.9301574913557082, 0.8650633666889845, 0.7808177265864169, 0.6794095682990244, 0.5627571346686047, 0.4333953941292472, 0.2943928627014602, 0.14887433898163122, 0], [0.06667134430868814, 0.1494513491505806, 0.21908636251598204, 0.26926671930999635, 0.29552422471475287], [0.011694638867371874, 0.032558162307964725, 0.054755896574351995, 0.07503967481091996, 0.0931254545836976, 0.10938715880229764, 0.12349197626206584, 0.13470921731147334, 0.14277593857706009, 0.14773910490133849, 0.1494455540029169], i3);
  }, GaussKronrod31: function(t2, e2, i3) {
    return this._gaussKronrod(t2, e2, 16, [0.9980022986933971, 0.9879925180204854, 0.9677390756791391, 0.937273392400706, 0.8972645323440819, 0.8482065834104272, 0.790418501442466, 0.7244177313601701, 0.650996741297417, 0.5709721726085388, 0.4850818636402397, 0.3941513470775634, 0.29918000715316884, 0.20119409399743451, 0.1011420669187175, 0], [0.03075324199611727, 0.07036604748810812, 0.10715922046717194, 0.13957067792615432, 0.16626920581699392, 0.1861610000155622, 0.19843148532711158, 0.2025782419255613], [0.005377479872923349, 0.015007947329316122, 0.02546084732671532, 0.03534636079137585, 0.04458975132476488, 0.05348152469092809, 0.06200956780067064, 0.06985412131872826, 0.07684968075772038, 0.08308050282313302, 0.08856444305621176, 0.09312659817082532, 0.09664272698362368, 0.09917359872179196, 0.10076984552387559, 0.10133000701479154], i3);
  }, _workspace: function(t2, e2) {
    return { limit: e2, size: 0, nrmax: 0, i: 0, alist: [t2[0]], blist: [t2[1]], rlist: [0], elist: [0], order: [0], level: [0], qpsrt: function() {
      var t3, e3, i3, s2, r3, o2 = this.size - 1, n2 = this.limit, a2 = this.nrmax, h2 = this.order[a2];
      if (o2 < 2)
        return this.order[0] = 0, this.order[1] = 1, void (this.i = h2);
      for (t3 = this.elist[h2]; a2 > 0 && t3 > this.elist[this.order[a2 - 1]]; )
        this.order[a2] = this.order[a2 - 1], a2--;
      for (r3 = o2 < n2 / 2 + 2 ? o2 : n2 - o2 + 1, i3 = a2 + 1; i3 < r3 && t3 < this.elist[this.order[i3]]; )
        this.order[i3 - 1] = this.order[i3], i3++;
      for (this.order[i3 - 1] = h2, e3 = this.elist[o2], s2 = r3 - 1; s2 > i3 - 2 && e3 >= this.elist[this.order[s2]]; )
        this.order[s2 + 1] = this.order[s2], s2--;
      this.order[s2 + 1] = o2, h2 = this.order[a2], this.i = h2, this.nrmax = a2;
    }, set_initial_result: function(t3, e3) {
      this.size = 1, this.rlist[0] = t3, this.elist[0] = e3;
    }, update: function(t3, e3, i3, s2, r3, o2, n2, a2) {
      var h2 = this.i, l = this.size, c = this.level[this.i] + 1;
      a2 > s2 ? (this.alist[h2] = r3, this.rlist[h2] = n2, this.elist[h2] = a2, this.level[h2] = c, this.alist[l] = t3, this.blist[l] = e3, this.rlist[l] = i3, this.elist[l] = s2, this.level[l] = c) : (this.blist[h2] = e3, this.rlist[h2] = i3, this.elist[h2] = s2, this.level[h2] = c, this.alist[l] = r3, this.blist[l] = o2, this.rlist[l] = n2, this.elist[l] = a2, this.level[l] = c), this.size++, c > this.maximum_level && (this.maximum_level = c), this.qpsrt();
    }, retrieve: function() {
      var t3 = this.i;
      return { a: this.alist[t3], b: this.blist[t3], r: this.rlist[t3], e: this.elist[t3] };
    }, sum_results: function() {
      var t3, e3 = this.size, i3 = 0;
      for (t3 = 0; t3 < e3; t3++)
        i3 += this.rlist[t3];
      return i3;
    }, subinterval_too_small: function(t3, e3, i3) {
      var s2 = 1.0000000000000222 * (Math.abs(e3) + 22250738585072014e-321);
      return Math.abs(t3) <= s2 && Math.abs(i3) <= s2;
    } };
  }, Qag: function(t2, e2, i3) {
    var o2, a2, h2, l, c, d, u, p, _, f, b, g, m, v, Z, C, y, P, E = this._workspace(t2, 1e3), O = i3 && r2.Z.isNumber(i3.limit) ? i3.limit : 15, x = i3 && r2.Z.isNumber(i3.epsrel) ? i3.epsrel : 1e-7, w = i3 && r2.Z.isNumber(i3.epsabs) ? i3.epsabs : 1e-7, S = i3 && r2.Z.isFunction(i3.q) ? i3.q : this.GaussKronrod15, T = {}, M = 0, N = 0, A = 0, k = 0, R = 0, D = 0, L = 0, B = 0, I = 0, Y = 0;
    if (O > E.limit && s.Z.warn("iteration limit exceeds available workspace"), w <= 0 && (x < 50 * n.Z.eps || x < 5e-29) && s.Z.warn("tolerance cannot be acheived with given epsabs and epsrel"), h2 = S.apply(this, [t2, e2, T]), l = T.abserr, c = T.resabs, d = T.resasc, E.set_initial_result(h2, l), u = Math.max(w, x * Math.abs(h2)), l <= 11102230246251565e-30 * c && l > u)
      return s.Z.warn("cannot reach tolerance because of roundoff error on first attempt"), -1 / 0;
    if (l <= u && l !== d || 0 === l)
      return h2;
    if (1 === O)
      return s.Z.warn("a maximum of one iteration was insufficient"), -1 / 0;
    o2 = h2, a2 = l, M = 1;
    do {
      R = 0, D = 0, L = 0, B = 0, I = 0, Y = 0, g = (y = E.retrieve()).a, m = y.b, v = y.r, Z = y.e, p = g, f = _ = 0.5 * (g + m), b = m, R = S.apply(this, [[p, _], e2, T]), B = T.abserr, C = T.resasc, D = S.apply(this, [[f, b], e2, T]), a2 += (Y = B + (I = T.abserr)) - Z, o2 += (L = R + D) - v, C !== B && T.resasc !== I && (P = v - L, Math.abs(P) <= 1e-5 * Math.abs(L) && Y >= 0.99 * Z && N++, M >= 10 && Y > Z && A++), a2 > (u = Math.max(w, x * Math.abs(o2))) && ((N >= 6 || A >= 20) && (k = 2), E.subinterval_too_small(p, f, b) && (k = 3)), E.update(p, _, R, B, f, b, D, I), g = (y = E.retrieve()).a_i, m = y.b_i, v = y.r_i, Z = y.e_i, M++;
    } while (M < O && !k && a2 > u);
    return E.sum_results();
  }, I: function(t2, e2) {
    return this.Qag(t2, e2, { q: this.GaussKronrod15, limit: 15, epsrel: 1e-7, epsabs: 1e-7 });
  }, Newton: function(t2, e2, i3) {
    var s2, o2 = 0, a2 = n.Z.eps, h2 = t2.apply(i3, [e2]);
    for (r2.Z.isArray(e2) && (e2 = e2[0]); o2 < 50 && Math.abs(h2) > a2; )
      s2 = this.D(t2, i3)(e2), Math.abs(s2) > a2 ? e2 -= h2 / s2 : e2 += 0.2 * Math.random() - 1, h2 = t2.apply(i3, [e2]), o2 += 1;
    return e2;
  }, root: function(t2, e2, i3) {
    return this.chandrupatla(t2, e2, i3);
  }, generalizedNewton: function(t2, e2, i3, s2) {
    var r3, o2, a2, h2, l, c, d, u, p, _, f, b, g, m, v = 0;
    for (this.generalizedNewton.t1memo ? (r3 = this.generalizedNewton.t1memo, o2 = this.generalizedNewton.t2memo) : (r3 = i3, o2 = s2), _ = (u = t2.X(r3) - e2.X(o2)) * u + (p = t2.Y(r3) - e2.Y(o2)) * p, f = this.D(t2.X, t2), b = this.D(e2.X, e2), g = this.D(t2.Y, t2), m = this.D(e2.Y, e2); _ > n.Z.eps && v < 10; )
      a2 = f(r3), h2 = -b(o2), l = g(r3), r3 -= ((c = -m(o2)) * u - h2 * p) / (d = a2 * c - h2 * l), o2 -= (a2 * p - l * u) / d, _ = (u = t2.X(r3) - e2.X(o2)) * u + (p = t2.Y(r3) - e2.Y(o2)) * p, v += 1;
    return this.generalizedNewton.t1memo = r3, this.generalizedNewton.t2memo = o2, Math.abs(r3) < Math.abs(o2) ? [t2.X(r3), t2.Y(r3)] : [e2.X(o2), e2.Y(o2)];
  }, Neville: function(t2) {
    var e2 = [], i3 = function(i4) {
      return function(s2, r3) {
        var o2, a2, h2, l = n.Z.binomial, c = t2.length, d = c - 1, u = 0, p = 0;
        if (!r3)
          for (h2 = 1, o2 = 0; o2 < c; o2++)
            e2[o2] = l(d, o2) * h2, h2 *= -1;
        for (a2 = s2, o2 = 0; o2 < c; o2++) {
          if (0 === a2)
            return t2[o2][i4]();
          h2 = e2[o2] / a2, a2 -= 1, u += t2[o2][i4]() * h2, p += h2;
        }
        return u / p;
      };
    };
    return [i3("X"), i3("Y"), 0, function() {
      return t2.length - 1;
    }];
  }, splineDef: function(t2, e2) {
    var i3, s2, r3, o2 = Math.min(t2.length, e2.length), n2 = [], a2 = [], h2 = [], l = [], c = [], d = [];
    if (2 === o2)
      return [0, 0];
    for (s2 = 0; s2 < o2; s2++)
      i3 = { X: t2[s2], Y: e2[s2] }, h2.push(i3);
    for (h2.sort(function(t3, e3) {
      return t3.X - e3.X;
    }), s2 = 0; s2 < o2; s2++)
      t2[s2] = h2[s2].X, e2[s2] = h2[s2].Y;
    for (s2 = 0; s2 < o2 - 1; s2++)
      l.push(t2[s2 + 1] - t2[s2]);
    for (s2 = 0; s2 < o2 - 2; s2++)
      c.push(6 * (e2[s2 + 2] - e2[s2 + 1]) / l[s2 + 1] - 6 * (e2[s2 + 1] - e2[s2]) / l[s2]);
    for (n2.push(2 * (l[0] + l[1])), a2.push(c[0]), s2 = 0; s2 < o2 - 3; s2++)
      r3 = l[s2 + 1] / n2[s2], n2.push(2 * (l[s2 + 1] + l[s2 + 2]) - r3 * l[s2 + 1]), a2.push(c[s2 + 1] - r3 * a2[s2]);
    for (d[o2 - 3] = a2[o2 - 3] / n2[o2 - 3], s2 = o2 - 4; s2 >= 0; s2--)
      d[s2] = (a2[s2] - l[s2 + 1] * d[s2 + 1]) / n2[s2];
    for (s2 = o2 - 3; s2 >= 0; s2--)
      d[s2 + 1] = d[s2];
    return d[0] = 0, d[o2 - 1] = 0, d;
  }, splineEval: function(t2, e2, i3, s2) {
    var o2, n2, a2, h2, l, c, d, u = Math.min(e2.length, i3.length), p = 1, _ = false, f = [];
    for (r2.Z.isArray(t2) ? (p = t2.length, _ = true) : t2 = [t2], o2 = 0; o2 < p; o2++) {
      if (t2[o2] < e2[0] || e2[o2] > e2[u - 1])
        return NaN;
      for (n2 = 1; n2 < u && !(t2[o2] <= e2[n2]); n2++)
        ;
      a2 = i3[n2 -= 1], h2 = (i3[n2 + 1] - i3[n2]) / (e2[n2 + 1] - e2[n2]) - (e2[n2 + 1] - e2[n2]) / 6 * (s2[n2 + 1] + 2 * s2[n2]), l = s2[n2] / 2, c = (s2[n2 + 1] - s2[n2]) / (6 * (e2[n2 + 1] - e2[n2])), d = t2[o2] - e2[n2], f.push(a2 + (h2 + (l + c * d) * d) * d);
    }
    return _ ? f : f[0];
  }, generatePolynomialTerm: function(t2, e2, i3, s2) {
    var r3, o2 = [];
    for (r3 = e2; r3 >= 0; r3--)
      o2 = o2.concat(["(", t2[r3].toPrecision(s2), ")"]), r3 > 1 ? o2 = o2.concat(["*", i3, "<sup>", r3, "<", "/sup> + "]) : 1 === r3 && (o2 = o2.concat(["*", i3, " + "]));
    return o2.join("");
  }, lagrangePolynomial: function(t2) {
    var e2 = [], i3 = this, s2 = function(i4, s3) {
      var r3, o2, n2, a2, h2 = t2.length, l = 0, c = 0;
      if (!s3)
        for (r3 = 0; r3 < h2; r3++) {
          for (e2[r3] = 1, n2 = t2[r3].X(), o2 = 0; o2 < h2; o2++)
            o2 !== r3 && (e2[r3] *= n2 - t2[o2].X());
          e2[r3] = 1 / e2[r3];
        }
      for (r3 = 0; r3 < h2; r3++) {
        if (i4 === (n2 = t2[r3].X()))
          return t2[r3].Y();
        c += a2 = e2[r3] / (i4 - n2), l += a2 * t2[r3].Y();
      }
      return l / c;
    };
    return s2.getTerm = function(e3, s3, r3) {
      return i3.lagrangePolynomialTerm(t2, e3, s3, r3)();
    }, s2;
  }, lagrangePolynomialTerm: function(t2, e2, i3, r3) {
    return function() {
      var a2, h2, l, c, d, u, p = t2.length, _ = [], f = [], b = [], g = true;
      for (i3 = i3 || "x", void 0 === r3 && (r3 = " * "), a2 = p - 1, c = 0; c < p; c++)
        b[c] = 0;
      for (l = 0; l < p; l++) {
        for (d = t2[l].Y(), u = t2[l].X(), _ = [], c = 0; c < p; c++)
          c !== l && (d /= u - t2[c].X(), _.push(t2[c].X()));
        for (f = [1].concat(n.Z.Vieta(_)), c = 0; c < f.length; c++)
          b[c] += (c % 2 == 1 ? -1 : 1) * f[c] * d;
      }
      for (h2 = "", c = 0; c < b.length; c++)
        d = b[c], Math.abs(d) < n.Z.eps || (s.Z.exists(e2) && (d = o.Z._round10(d, -e2)), g ? (h2 += d > 0 ? d : "-" + -d, g = false) : h2 += d > 0 ? " + " + d : " - " + -d, a2 - c > 1 ? h2 += r3 + i3 + "^" + (a2 - c) : a2 - c == 1 && (h2 += r3 + i3));
      return h2;
    };
  }, _initCubicPoly: function(t2, e2, i3, s2) {
    return [t2, i3, -3 * t2 + 3 * e2 - 2 * i3 - s2, 2 * t2 - 2 * e2 + i3 + s2];
  }, CardinalSpline: function(t2, e2, i3) {
    var s2, o2, a2, h2, l = [], c = this;
    return h2 = r2.Z.isFunction(e2) ? e2 : function() {
      return e2;
    }, void 0 === i3 && (i3 = "uniform"), o2 = function(e3) {
      return function(r3, o3) {
        var d, u, p, _, f, b, g, m, v, Z;
        if (t2.length < 2)
          return NaN;
        if (!o3)
          for (a2 = h2(), p = { X: function() {
            return 2 * t2[0].X() - t2[1].X();
          }, Y: function() {
            return 2 * t2[0].Y() - t2[1].Y();
          }, Dist: function(t3) {
            var e4 = this.X() - t3.X(), i4 = this.Y() - t3.Y();
            return Math.sqrt(e4 * e4 + i4 * i4);
          } }, _ = { X: function() {
            return 2 * t2[t2.length - 1].X() - t2[t2.length - 2].X();
          }, Y: function() {
            return 2 * t2[t2.length - 1].Y() - t2[t2.length - 2].Y();
          }, Dist: function(t3) {
            var e4 = this.X() - t3.X(), i4 = this.Y() - t3.Y();
            return Math.sqrt(e4 * e4 + i4 * i4);
          } }, Z = (s2 = [p].concat(t2, [_])).length, l[e3] = [], d = 0; d < Z - 3; d++)
            "centripetal" === i3 ? (g = s2[d].Dist(s2[d + 1]), m = s2[d + 2].Dist(s2[d + 1]), v = s2[d + 3].Dist(s2[d + 2]), g = Math.sqrt(g), m = Math.sqrt(m), v = Math.sqrt(v), m < n.Z.eps && (m = 1), g < n.Z.eps && (g = m), v < n.Z.eps && (v = m), f = (s2[d + 1][e3]() - s2[d][e3]()) / g - (s2[d + 2][e3]() - s2[d][e3]()) / (m + g) + (s2[d + 2][e3]() - s2[d + 1][e3]()) / m, b = (s2[d + 2][e3]() - s2[d + 1][e3]()) / m - (s2[d + 3][e3]() - s2[d + 1][e3]()) / (v + m) + (s2[d + 3][e3]() - s2[d + 2][e3]()) / v, f *= m, b *= m, l[e3][d] = c._initCubicPoly(s2[d + 1][e3](), s2[d + 2][e3](), a2 * f, a2 * b)) : l[e3][d] = c._initCubicPoly(s2[d + 1][e3](), s2[d + 2][e3](), a2 * (s2[d + 2][e3]() - s2[d][e3]()), a2 * (s2[d + 3][e3]() - s2[d + 1][e3]()));
        return isNaN(r3) ? NaN : (Z = t2.length, r3 <= 0 ? t2[0][e3]() : r3 >= Z ? t2[Z - 1][e3]() : (d = Math.floor(r3)) === r3 ? t2[d][e3]() : (r3 -= d, void 0 === (u = l[e3][d]) ? NaN : ((u[3] * r3 + u[2]) * r3 + u[1]) * r3 + u[0]));
      };
    }, [o2("X"), o2("Y"), 0, function() {
      return t2.length - 1;
    }];
  }, CatmullRomSpline: function(t2, e2) {
    return this.CardinalSpline(t2, 0.5, e2);
  }, regressionPolynomial: function(t2, e2, i3) {
    var s2, o2, a2, h2, l, c, d = "";
    if (r2.Z.isPoint(t2) && r2.Z.isFunction(t2.Value))
      o2 = function() {
        return t2.Value();
      };
    else if (r2.Z.isFunction(t2))
      o2 = t2;
    else {
      if (!r2.Z.isNumber(t2))
        throw new Error("JSXGraph: Can't create regressionPolynomial from degree of type'" + typeof t2 + "'.");
      o2 = function() {
        return t2;
      };
    }
    if (3 === arguments.length && r2.Z.isArray(e2) && r2.Z.isArray(i3))
      l = 0;
    else if (2 === arguments.length && r2.Z.isArray(e2) && e2.length > 0 && r2.Z.isPoint(e2[0]))
      l = 1;
    else {
      if (!(2 === arguments.length && r2.Z.isArray(e2) && e2.length > 0 && e2[0].usrCoords && e2[0].scrCoords))
        throw new Error("JSXGraph: Can't create regressionPolynomial. Wrong parameters.");
      l = 2;
    }
    return (c = function(t3, c2) {
      var u, p, _, f, b, g, m, v, Z, C = e2.length;
      if (Z = Math.floor(o2()), !c2) {
        if (1 === l)
          for (a2 = [], h2 = [], u = 0; u < C; u++)
            a2[u] = e2[u].X(), h2[u] = e2[u].Y();
        if (2 === l)
          for (a2 = [], h2 = [], u = 0; u < C; u++)
            a2[u] = e2[u].usrCoords[1], h2[u] = e2[u].usrCoords[2];
        if (0 === l)
          for (a2 = [], h2 = [], u = 0; u < C; u++)
            r2.Z.isFunction(e2[u]) ? a2.push(e2[u]()) : a2.push(e2[u]), r2.Z.isFunction(i3[u]) ? h2.push(i3[u]()) : h2.push(i3[u]);
        for (_ = [], p = 0; p < C; p++)
          _.push([1]);
        for (u = 1; u <= Z; u++)
          for (p = 0; p < C; p++)
            _[p][u] = _[p][u - 1] * a2[p];
        b = h2, f = n.Z.transpose(_), g = n.Z.matMatMult(f, _), m = n.Z.matVecMult(f, b), s2 = n.Z.Numerics.Gauss(g, m), d = n.Z.Numerics.generatePolynomialTerm(s2, Z, "x", 3);
      }
      for (v = s2[Z], u = Z - 1; u >= 0; u--)
        v = v * t3 + s2[u];
      return v;
    }).getTerm = function() {
      return d;
    }, c;
  }, bezier: function(t2) {
    var e2, i3, s2 = function(s3) {
      return function(r3, o2) {
        var n2 = 3 * Math.floor(r3), a2 = r3 % 1, h2 = 1 - a2;
        return o2 || (i3 = 3 * Math.floor((t2.length - 1) / 3), e2 = Math.floor(i3 / 3)), r3 < 0 ? t2[0][s3]() : r3 >= e2 ? t2[i3][s3]() : isNaN(r3) ? NaN : h2 * h2 * (h2 * t2[n2][s3]() + 3 * a2 * t2[n2 + 1][s3]()) + (3 * h2 * t2[n2 + 2][s3]() + a2 * t2[n2 + 3][s3]()) * a2 * a2;
      };
    };
    return [s2("X"), s2("Y"), 0, function() {
      return Math.floor(t2.length / 3);
    }];
  }, bspline: function(t2, e2) {
    var i3, s2 = function(s3) {
      return function(r3, o2) {
        var n2, a2, h2, l, c = t2.length, d = c - 1, u = e2;
        if (d <= 0)
          return NaN;
        if (d + 2 <= u && (u = d + 1), r3 <= 0)
          return t2[0][s3]();
        if (r3 >= d - u + 2)
          return t2[d][s3]();
        for (h2 = Math.floor(r3) + u - 1, i3 = function(t3, e3) {
          var i4, s4 = [];
          for (i4 = 0; i4 < t3 + e3 + 1; i4++)
            s4[i4] = i4 < e3 ? 0 : i4 <= t3 ? i4 - e3 + 1 : t3 - e3 + 2;
          return s4;
        }(d, u), l = function(t3, e3, i4, s4) {
          var r4, o3, n3, a3, h3, l2 = [];
          for (e3[s4] <= t3 && t3 < e3[s4 + 1] ? l2[s4] = 1 : l2[s4] = 0, r4 = 2; r4 <= i4; r4++)
            for (o3 = s4 - r4 + 1; o3 <= s4; o3++)
              n3 = o3 <= s4 - r4 + 1 || o3 < 0 ? 0 : l2[o3], a3 = o3 >= s4 ? 0 : l2[o3 + 1], h3 = e3[o3 + r4 - 1] - e3[o3], l2[o3] = 0 === h3 ? 0 : (t3 - e3[o3]) / h3 * n3, 0 != (h3 = e3[o3 + r4] - e3[o3 + 1]) && (l2[o3] += (e3[o3 + r4] - t3) / h3 * a3);
          return l2;
        }(r3, i3, u, h2), n2 = 0, a2 = h2 - u + 1; a2 <= h2; a2++)
          a2 < c && a2 >= 0 && (n2 += t2[a2][s3]() * l[a2]);
        return n2;
      };
    };
    return [s2("X"), s2("Y"), 0, function() {
      return t2.length - 1;
    }];
  }, D: function(t2, e2) {
    return r2.Z.exists(e2) ? function(i3, s2) {
      var r3 = 1e-5;
      return (t2.apply(e2, [i3 + r3, s2]) - t2.apply(e2, [i3 - r3, s2])) / 2e-5;
    } : function(e3, i3) {
      var s2 = 1e-5;
      return (t2(e3 + s2, i3) - t2(e3 - s2, i3)) / 2e-5;
    };
  }, _riemannValue: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2;
    if (s2 < 0 && ("trapezoidal" !== i3 && (t2 += s2), s2 *= -1, "lower" === i3 ? i3 = "upper" : "upper" === i3 && (i3 = "lower")), a2 = 0.01 * s2, "right" === i3)
      r3 = e2(t2 + s2);
    else if ("middle" === i3)
      r3 = e2(t2 + 0.5 * s2);
    else if ("left" === i3 || "trapezoidal" === i3)
      r3 = e2(t2);
    else if ("lower" === i3) {
      for (r3 = e2(t2), n2 = t2 + a2; n2 <= t2 + s2; n2 += a2)
        (o2 = e2(n2)) < r3 && (r3 = o2);
      (o2 = e2(t2 + s2)) < r3 && (r3 = o2);
    } else if ("upper" === i3) {
      for (r3 = e2(t2), n2 = t2 + a2; n2 <= t2 + s2; n2 += a2)
        (o2 = e2(n2)) > r3 && (r3 = o2);
      (o2 = e2(t2 + s2)) > r3 && (r3 = o2);
    } else
      r3 = "random" === i3 ? e2(t2 + s2 * Math.random()) : "simpson" === i3 ? (e2(t2) + 4 * e2(t2 + 0.5 * s2) + e2(t2 + s2)) / 6 : e2(t2);
    return r3;
  }, riemann: function(t2, e2, i3, s2, o2) {
    var n2, a2, h2, l, c, d, u, p = [], _ = [], f = 0, b = s2, g = 0;
    if (r2.Z.isArray(t2) ? (c = t2[0], l = t2[1]) : l = t2, (e2 = Math.floor(e2)) <= 0)
      return [p, _, g];
    for (a2 = (o2 - s2) / e2, n2 = 0; n2 < e2; n2++)
      h2 = this._riemannValue(b, l, i3, a2), p[f] = b, _[f] = h2, f += 1, b += a2, "trapezoidal" === i3 && (h2 = l(b)), p[f] = b, _[f] = h2, f += 1;
    for (n2 = 0; n2 < e2; n2++)
      h2 = c ? this._riemannValue(b, c, i3, -a2) : 0, p[f] = b, _[f] = h2, f += 1, b -= a2, "trapezoidal" === i3 && c && (h2 = c(b)), p[f] = b, _[f] = h2, "trapezoidal" !== i3 ? (d = h2, u = _[2 * (e2 - 1) - 2 * n2]) : (u = 0.5 * (l(b + a2) + l(b)), d = c ? 0.5 * (c(b + a2) + c(b)) : 0), g += (u - d) * a2, p[f += 1] = b, _[f] = _[2 * (e2 - 1) - 2 * n2], f += 1;
    return [p, _, g];
  }, riemannsum: function(t2, e2, i3, r3, o2) {
    return s.Z.deprecated("Numerics.riemannsum()", "Numerics.riemann()"), this.riemann(t2, e2, i3, r3, o2)[2];
  }, rungeKutta: function(t2, e2, i3, s2, o2) {
    var n2, h2, l, c, d, u, p = [], _ = [], f = (i3[1] - i3[0]) / s2, b = i3[0], g = e2.length, m = [], v = 0;
    for (r2.Z.isString(t2) && (t2 = a[t2] || a.euler), u = t2.s, n2 = 0; n2 < g; n2++)
      p[n2] = e2[n2];
    for (h2 = 0; h2 < s2; h2++) {
      for (m[v] = [], n2 = 0; n2 < g; n2++)
        m[v][n2] = p[n2];
      for (v += 1, c = [], l = 0; l < u; l++) {
        for (n2 = 0; n2 < g; n2++)
          _[n2] = 0;
        for (d = 0; d < l; d++)
          for (n2 = 0; n2 < g; n2++)
            _[n2] += t2.A[l][d] * f * c[d][n2];
        for (n2 = 0; n2 < g; n2++)
          _[n2] += p[n2];
        c.push(o2(b + t2.c[l] * f, _));
      }
      for (n2 = 0; n2 < g; n2++)
        _[n2] = 0;
      for (d = 0; d < u; d++)
        for (n2 = 0; n2 < g; n2++)
          _[n2] += t2.b[d] * c[d][n2];
      for (n2 = 0; n2 < g; n2++)
        p[n2] = p[n2] + f * _[n2];
      b += f;
    }
    return m;
  }, maxIterationsRoot: 80, maxIterationsMinimize: 500, findBracket: function(t2, e2, i3) {
    var s2, o2, n2, a2, h2, l, c, d, u, p;
    if (r2.Z.isArray(e2))
      return e2;
    for (s2 = e2, n2 = t2.call(i3, s2), p = (a2 = [s2 - 0.1 * (o2 = 0 === s2 ? 1 : s2), s2 + 0.1 * o2, s2 - 1, s2 + 1, s2 - 0.5 * o2, s2 + 0.5 * o2, s2 - 0.6 * o2, s2 + 0.6 * o2, s2 - 1 * o2, s2 + 1 * o2, s2 - 2 * o2, s2 + 2 * o2, s2 - 5 * o2, s2 + 5 * o2, s2 - 10 * o2, s2 + 10 * o2, s2 - 50 * o2, s2 + 50 * o2, s2 - 100 * o2, s2 + 100 * o2]).length, u = 0; u < p && (h2 = a2[u], !(n2 * (l = t2.call(i3, h2)) <= 0)); u++)
      ;
    return h2 < s2 && (c = s2, s2 = h2, h2 = c, d = n2, n2 = l, l = d), [s2, n2, h2, l];
  }, fzero: function(t2, e2, i3) {
    var s2, o2, a2, h2, l, c, d, u, p, _, f, b, g, m, v, Z = n.Z.eps, C = this.maxIterationsRoot, y = 0;
    if (r2.Z.isArray(e2)) {
      if (e2.length < 2)
        throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
      s2 = e2[0], h2 = t2.call(i3, s2), o2 = e2[1], l = t2.call(i3, o2);
    } else
      s2 = (d = this.findBracket(t2, e2, i3))[0], h2 = d[1], o2 = d[2], l = d[3];
    if (Math.abs(h2) <= Z)
      return s2;
    if (Math.abs(l) <= Z)
      return o2;
    if (h2 * l > 0)
      return r2.Z.isArray(e2) ? this.fminbr(t2, [s2, o2], i3) : this.Newton(t2, s2, i3);
    for (a2 = s2, c = h2; y < C; ) {
      if (u = o2 - s2, Math.abs(c) < Math.abs(l) && (s2 = o2, o2 = a2, a2 = s2, h2 = l, l = c, c = h2), b = 2 * Z * Math.abs(o2) + 0.5 * Z, v = 0.5 * (a2 - o2), Math.abs(v) <= b || Math.abs(l) <= Z)
        return o2;
      Math.abs(u) >= b && Math.abs(h2) > Math.abs(l) && (_ = a2 - o2, s2 === a2 ? (g = _ * (p = l / h2), m = 1 - p) : (g = (f = l / h2) * (_ * (m = h2 / c) * (m - (p = l / c)) - (o2 - s2) * (p - 1)), m = (m - 1) * (p - 1) * (f - 1)), g > 0 ? m = -m : g = -g, g < 0.75 * _ * m - 0.5 * Math.abs(b * m) && g < Math.abs(u * m * 0.5) && (v = g / m)), Math.abs(v) < b && (v = v > 0 ? b : -b), s2 = o2, h2 = l, o2 += v, ((l = t2.call(i3, o2)) > 0 && c > 0 || l < 0 && c < 0) && (a2 = s2, c = h2), y++;
    }
    return o2;
  }, chandrupatla: function(t2, e2, i3) {
    var s2, o2, a2, h2, l, c, d, u, p, _, f, b, g, m, v, Z, C, y, P, E, O = 0, x = this.maxIterationsRoot, w = 1 + 1e-3 * Math.random(), S = 0.5 * w, T = n.Z.eps;
    if (r2.Z.isArray(e2)) {
      if (e2.length < 2)
        throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
      s2 = e2[0], o2 = t2.call(i3, s2), a2 = e2[1], h2 = t2.call(i3, a2);
    } else
      s2 = (l = this.findBracket(t2, e2, i3))[0], o2 = l[1], a2 = l[2], h2 = l[3];
    if (o2 * h2 > 0)
      return r2.Z.isArray(e2) ? this.fminbr(t2, [s2, a2], i3) : this.Newton(t2, s2, i3);
    c = s2, d = a2, _ = o2, f = h2;
    do {
      if (p = c + S * (d - c), g = t2.call(i3, p), Math.sign(g) === Math.sign(_) ? (u = c, c = p, b = _, _ = g) : (u = d, d = c, b = f, f = _), m = c = p, v = _ = g, Math.abs(f) < Math.abs(_) && (m = d, v = f), (Z = (2 * T * Math.abs(m) + 5e-6) / Math.abs(d - c)) > 0.5 || 0 === v)
        break;
      C = (c - d) / (u - d), y = (_ - f) / (b - f), P = 1 - Math.sqrt(1 - C), E = Math.sqrt(C), (S = P < y && y < E ? _ / (f - _) * (b / (f - b)) + _ / (b - _) * (f / (b - f)) * ((u - c) / (d - c)) : 0.5 * w) < Z && (S = Z), S > 1 - Z && (S = 1 - Z), O++;
    } while (O <= x);
    return m;
  }, fminbr: function(t2, e2, i3) {
    var s2, o2, a2, h2, l, c, d, u, p, _, f, b, g, m, v, Z, C = 0.5 * (3 - Math.sqrt(5)), y = n.Z.eps, P = n.Z.eps, E = this.maxIterationsMinimize, O = 0;
    if (!r2.Z.isArray(e2) || e2.length < 2)
      throw new Error("JXG.Math.Numerics.fminbr: length of array x0 has to be at least two.");
    for (a2 = h2 = (s2 = e2[0]) + C * ((o2 = e2[1]) - s2), l = h2, c = d = t2.call(i3, h2), u = d; O < E; ) {
      if (p = o2 - s2, _ = 0.5 * (s2 + o2), f = P * Math.abs(a2) + y / 3, Math.abs(a2 - _) + 0.5 * p <= 2 * f)
        return a2;
      b = C * (a2 < _ ? o2 - a2 : s2 - a2), Math.abs(a2 - l) >= f && (g = (a2 - h2) * (m = (a2 - h2) * (c - u)) - (a2 - l) * (v = (a2 - l) * (c - d)), (m = 2 * (m - v)) > 0 ? g = -g : m = -m, Math.abs(g) < Math.abs(b * m) && g > m * (s2 - a2 + 2 * f) && g < m * (o2 - a2 - 2 * f) && (b = g / m)), Math.abs(b) < f && (b = b > 0 ? f : -f), v = a2 + b, (Z = t2.call(i3, v)) <= c ? (v < a2 ? o2 = a2 : s2 = a2, h2 = l, l = a2, a2 = v, d = u, u = c, c = Z) : (v < a2 ? s2 = v : o2 = v, Z <= u || l === a2 ? (h2 = l, l = v, d = u, u = Z) : (Z <= d || h2 === a2 || h2 === l) && (h2 = v, d = Z)), O += 1;
    }
    return a2;
  }, RamerDouglasPeucker: function(t2, e2) {
    var i3, s2, r3, o2 = [], a2 = [], h2 = function(t3, e3, i4, s3, r4) {
      var o3 = function(t4, e4, i5) {
        var s4, r5, o4, a4, h3, l, c, d, u, p, _, f = 1e4, b = 0, g = e4;
        if (i5 - e4 < 2)
          return [-1, 0];
        if (o4 = t4[e4].scrCoords, a4 = t4[i5].scrCoords, isNaN(o4[1]) || isNaN(o4[2]))
          return [NaN, e4];
        if (isNaN(a4[1]) || isNaN(a4[2]))
          return [NaN, i5];
        for (r5 = e4 + 1; r5 < i5; r5++) {
          if (h3 = t4[r5].scrCoords, isNaN(h3[1]) || isNaN(h3[2]))
            return [NaN, r5];
          l = (l = (l = h3[1] - o4[1]) == 1 / 0 ? f : l) === -1 / 0 ? -f : l, c = (c = (c = h3[2] - o4[2]) == 1 / 0 ? f : c) === -1 / 0 ? -f : c, (p = (d = (d = (d = a4[1] - o4[1]) == 1 / 0 ? f : d) === -1 / 0 ? -f : d) * d + (u = (u = (u = a4[2] - o4[2]) == 1 / 0 ? f : u) === -1 / 0 ? -f : u) * u) >= n.Z.eps ? ((_ = (l * d + c * u) / p) < 0 ? _ = 0 : _ > 1 && (_ = 1), s4 = (l -= _ * d) * l + (c -= _ * u) * c) : (_ = 0, s4 = l * l + c * c), s4 > b && (b = s4, g = r5);
        }
        return [Math.sqrt(b), g];
      }(t3, e3, i4), a3 = o3[1];
      if (isNaN(o3[0])) {
        h2(t3, e3, a3 - 1, s3, r4), r4.push(t3[a3]);
        do {
          ++a3;
        } while (a3 <= i4 && isNaN(t3[a3].scrCoords[1] + t3[a3].scrCoords[2]));
        a3 <= i4 && r4.push(t3[a3]), h2(t3, a3 + 1, i4, s3, r4);
      } else
        o3[0] > s3 ? (h2(t3, e3, a3, s3, r4), h2(t3, a3, i4, s3, r4)) : r4.push(t3[i4]);
    };
    for (r3 = t2.length, i3 = 0; ; ) {
      for (; i3 < r3 && isNaN(t2[i3].scrCoords[1] + t2[i3].scrCoords[2]); )
        i3 += 1;
      for (s2 = i3 + 1; s2 < r3 && !isNaN(t2[s2].scrCoords[1] + t2[s2].scrCoords[2]); )
        s2 += 1;
      if (s2--, i3 < r3 && s2 > i3 && ((a2 = [])[0] = t2[i3], h2(t2, i3, s2, e2, a2), o2 = o2.concat(a2)), i3 >= r3)
        break;
      s2 < r3 - 1 && o2.push(t2[s2 + 1]), i3 = s2 + 1;
    }
    return o2;
  }, RamerDouglasPeuker: function(t2, e2) {
    return s.Z.deprecated("Numerics.RamerDouglasPeuker()", "Numerics.RamerDouglasPeucker()"), this.RamerDouglasPeucker(t2, e2);
  }, Visvalingam: function(t2, e2) {
    var i3, r3, o2, n2, a2, h2, l, c, d, u = [], p = [], _ = [];
    if ((r3 = t2.length) <= 2)
      return t2;
    for (u[0] = { used: true, lft: null, node: null }, a2 = 0, i3 = 1; i3 < r3 - 1; i3++)
      o2 = Math.abs(s.Z.Math.Numerics.det([t2[i3 - 1].usrCoords, t2[i3].usrCoords, t2[i3 + 1].usrCoords])), isNaN(o2) || (d = { v: o2, idx: i3 }, p.push(d), u[i3] = { used: true, lft: a2, node: d }, u[a2].rt = i3, a2 = i3);
    for (u[r3 - 1] = { used: true, rt: null, lft: a2, node: null }, u[a2].rt = r3 - 1, n2 = -1 / 0; p.length > e2; )
      p.sort(function(t3, e3) {
        return e3.v - t3.v;
      }), u[i3 = p.pop().idx].used = false, n2 = u[i3].node.v, a2 = u[i3].lft, h2 = u[i3].rt, u[a2].rt = h2, u[h2].lft = a2, null !== (l = u[a2].lft) && (o2 = Math.abs(s.Z.Math.Numerics.det([t2[l].usrCoords, t2[a2].usrCoords, t2[h2].usrCoords])), u[a2].node.v = o2 >= n2 ? o2 : n2), null !== (c = u[h2].rt) && (o2 = Math.abs(s.Z.Math.Numerics.det([t2[a2].usrCoords, t2[h2].usrCoords, t2[c].usrCoords])), u[h2].node.v = o2 >= n2 ? o2 : n2);
    _ = [t2[i3 = 0]];
    do {
      i3 = u[i3].rt, _.push(t2[i3]);
    } while (null !== u[i3].rt);
    return _;
  } };
  const h = n.Z.Numerics;
}, 309: (t, e, i2) => {
  i2.d(e, { Z: () => n });
  var s = i2(765), r2 = i2(275), o = i2(109);
  r2.Z.Statistics = { sum: function(t2) {
    var e2, i3 = t2.length, s2 = 0;
    for (e2 = 0; e2 < i3; e2++)
      s2 += t2[e2];
    return s2;
  }, prod: function(t2) {
    var e2, i3 = t2.length, s2 = 1;
    for (e2 = 0; e2 < i3; e2++)
      s2 *= t2[e2];
    return s2;
  }, mean: function(t2) {
    return t2.length > 0 ? this.sum(t2) / t2.length : 0;
  }, median: function(t2) {
    var e2, i3;
    return t2.length > 0 ? (ArrayBuffer.isView(t2) ? (e2 = new Float64Array(t2)).sort() : (e2 = t2.slice(0)).sort(function(t3, e3) {
      return t3 - e3;
    }), 1 & (i3 = e2.length) ? e2[parseInt(0.5 * i3, 10)] : 0.5 * (e2[0.5 * i3 - 1] + e2[0.5 * i3])) : 0;
  }, percentile: function(t2, e2) {
    var i3, s2, r3, n2, a, h = [];
    if (t2.length > 0) {
      for (ArrayBuffer.isView(t2) ? (i3 = new Float64Array(t2)).sort() : (i3 = t2.slice(0)).sort(function(t3, e3) {
        return t3 - e3;
      }), s2 = i3.length, n2 = o.Z.isArray(e2) ? e2 : [e2], r3 = 0; r3 < n2.length; r3++)
        a = s2 * n2[r3] * 0.01, parseInt(a, 10) === a ? h.push(0.5 * (i3[a - 1] + i3[a])) : h.push(i3[parseInt(a, 10)]);
      return o.Z.isArray(e2) ? h : h[0];
    }
    return 0;
  }, variance: function(t2) {
    var e2, i3, s2, r3 = t2.length;
    if (r3 > 1) {
      for (e2 = this.mean(t2), i3 = 0, s2 = 0; s2 < r3; s2++)
        i3 += (t2[s2] - e2) * (t2[s2] - e2);
      return i3 / (t2.length - 1);
    }
    return 0;
  }, sd: function(t2) {
    return Math.sqrt(this.variance(t2));
  }, weightedMean: function(t2, e2) {
    if (t2.length !== e2.length)
      throw new Error("JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch.");
    return t2.length > 0 ? this.mean(this.multiply(t2, e2)) : 0;
  }, max: function(t2) {
    return Math.max.apply(this, t2);
  }, min: function(t2) {
    return Math.min.apply(this, t2);
  }, range: function(t2) {
    return [this.min(t2), this.max(t2)];
  }, abs: function(t2) {
    var e2, i3, s2;
    if (o.Z.isArray(t2))
      if (t2.map)
        s2 = t2.map(Math.abs);
      else
        for (i3 = t2.length, s2 = [], e2 = 0; e2 < i3; e2++)
          s2[e2] = Math.abs(t2[e2]);
    else
      s2 = ArrayBuffer.isView(t2) ? t2.map(Math.abs) : Math.abs(t2);
    return s2;
  }, add: function(t2, e2) {
    var i3, s2, r3 = [];
    if (t2 = o.Z.evalSlider(t2), e2 = o.Z.evalSlider(e2), o.Z.isArray(t2) && o.Z.isNumber(e2))
      for (s2 = t2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] + e2;
    else if (o.Z.isNumber(t2) && o.Z.isArray(e2))
      for (s2 = e2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2 + e2[i3];
    else if (o.Z.isArray(t2) && o.Z.isArray(e2))
      for (s2 = Math.min(t2.length, e2.length), i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] + e2[i3];
    else
      r3 = t2 + e2;
    return r3;
  }, div: function(t2, e2) {
    var i3, s2, r3 = [];
    if (t2 = o.Z.evalSlider(t2), e2 = o.Z.evalSlider(e2), o.Z.isArray(t2) && o.Z.isNumber(e2))
      for (s2 = t2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] / e2;
    else if (o.Z.isNumber(t2) && o.Z.isArray(e2))
      for (s2 = e2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2 / e2[i3];
    else if (o.Z.isArray(t2) && o.Z.isArray(e2))
      for (s2 = Math.min(t2.length, e2.length), i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] / e2[i3];
    else
      r3 = t2 / e2;
    return r3;
  }, divide: function() {
    s.Z.deprecated("Statistics.divide()", "Statistics.div()"), r2.Z.Statistics.div.apply(r2.Z.Statistics, arguments);
  }, mod: function(t2, e2, i3) {
    var s2, n2, a = [], h = function(t3, e3) {
      return t3 % e3;
    };
    if ((i3 = o.Z.def(i3, false)) && (h = r2.Z.mod), t2 = o.Z.evalSlider(t2), e2 = o.Z.evalSlider(e2), o.Z.isArray(t2) && o.Z.isNumber(e2))
      for (n2 = t2.length, s2 = 0; s2 < n2; s2++)
        a[s2] = h(t2[s2], e2);
    else if (o.Z.isNumber(t2) && o.Z.isArray(e2))
      for (n2 = e2.length, s2 = 0; s2 < n2; s2++)
        a[s2] = h(t2, e2[s2]);
    else if (o.Z.isArray(t2) && o.Z.isArray(e2))
      for (n2 = Math.min(t2.length, e2.length), s2 = 0; s2 < n2; s2++)
        a[s2] = h(t2[s2], e2[s2]);
    else
      a = h(t2, e2);
    return a;
  }, multiply: function(t2, e2) {
    var i3, s2, r3 = [];
    if (t2 = o.Z.evalSlider(t2), e2 = o.Z.evalSlider(e2), o.Z.isArray(t2) && o.Z.isNumber(e2))
      for (s2 = t2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] * e2;
    else if (o.Z.isNumber(t2) && o.Z.isArray(e2))
      for (s2 = e2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2 * e2[i3];
    else if (o.Z.isArray(t2) && o.Z.isArray(e2))
      for (s2 = Math.min(t2.length, e2.length), i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] * e2[i3];
    else
      r3 = t2 * e2;
    return r3;
  }, subtract: function(t2, e2) {
    var i3, s2, r3 = [];
    if (t2 = o.Z.evalSlider(t2), e2 = o.Z.evalSlider(e2), o.Z.isArray(t2) && o.Z.isNumber(e2))
      for (s2 = t2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] - e2;
    else if (o.Z.isNumber(t2) && o.Z.isArray(e2))
      for (s2 = e2.length, i3 = 0; i3 < s2; i3++)
        r3[i3] = t2 - e2[i3];
    else if (o.Z.isArray(t2) && o.Z.isArray(e2))
      for (s2 = Math.min(t2.length, e2.length), i3 = 0; i3 < s2; i3++)
        r3[i3] = t2[i3] - e2[i3];
    else
      r3 = t2 - e2;
    return r3;
  }, TheilSenRegression: function(t2) {
    var e2, i3, s2 = [], o2 = [], n2 = [];
    for (e2 = 0; e2 < t2.length; e2++) {
      for (o2.length = 0, i3 = 0; i3 < t2.length; i3++)
        Math.abs(t2[i3].usrCoords[1] - t2[e2].usrCoords[1]) > r2.Z.eps && (o2[i3] = (t2[i3].usrCoords[2] - t2[e2].usrCoords[2]) / (t2[i3].usrCoords[1] - t2[e2].usrCoords[1]));
      s2[e2] = this.median(o2), n2.push(t2[e2].usrCoords[2] - s2[e2] * t2[e2].usrCoords[1]);
    }
    return [this.median(n2), this.median(s2), -1];
  }, generateGaussian: function(t2, e2) {
    var i3, s2, r3;
    if (this.hasSpare)
      return this.hasSpare = false, this.spare * e2 + t2;
    do {
      r3 = (i3 = 2 * Math.random() - 1) * i3 + (s2 = 2 * Math.random() - 1) * s2;
    } while (r3 >= 1 || 0 === r3);
    return r3 = Math.sqrt(-2 * Math.log(r3) / r3), this.spare = s2 * r3, this.hasSpare = true, t2 + e2 * i3 * r3;
  } };
  const n = r2.Z.Statistics;
}, 766: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(351), o = i2(275), n = i2(327), a = i2(109);
  s.Z.Options = { jc: { enabled: true, compile: true }, board: { boundingBox: [-5, 5, 5, -5], maxBoundingBox: [-1 / 0, 1 / 0, 1 / 0, -1 / 0], zoomFactor: 1, zoomX: 1, zoomY: 1, title: "", description: "", showCopyright: true, axis: false, defaultAxes: { x: { name: "x", fixed: true, ticks: { label: { visible: "inherit", anchorX: "middle", anchorY: "top", fontSize: 12, offset: [0, -3] }, tickEndings: [0, 1], majorTickEndings: [1, 1], drawZero: false, needsRegularUpdate: false, visible: "inherit" } }, y: { name: "y", fixed: true, ticks: { label: { visible: "inherit", anchorX: "right", anchorY: "middle", fontSize: 12, offset: [-6, 0] }, tickEndings: [1, 0], majorTickEndings: [1, 1], drawZero: false, needsRegularUpdate: false, visible: "inherit" } } }, showNavigation: true, showZoom: true, showReload: false, showScreenshot: false, screenshot: { scale: 1, type: "png", symbol: "", css: "background-color:#eeeeee; opacity:1.0; border:2px solid black; border-radius:10px; text-align:center", cssButton: "padding: 4px 10px; border: solid #356AA0 1px; border-radius: 5px; position: absolute; right: 2ex; top: 2ex; background-color: rgba(255, 255, 255, 0.3);" }, showFullscreen: false, fullscreen: { symbol: '<svg height="1em" width="1em" version="1.1" viewBox="10 10 18 18"><path fill="#666" d="m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z"></path><path fill="#666" d="m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z"></path><path fill="#666" d="m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z"></path><path fill="#666" d="M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z"></path></svg>', scale: 0.85, id: null }, showClearTraces: false, keepAspectRatio: false, ignoreLabels: true, maxNameLength: 1, document: false, takeFirst: false, takeSizeFromFile: false, renderer: "auto", animationDelay: 35, maxFrameRate: 40, registerEvents: true, registerResizeEvent: true, registerFullscreenEvent: true, minimizeReflow: "none", offsetX: 0, offsetY: 0, zoom: { enabled: true, factorX: 1.25, factorY: 1.25, wheel: true, needShift: true, min: 1e-4, max: 1e4, pinchHorizontal: true, pinchVertical: true, pinchSensitivity: 7 }, pan: { enabled: true, needShift: true, needTwoFingers: false }, browserPan: false, drag: { enabled: true }, keyboard: { enabled: true, dx: 10, dy: 10, panShift: true, panCtrl: false }, resize: { enabled: true, throttle: 10 }, moveTarget: null, selection: { enabled: false, name: "selectionPolygon", needShift: false, needCtrl: true, withLines: false, vertices: { visible: false }, fillColor: "#ffff00", visible: false }, showInfobox: true, logging: { enabled: false } }, navbar: { strokeColor: "#333333", fillColor: "transparent", highlightFillColor: "#aaaaaa", padding: "2px", position: "absolute", fontSize: "14px", cursor: "pointer", zIndex: "100", right: "5px", bottom: "5px" }, elements: { strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", fillColor: n.Z.palette.red, highlightFillColor: "none", strokeOpacity: 1, highlightStrokeOpacity: 1, fillOpacity: 1, highlightFillOpacity: 1, gradient: null, gradientSecondColor: "#ffffff", gradientSecondOpacity: 1, gradientStartOffset: 0, gradientEndOffset: 1, gradientAngle: 0, gradientCX: 0.5, gradientCY: 0.5, gradientR: 0.5, gradientFX: 0.5, gradientFY: 0.5, gradientFR: 0, transitionDuration: 100, transitionProperties: ["fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width"], strokeWidth: 2, highlightStrokeWidth: 2, fixed: false, frozen: false, withLabel: false, visible: true, priv: false, layer: 0, dash: 0, shadow: { enabled: false, color: [0, 0, 0], opacity: 1, blur: 3, blend: 0.1, offset: [5, 5] }, trace: false, traceAttributes: {}, highlight: true, needsRegularUpdate: true, snapToGrid: false, scalable: true, rotatable: true, dragToTopOfLayer: false, precision: "inherit", draft: { draft: false, strokeColor: "#565656", fillColor: "#565656", strokeOpacity: 0.8, fillOpacity: 0.8, strokeWidth: 1 }, isLabel: false, tabindex: 0 }, ticks: { generateLabelText: null, generateLabelValue: null, drawLabels: false, label: {}, beautifulScientificTickLabels: false, useUnicodeMinus: true, anchor: "left", drawZero: false, insertTicks: false, minTicksDistance: 10, minorHeight: 4, majorHeight: 10, tickEndings: [1, 1], majorTickEndings: [1, 1], ignoreInfiniteTickEndings: true, minorTicks: 4, ticksPerLabel: false, scale: 1, scaleSymbol: "", labels: [], maxLabelLength: 5, precision: 3, digits: 3, ticksDistance: 1, face: "|", strokeOpacity: 1, strokeWidth: 1, strokeColor: "#000000", highlightStrokeColor: "#888888", fillColor: "none", highlightFillColor: "none", visible: "inherit", includeBoundaries: false, type: "linear" }, hatch: { drawLabels: false, drawZero: true, majorHeight: 20, anchor: "middle", face: "|", strokeWidth: 2, strokeColor: n.Z.palette.blue, ticksDistance: 0.2 }, precision: { touch: 30, touchMax: 100, mouse: 4, pen: 4, epsilon: 1e-4, hasPoint: 4 }, layer: { numlayers: 20, unused9: 19, unused8: 18, unused7: 17, unused6: 16, unused5: 15, unused4: 14, unused3: 13, unused2: 12, unused1: 11, unused0: 10, text: 9, point: 9, glider: 9, arc: 8, line: 7, circle: 6, curve: 5, turtle: 5, polygon: 3, sector: 3, angle: 3, integral: 3, axis: 2, ticks: 2, grid: 1, image: 0, trace: 0 }, angle: { withLabel: true, radius: "auto", type: "sector", orthoType: "square", orthoSensitivity: 1, fillColor: n.Z.palette.orange, highlightFillColor: n.Z.palette.orange, strokeColor: n.Z.palette.orange, fillOpacity: 0.3, highlightFillOpacity: 0.3, radiuspoint: { withLabel: false, visible: false, name: "" }, pointsquare: { withLabel: false, visible: false, name: "" }, dot: { visible: false, strokeColor: "none", fillColor: "#000000", size: 2, face: "o", withLabel: false, name: "" }, label: { position: "top", offset: [0, 0], strokeColor: n.Z.palette.blue }, arc: { visible: false, fillColor: "none" } }, arc: { selection: "auto", hasInnerPoints: false, label: { anchorX: "auto", anchorY: "auto" }, firstArrow: false, lastArrow: false, fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", useDirection: false, center: {}, radiusPoint: {}, anglePoint: {} }, arrow: { firstArrow: false, lastArrow: { type: 1, highlightSize: 6, size: 6 } }, axis: { name: "", needsRegularUpdate: false, strokeWidth: 1, lastArrow: { type: 1, highlightSize: 8, size: 8 }, strokeColor: "#666666", highlightStrokeWidth: 1, highlightStrokeColor: "#888888", withTicks: true, straightFirst: true, straightLast: true, margin: -4, withLabel: false, scalable: false, ticks: { label: { offset: [4, -9], parse: false, needsRegularUpdate: false, display: "internal", visible: "inherit", layer: 9 }, visible: "inherit", needsRegularUpdate: false, strokeWidth: 1, strokeColor: "#666666", highlightStrokeColor: "#888888", drawLabels: true, drawZero: false, insertTicks: true, minTicksDistance: 5, minorHeight: 10, majorHeight: -1, tickEndings: [0, 1], majorTickEndings: [1, 1], minorTicks: 4, ticksDistance: 1, strokeOpacity: 0.25 }, point1: { needsRegularUpdate: false, visible: false }, point2: { needsRegularUpdate: false, visible: false }, tabindex: -1, label: { position: "lft", offset: [10, 10] } }, bisector: { strokeColor: "#000000", point: { visible: false, fixed: false, withLabel: false, name: "" } }, bisectorlines: { line1: { strokeColor: "#000000" }, line2: { strokeColor: "#000000" } }, boxplot: { dir: "vertical", smallWidth: 0.5, strokeWidth: 2, strokeColor: n.Z.palette.blue, fillColor: n.Z.palette.blue, fillOpacity: 0.2, highlightStrokeWidth: 2, highlightStrokeColor: n.Z.palette.blue, highlightFillColor: n.Z.palette.blue, highlightFillOpacity: 0.1 }, button: { disabled: false, display: "html" }, cardinalspline: { createPoints: true, isArrayOfCoordinates: true, points: { strokeOpacity: 0.05, fillOpacity: 0.05, highlightStrokeOpacity: 1, highlightFillOpacity: 1, withLabel: false, name: "", fixed: false } }, chart: { chartStyle: "line", colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#c3d9ff", "#4096EE", "#008C00"], highlightcolors: null, fillcolor: null, highlightonsector: false, highlightbysize: false, fillOpacity: 0.6, withLines: false, label: {} }, checkbox: { disabled: false, checked: false, display: "html" }, circle: { hasInnerPoints: false, fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", center: { visible: false, withLabel: false, fixed: false, fillColor: n.Z.palette.red, strokeColor: n.Z.palette.red, highlightFillColor: "#c3d9ff", highlightStrokeColor: "#c3d9ff", name: "" }, point2: { visible: false, withLabel: false, fixed: false, name: "" }, label: { position: "urt" } }, circumcircle: { fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", center: { visible: false, fixed: false, withLabel: false, fillColor: n.Z.palette.red, strokeColor: n.Z.palette.red, highlightFillColor: "#c3d9ff", highlightStrokeColor: "#c3d9ff", name: "" } }, circumcirclearc: { fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", center: { visible: false, withLabel: false, fixed: false, name: "" } }, circumcirclesector: { useDirection: true, fillColor: n.Z.palette.yellow, highlightFillColor: n.Z.palette.yellow, fillOpacity: 0.3, highlightFillOpacity: 0.3, strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", point: { visible: false, fixed: false, withLabel: false, name: "" } }, conic: { fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", foci: { fixed: false, visible: false, withLabel: false, name: "" }, center: { visible: false, withLabel: false, name: "" }, point: { withLabel: false, name: "" }, line: { visible: false } }, curve: { strokeWidth: 1, strokeColor: n.Z.palette.blue, fillColor: "none", fixed: true, useQDT: false, handDrawing: false, curveType: null, RDPsmoothing: false, numberPointsHigh: 1600, numberPointsLow: 400, doAdvancedPlot: true, recursionDepthHigh: 17, recursionDepthLow: 15, doAdvancedPlotOld: false, plotVersion: 2, label: { position: "lft" }, firstArrow: false, lastArrow: false }, foreignobject: { attractors: [], fixed: true, visible: true }, glider: { label: {} }, grid: { needsRegularUpdate: false, hasGrid: false, gridX: 1, gridY: 1, strokeColor: "#c0c0c0", strokeOpacity: 0.5, strokeWidth: 1, dash: 0, snapToGrid: false, snapSizeX: 10, snapSizeY: 10 }, group: { needsRegularUpdate: true }, htmlslider: { widthRange: 100, widthOut: 34, step: 0.01, frozen: true, isLabel: false, strokeColor: "#000000", display: "html", anchorX: "left", anchorY: "middle", withLabel: false }, image: { imageString: null, fillOpacity: 1, highlightFillOpacity: 0.6, cssClass: "JXGimage", highlightCssClass: "JXGimageHighlight", rotate: 0, snapSizeX: 1, snapSizeY: 1, attractors: [] }, incircle: { fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", center: { visible: false, fixed: false, withLabel: false, fillColor: n.Z.palette.red, strokeColor: n.Z.palette.red, highlightFillColor: "#c3d9ff", highlightStrokeColor: "#c3d9ff", name: "" } }, inequality: { fillColor: n.Z.palette.red, fillOpacity: 0.2, strokeColor: "none", inverse: false }, infobox: { distanceX: -20, distanceY: 25, fontSize: 12, isLabel: false, strokeColor: "#bbbbbb", display: "html", anchorX: "left", anchorY: "middle", cssClass: "JXGinfobox", rotate: 0, visible: true, parse: false, transitionDuration: 0, needsRegularUpdate: false, tabindex: null }, integral: { axis: "x", withLabel: true, fixed: true, strokeWidth: 0, strokeOpacity: 0, fillColor: n.Z.palette.red, fillOpacity: 0.3, highlightFillColor: n.Z.palette.red, highlightFillOpacity: 0.2, curveLeft: { visible: true, withLabel: false, color: n.Z.palette.red, fillOpacity: 0.8, layer: 9 }, baseLeft: { visible: false, fixed: false, withLabel: false, name: "" }, curveRight: { visible: true, withLabel: false, color: n.Z.palette.red, fillOpacity: 0.8, layer: 9 }, baseRight: { visible: false, fixed: false, withLabel: false, name: "" }, label: { fontSize: 20 } }, input: { disabled: false, maxlength: 524288, display: "html" }, intersection: { alwaysIntersect: true }, label: { visible: "inherit", strokeColor: "#000000", strokeOpacity: 1, highlightStrokeOpacity: 0.666666, highlightStrokeColor: "#000000", fixed: true, position: "urt", offset: [10, 10], autoPosition: false }, legend: { style: "vertical", labels: ["1", "2", "3", "4", "5", "6", "7", "8"], colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#c3d9ff", "#4096EE", "#008C00"], rowHeight: 20, strokeWidth: 5 }, line: { firstArrow: false, lastArrow: false, margin: 0, straightFirst: true, straightLast: true, fillColor: "none", highlightFillColor: "none", strokeColor: n.Z.palette.blue, highlightStrokeColor: "#c3d9ff", withTicks: false, point1: { visible: false, withLabel: false, fixed: false, name: "" }, point2: { visible: false, withLabel: false, fixed: false, name: "" }, ticks: { drawLabels: true, label: { offset: [4, -9] }, drawZero: false, insertTicks: false, minTicksDistance: 50, minorHeight: 4, majorHeight: -1, minorTicks: 4, defaultDistance: 1, strokeOpacity: 0.3, visible: "inherit" }, label: { position: "llft" }, snapToGrid: false, snapSizeX: 1, snapSizeY: 1, touchFirstPoint: false, touchLastPoint: false, lineCap: "butt" }, locus: { translateToOrigin: false, translateTo10: false, stretch: false, toOrigin: null, to10: null }, metapostspline: { createPoints: true, isArrayOfCoordinates: true, points: { strokeOpacity: 0.5, fillOpacity: 0.5, highlightStrokeOpacity: 1, highlightFillOpacity: 1, withLabel: false, name: "", fixed: false } }, mirrorelement: { fixed: true, point: {}, center: {}, type: "Euclidean" }, normal: { strokeColor: "#000000", point: { visible: false, fixed: false, withLabel: false, name: "" } }, orthogonalprojection: {}, parallel: { strokeColor: "#000000", point: { visible: false, fixed: false, withLabel: false, name: "" }, label: { position: "llft" } }, perpendicular: { strokeColor: "#000000", straightFirst: true, straightLast: true }, perpendicularsegment: { strokeColor: "#000000", straightFirst: false, straightLast: false, point: { visible: false, fixed: true, withLabel: false, name: "" } }, point: { withLabel: true, label: {}, style: 5, face: "o", size: 3, sizeUnit: "screen", strokeWidth: 2, transitionProperties: ["fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "width", "height", "rx", "ry"], fillColor: n.Z.palette.red, strokeColor: n.Z.palette.red, highlightFillColor: "#c3d9ff", highlightStrokeColor: "#c3d9ff", zoom: false, showInfobox: "inherit", infoboxDigits: "auto", draft: false, attractors: [], attractorUnit: "user", attractorDistance: 0, snatchDistance: 0, snapToGrid: false, attractToGrid: false, snapSizeX: 1, snapSizeY: 1, snapToPoints: false, ignoredSnapToPoints: [] }, polygon: { hasInnerPoints: false, fillColor: n.Z.palette.yellow, highlightFillColor: n.Z.palette.yellow, fillOpacity: 0.3, highlightFillOpacity: 0.2, withLines: true, borders: { withLabel: false, strokeWidth: 1, highlightStrokeWidth: 1, layer: 5, label: { position: "top" }, visible: "inherit" }, vertices: { layer: 9, withLabel: false, name: "", strokeColor: n.Z.palette.red, fillColor: n.Z.palette.red, fixed: false, visible: "inherit" }, label: { offset: [0, 0] } }, polygonalchain: { fillColor: "none", highlightFillColor: "none" }, prescribedangle: { anglePoint: { size: 2, visible: false, withLabel: false } }, reflection: { fixed: true, center: {}, type: "Euclidean" }, regularpolygon: { hasInnerPoints: false, fillColor: n.Z.palette.yellow, highlightFillColor: n.Z.palette.yellow, fillOpacity: 0.3, highlightFillOpacity: 0.2, withLines: true, borders: { withLabel: false, strokeWidth: 1, highlightStrokeWidth: 1, layer: 5, label: { position: "top" } }, vertices: { layer: 9, withLabel: true, strokeColor: n.Z.palette.red, fillColor: n.Z.palette.red, fixed: false }, label: { offset: [0, 0] } }, riemannsum: { withLabel: false, fillOpacity: 0.3, fillColor: n.Z.palette.yellow }, sector: { fillColor: n.Z.palette.yellow, highlightFillColor: n.Z.palette.yellow, fillOpacity: 0.3, highlightFillOpacity: 0.3, highlightOnSector: false, highlightStrokeWidth: 0, selection: "auto", arc: { visible: false, fillColor: "none" }, radiusPoint: { visible: false, withLabel: false }, center: { visible: false, withLabel: false }, anglePoint: { visible: false, withLabel: false }, label: { offset: [0, 0], anchorX: "auto", anchorY: "auto" } }, segment: { label: { position: "top" } }, semicircle: { center: { visible: false, withLabel: false, fixed: false, fillColor: n.Z.palette.red, strokeColor: n.Z.palette.red, highlightFillColor: "#eeeeee", highlightStrokeColor: n.Z.palette.red, name: "" } }, slider: { snapWidth: -1, precision: 2, digits: 2, firstArrow: false, lastArrow: false, withTicks: true, withLabel: true, suffixLabel: null, unitLabel: null, postLabel: null, layer: 9, showInfobox: false, name: "", visible: true, strokeColor: "#000000", highlightStrokeColor: "#888888", fillColor: "#ffffff", highlightFillColor: "none", size: 6, point1: { needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, name: "" }, point2: { needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, name: "" }, baseline: { needsRegularUpdate: false, visible: "inherit", fixed: true, scalable: false, tabindex: null, name: "", strokeWidth: 1, strokeColor: "#000000", highlightStrokeColor: "#888888" }, ticks: { needsRegularUpdate: false, fixed: true, drawLabels: false, digits: 2, includeBoundaries: 1, drawZero: true, label: { offset: [-4, -14], display: "internal" }, minTicksDistance: 30, insertTicks: true, minorHeight: 4, majorHeight: 5, minorTicks: 0, defaultDistance: 1, strokeOpacity: 1, strokeWidth: 1, tickEndings: [0, 1], majortickEndings: [0, 1], strokeColor: "#000000", visible: "inherit" }, highline: { strokeWidth: 3, visible: "inherit", fixed: true, tabindex: null, name: "", strokeColor: "#000000", highlightStrokeColor: "#888888" }, label: { visible: "inherit", strokeColor: "#000000" }, moveOnUp: true }, comb: { frequency: 0.2, width: 0.4, angle: Math.PI / 3, reverse: false, point1: { visible: false, withLabel: false, fixed: false, name: "" }, point2: { visible: false, withLabel: false, fixed: false, name: "" }, curve: { strokeWidth: 1, strokeColor: "#000000", fillColor: "none" } }, slopetriangle: { fillColor: n.Z.palette.red, fillOpacity: 0.4, highlightFillColor: n.Z.palette.red, highlightFillOpacity: 0.3, borders: { lastArrow: { type: 1, size: 6 } }, glider: { fixed: true, visible: false, withLabel: false }, baseline: { visible: false, withLabel: false, name: "" }, basepoint: { visible: false, withLabel: false, name: "" }, tangent: { visible: false, withLabel: false, name: "" }, toppoint: { visible: false, withLabel: false, name: "" }, label: { visible: true } }, stepfunction: {}, tapemeasure: { strokeColor: "#000000", strokeWidth: 2, highlightStrokeColor: "#000000", withTicks: true, withLabel: true, precision: 2, digits: 2, point1: { visible: "inherit", strokeColor: "#000000", fillColor: "#ffffff", fillOpacity: 0, highlightFillOpacity: 0.1, size: 6, snapToPoints: true, attractorUnit: "screen", attractorDistance: 20, showInfobox: false, withLabel: false, name: "" }, point2: { visible: "inherit", strokeColor: "#000000", fillColor: "#ffffff", fillOpacity: 0, highlightFillOpacity: 0.1, size: 6, snapToPoints: true, attractorUnit: "screen", attractorDistance: 20, showInfobox: false, withLabel: false, name: "" }, ticks: { drawLabels: false, drawZero: true, insertTicks: true, minorHeight: 8, majorHeight: 16, minorTicks: 4, tickEndings: [0, 1], majorTickEndings: [0, 1], defaultDistance: 0.1, strokeOpacity: 1, strokeWidth: 1, strokeColor: "#000000", visible: "inherit" }, label: { position: "top" } }, text: { fontSize: 12, fontUnit: "px", digits: 2, parse: true, useCaja: false, isLabel: false, strokeColor: "#000000", highlightStrokeColor: "#000000", highlightStrokeOpacity: 0.666666, cssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;", highlightCssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;", cssStyle: "", highlightCssStyle: "", transitionProperties: ["color", "opacity"], useASCIIMathML: false, useMathJax: false, useKatex: false, katexMacros: {}, display: "html", anchor: null, anchorX: "left", anchorY: "middle", cssClass: "JXGtext", highlightCssClass: "JXGtext", dragArea: "all", withLabel: false, rotate: 0, visible: true, snapSizeX: 1, snapSizeY: 1, attractors: [] }, tracecurve: { strokeColor: "#000000", fillColor: "none", numberPoints: 100 }, turtle: { strokeWidth: 1, fillColor: "none", strokeColor: "#000000", arrow: { strokeWidth: 2, withLabel: false, strokeColor: n.Z.palette.red, lastArrow: true } }, shortcuts: { color: ["strokeColor", "fillColor"], opacity: ["strokeOpacity", "fillOpacity"], highlightColor: ["highlightStrokeColor", "highlightFillColor"], highlightOpacity: ["highlightStrokeOpacity", "highlightFillOpacity"], strokeWidth: ["strokeWidth", "highlightStrokeWidth"] } }, s.Z.Validator = function() {
    var t2, e2 = function(t3) {
      return a.Z.isString(t3);
    }, i3 = function(t3) {
      return Math.abs(t3 - Math.round(t3)) < o.Z.eps;
    }, r3 = function(t3) {
      return i3(t3) && t3 > 0;
    }, n2 = function(t3) {
      return t3 > 0;
    }, h2 = function(t3) {
      return t3 >= 0;
    }, l = {}, c = { attractorDistance: h2, color: e2, defaultDistance: a.Z.isNumber, display: function(t3) {
      return "html" === t3 || "internal" === t3;
    }, doAdvancedPlot: false, draft: false, drawLabels: false, drawZero: false, face: function(t3) {
      return a.Z.exists(s.Z.normalizePointFace(t3));
    }, factor: a.Z.isNumber, fillColor: e2, fillOpacity: a.Z.isNumber, firstArrow: false, fontSize: i3, dash: i3, gridX: a.Z.isNumber, gridY: a.Z.isNumber, hasGrid: false, highlightFillColor: e2, highlightFillOpacity: a.Z.isNumber, highlightStrokeColor: e2, highlightStrokeOpacity: a.Z.isNumber, insertTicks: false, lastArrow: false, layer: function(t3) {
      return i3(t3) && t3 >= 0;
    }, majorHeight: i3, minorHeight: i3, minorTicks: h2, minTicksDistance: r3, numberPointsHigh: r3, numberPointsLow: r3, opacity: a.Z.isNumber, radius: a.Z.isNumber, RDPsmoothing: false, renderer: function(t3) {
      return "vml" === t3 || "svg" === t3 || "canvas" === t3 || "no" === t3;
    }, right: function(t3) {
      return /^[0-9]+px$/.test(t3);
    }, showCopyright: false, showInfobox: false, showNavigation: false, size: h2, snapSizeX: n2, snapSizeY: n2, snapWidth: a.Z.isNumber, snapToGrid: false, snatchDistance: h2, straightFirst: false, straightLast: false, stretch: false, strokeColor: e2, strokeOpacity: a.Z.isNumber, strokeWidth: h2, takeFirst: false, takeSizeFromFile: false, to10: false, toOrigin: false, translateTo10: false, translateToOrigin: false, useASCIIMathML: false, useDirection: false, useMathJax: false, withLabel: false, withTicks: false, zoom: false };
    for (t2 in c)
      c.hasOwnProperty(t2) && (l[t2.toLowerCase()] = c[t2]);
    return l;
  }(), s.Z.normalizePointFace = function(t2) {
    return { cross: "x", x: "x", circle: "o", o: "o", square: "[]", "[]": "[]", plus: "+", "+": "+", divide: "|", "|": "|", minus: "-", "-": "-", diamond: "<>", "<>": "<>", triangleup: "^", a: "^", "^": "^", triangledown: "v", v: "v", triangleleft: "<", "<": "<", triangleright: ">", ">": ">" }[t2];
  }, s.Z.useStandardOptions = function(t2) {
    var e2, i3, o2, n2, a2 = s.Z.Options, h2 = t2.hasGrid;
    for (e2 in t2.options.grid.hasGrid = a2.grid.hasGrid, t2.options.grid.gridX = a2.grid.gridX, t2.options.grid.gridY = a2.grid.gridY, t2.options.grid.gridColor = a2.grid.gridColor, t2.options.grid.gridOpacity = a2.grid.gridOpacity, t2.options.grid.gridDash = a2.grid.gridDash, t2.options.grid.snapToGrid = a2.grid.snapToGrid, t2.options.grid.snapSizeX = a2.grid.SnapSizeX, t2.options.grid.snapSizeY = a2.grid.SnapSizeY, t2.takeSizeFromFile = a2.takeSizeFromFile, n2 = function(t3, e3) {
      t3.visProp.fillcolor = e3.fillColor, t3.visProp.highlightfillcolor = e3.highlightFillColor, t3.visProp.strokecolor = e3.strokeColor, t3.visProp.highlightstrokecolor = e3.highlightStrokeColor;
    }, t2.objects)
      if (t2.objects.hasOwnProperty(e2))
        if ((o2 = t2.objects[e2]).elementClass === r2.Z.OBJECT_CLASS_POINT)
          n2(o2, a2.point);
        else if (o2.elementClass === r2.Z.OBJECT_CLASS_LINE)
          for (n2(o2, a2.line), i3 = 0; i3 < o2.ticks.length; i3++)
            o2.ticks[i3].majorTicks = a2.line.ticks.majorTicks, o2.ticks[i3].minTicksDistance = a2.line.ticks.minTicksDistance, o2.ticks[i3].visProp.minorheight = a2.line.ticks.minorHeight, o2.ticks[i3].visProp.majorheight = a2.line.ticks.majorHeight;
        else
          o2.elementClass === r2.Z.OBJECT_CLASS_CIRCLE ? n2(o2, a2.circle) : o2.type === r2.Z.OBJECT_TYPE_ANGLE ? n2(o2, a2.angle) : o2.type === r2.Z.OBJECT_TYPE_ARC ? n2(o2, a2.arc) : o2.type === r2.Z.OBJECT_TYPE_POLYGON ? n2(o2, a2.polygon) : o2.type === r2.Z.OBJECT_TYPE_CONIC ? n2(o2, a2.conic) : o2.type === r2.Z.OBJECT_TYPE_CURVE ? n2(o2, a2.curve) : o2.type === r2.Z.OBJECT_TYPE_SECTOR && (o2.arc.visProp.fillcolor = a2.sector.fillColor, o2.arc.visProp.highlightfillcolor = a2.sector.highlightFillColor, o2.arc.visProp.fillopacity = a2.sector.fillOpacity, o2.arc.visProp.highlightfillopacity = a2.sector.highlightFillOpacity);
    t2.fullUpdate(), h2 && !t2.hasGrid ? t2.removeGrids(t2) : !h2 && t2.hasGrid && t2.create("grid", []);
  }, s.Z.useBlackWhiteOptions = function(t2) {
    var e2 = s.Z.Options;
    e2.point.fillColor = n.Z.rgb2bw(e2.point.fillColor), e2.point.highlightFillColor = n.Z.rgb2bw(e2.point.highlightFillColor), e2.point.strokeColor = n.Z.rgb2bw(e2.point.strokeColor), e2.point.highlightStrokeColor = n.Z.rgb2bw(e2.point.highlightStrokeColor), e2.line.fillColor = n.Z.rgb2bw(e2.line.fillColor), e2.line.highlightFillColor = n.Z.rgb2bw(e2.line.highlightFillColor), e2.line.strokeColor = n.Z.rgb2bw(e2.line.strokeColor), e2.line.highlightStrokeColor = n.Z.rgb2bw(e2.line.highlightStrokeColor), e2.circle.fillColor = n.Z.rgb2bw(e2.circle.fillColor), e2.circle.highlightFillColor = n.Z.rgb2bw(e2.circle.highlightFillColor), e2.circle.strokeColor = n.Z.rgb2bw(e2.circle.strokeColor), e2.circle.highlightStrokeColor = n.Z.rgb2bw(e2.circle.highlightStrokeColor), e2.arc.fillColor = n.Z.rgb2bw(e2.arc.fillColor), e2.arc.highlightFillColor = n.Z.rgb2bw(e2.arc.highlightFillColor), e2.arc.strokeColor = n.Z.rgb2bw(e2.arc.strokeColor), e2.arc.highlightStrokeColor = n.Z.rgb2bw(e2.arc.highlightStrokeColor), e2.polygon.fillColor = n.Z.rgb2bw(e2.polygon.fillColor), e2.polygon.highlightFillColor = n.Z.rgb2bw(e2.polygon.highlightFillColor), e2.sector.fillColor = n.Z.rgb2bw(e2.sector.fillColor), e2.sector.highlightFillColor = n.Z.rgb2bw(e2.sector.highlightFillColor), e2.curve.strokeColor = n.Z.rgb2bw(e2.curve.strokeColor), e2.grid.gridColor = n.Z.rgb2bw(e2.grid.gridColor), s.Z.useStandardOptions(t2);
  }, s.Z.Options.normalizePointFace = s.Z.normalizePointFace;
  const h = s.Z.Options;
}, 632: (t, e, i2) => {
  i2.d(e, { Z: () => n });
  var s = i2(765), r2 = i2(351), o = i2(109);
  s.Z.GeonextParser = { replacePow: function(t2) {
    var e2, i3, s2, r3, o2, n2, a, h, l, c, d, u;
    for (c = (t2 = t2.replace(/(\s*)\^(\s*)/g, "^")).indexOf("^"), r3 = -1; c >= 0 && c < t2.length - 1; ) {
      if (r3 === c)
        throw new Error("JSXGraph: Error while parsing expression '" + t2 + "'");
      if (r3 = c, l = t2.slice(0, c), d = t2.slice(c + 1), ")" === l.charAt(l.length - 1)) {
        for (e2 = 1, i3 = l.length - 2; i3 >= 0 && e2 > 0; )
          ")" === (s2 = l.charAt(i3)) ? e2++ : "(" === s2 && (e2 -= 1), i3 -= 1;
        if (0 !== e2)
          throw new Error("JSXGraph: Missing '(' in expression");
        for (o2 = "", a = l.substring(0, i3 + 1), h = i3; h >= 0 && a.substr(h, 1).match(/([\w.]+)/); )
          o2 = RegExp.$1 + o2, h -= 1;
        o2 = (o2 += l.substring(i3 + 1, l.length)).replace(/([()+*%^\-/\][])/g, "\\$1");
      } else
        o2 = "[\\w\\.]+";
      if (d.match(/^([\w.]*\()/)) {
        for (e2 = 1, i3 = RegExp.$1.length; i3 < d.length && e2 > 0; )
          ")" === (s2 = d.charAt(i3)) ? e2 -= 1 : "(" === s2 && (e2 += 1), i3 += 1;
        if (0 !== e2)
          throw new Error("JSXGraph: Missing ')' in expression");
        n2 = (n2 = d.substring(0, i3)).replace(/([()+*%^\-/[\]])/g, "\\$1");
      } else
        n2 = "[\\w\\.]+";
      u = new RegExp("(" + o2 + ")\\^(" + n2 + ")"), c = (t2 = t2.replace(u, "pow($1,$2)")).indexOf("^");
    }
    return t2;
  }, replaceIf: function(t2) {
    var e2, i3, s2, r3, o2, n2, a, h, l, c = "", d = null, u = null, p = null;
    if ((s2 = t2.indexOf("If(")) < 0)
      return t2;
    for (t2 = t2.replace(/""/g, "0"); s2 >= 0; ) {
      for (e2 = t2.slice(0, s2), i3 = t2.slice(s2 + 3), o2 = 1, r3 = 0, n2 = -1, a = -1; r3 < i3.length && o2 > 0; )
        ")" === (h = i3.charAt(r3)) ? o2 -= 1 : "(" === h ? o2 += 1 : "," === h && 1 === o2 && (n2 < 0 ? n2 = r3 : a = r3), r3 += 1;
      if (l = i3.slice(0, r3 - 1), i3 = i3.slice(r3), n2 < 0)
        return "";
      if (a < 0)
        return "";
      d = l.slice(0, n2), u = l.slice(n2 + 1, a), p = l.slice(a + 1), c += e2 + "((" + (d = this.replaceIf(d)) + ")?(" + (u = this.replaceIf(u)) + "):(" + (p = this.replaceIf(p)) + "))", d = null, u = null, s2 = (t2 = i3).indexOf("If(");
    }
    return c += i3;
  }, replaceNameById: function(t2, e2, i3) {
    var s2, r3, o2, n2, a = 0, h = ["X", "Y", "L", "V"], l = function(t3) {
      return i3 ? "$('" + t3 + "')" : t3;
    };
    for (n2 = 0; n2 < h.length; n2++)
      for (a = t2.indexOf(h[n2] + "("); a >= 0; )
        a >= 0 && (s2 = t2.indexOf(")", a + 2)) >= 0 && (r3 = (r3 = t2.slice(a + 2, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 2) + (i3 ? "$('" : "") + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(")", a + 2), a = t2.indexOf(h[n2] + "(", s2);
    for (a = t2.indexOf("Dist("); a >= 0; )
      a >= 0 && (s2 = t2.indexOf(",", a + 5)) >= 0 && (r3 = (r3 = t2.slice(a + 5, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 5) + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(",", a + 5), a = t2.indexOf(",", s2), (s2 = t2.indexOf(")", a + 1)) >= 0 && (r3 = (r3 = t2.slice(a + 1, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 1) + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(")", a + 1), a = t2.indexOf("Dist(", s2);
    for (h = ["Deg", "Rad"], n2 = 0; n2 < h.length; n2++)
      for (a = t2.indexOf(h[n2] + "("); a >= 0; )
        a >= 0 && (s2 = t2.indexOf(",", a + 4)) >= 0 && (r3 = (r3 = t2.slice(a + 4, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 4) + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(",", a + 4), a = t2.indexOf(",", s2), (s2 = t2.indexOf(",", a + 1)) >= 0 && (r3 = (r3 = t2.slice(a + 1, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 1) + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(",", a + 1), a = t2.indexOf(",", s2), (s2 = t2.indexOf(")", a + 1)) >= 0 && (r3 = (r3 = t2.slice(a + 1, s2)).replace(/\\(['"])?/g, "$1"), (o2 = e2.elementsByName[r3]) && (t2 = t2.slice(0, a + 1) + l(o2.id) + t2.slice(s2))), s2 = t2.indexOf(")", a + 1), a = t2.indexOf(h[n2] + "(", s2);
    return t2;
  }, replaceIdByObj: function(t2) {
    var e2 = /(X|Y|L)\(([\w_]+)\)/g;
    return t2 = t2.replace(e2, "$('$2').$1()"), e2 = /(V)\(([\w_]+)\)/g, t2 = t2.replace(e2, "$('$2').Value()"), e2 = /(Dist)\(([\w_]+),([\w_]+)\)/g, t2 = t2.replace(e2, "dist($('$2'), $('$3'))"), e2 = /(Deg)\(([\w_]+),([ \w[\w_]+),([\w_]+)\)/g, t2 = t2.replace(e2, "deg($('$2'),$('$3'),$('$4'))"), e2 = /Rad\(([\w_]+),([\w_]+),([\w_]+)\)/g, t2 = t2.replace(e2, "rad($('$1'),$('$2'),$('$3'))"), e2 = /N\((.+)\)/g, t2 = t2.replace(e2, "($1)");
  }, geonext2JS: function(t2, e2) {
    var i3, s2, r3, o2 = ["Abs", "ACos", "ASin", "ATan", "Ceil", "Cos", "Exp", "Factorial", "Floor", "Log", "Max", "Min", "Random", "Round", "Sin", "Sqrt", "Tan", "Trunc"], n2 = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "factorial", "floor", "log", "max", "min", "random", "round", "sin", "sqrt", "tan", "ceil"];
    for (s2 = t2 = (t2 = (t2 = t2.replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&amp;/g, "&"), s2 = this.replaceNameById(s2, e2), s2 = this.replaceIf(s2), s2 = this.replacePow(s2), s2 = this.replaceIdByObj(s2), r3 = 0; r3 < o2.length; r3++)
      i3 = new RegExp(["(\\W|^)(", o2[r3], ")"].join(""), "ig"), s2 = s2.replace(i3, ["$1", n2[r3]].join(""));
    return s2 = (s2 = (s2 = (s2 = (s2 = s2.replace(/True/g, "true")).replace(/False/g, "false")).replace(/fasle/g, "false")).replace(/Pi/g, "PI")).replace(/"/g, "'");
  }, findDependencies: function(t2, e2, i3) {
    var s2, n2, a, h;
    for (n2 in o.Z.exists(i3) || (i3 = t2.board), s2 = i3.elementsByName)
      s2.hasOwnProperty(n2) && n2 !== t2.name && (s2[n2].elementClass === r2.Z.OBJECT_CLASS_TEXT && o.Z.evaluate(s2[n2].visProp.islabel) || (h = (h = n2.replace(/\[/g, "\\[")).replace(/\]/g, "\\]"), a = new RegExp("\\(([\\w\\[\\]'_ ]+,)*(" + h + ")(,[\\w\\[\\]'_ ]+)*\\)", "g"), e2.search(a) >= 0 && s2[n2].addChild(t2)));
  }, gxt2jc: function(t2, e2) {
    var i3;
    return i3 = t2 = (t2 = (t2 = t2.replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&amp;/g, "&"), i3 = (i3 = (i3 = (i3 = this.replaceNameById(i3, e2, true)).replace(/True/g, "true")).replace(/False/g, "false")).replace(/fasle/g, "false");
  } };
  const n = s.Z.GeonextParser;
}, 254: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  __webpack_require__.d(__webpack_exports__, { Z: () => __WEBPACK_DEFAULT_EXPORT__ });
  var _jxg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(765), _base_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(351), _base_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(573), _math_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(275), _math_ia__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(785), _math_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(922), _math_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(309), _utils_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(109), _utils_env__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(503);
  Object.create || (Object.create = function(t, e) {
    if ("object" != typeof t && "function" != typeof t)
      throw new TypeError("Object prototype may only be an Object: " + t);
    if (null === t)
      throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
    if (void 0 !== e)
      throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");
    function i2() {
    }
    return i2.prototype = t, new i2();
  });
  var priv = { modules: { math: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z, "math/geometry": _math_geometry__WEBPACK_IMPORTED_MODULE_5__.Z, "math/statistics": _math_statistics__WEBPACK_IMPORTED_MODULE_6__.Z, "math/numerics": _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.Numerics } }, r, _ccache;
  _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.JessieCode = function(t, e) {
    this.scope = { id: 0, hasChild: true, args: [], locals: {}, context: null, previous: null }, this.scopes = [], this.scopes.push(this.scope), this.dpstack = [[]], this.pscope = 0, this.propstack = [{}], this.propscope = 0, this.lhs = [], this.isLHS = false, this.warnLog = "jcwarn", this.$log = [], this.builtIn = this.defineBuiltIn(), this.operands = this.getPossibleOperands(), this.board = null, this.lineToElement = {}, this.parCurLine = 1, this.parCurColumn = 0, this.line = 1, this.col = 1, _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.CA && (this.CA = new _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.CA(this.node, this.createNode, this)), this.code = "", "string" == typeof t && this.parse(t, e);
  }, _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.extend(_jxg__WEBPACK_IMPORTED_MODULE_0__.Z.JessieCode.prototype, { node: function(t, e, i2) {
    return { type: t, value: e, children: i2 };
  }, createNode: function(t, e, i2) {
    var s, r2 = this.node(t, e, []);
    for (s = 2; s < arguments.length; s++)
      r2.children.push(arguments[s]);
    return "node_const" == r2.type && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(r2.value) && (r2.isMath = true), r2.line = this.parCurLine, r2.col = this.parCurColumn, r2;
  }, pushScope: function(t) {
    var e = { args: t, locals: {}, context: null, previous: this.scope };
    return this.scope.hasChild = true, this.scope = e, e.id = this.scopes.push(e) - 1, e;
  }, popScope: function() {
    var t = this.scope.previous;
    return this.scope = null !== t ? t : this.scope, this.scope;
  }, getElementById: function(t) {
    return this.board.objects[t];
  }, log: function() {
    this.$log.push(arguments), "object" == typeof console && console.log && console.log.apply(console, arguments);
  }, creator: (_ccache = {}, (r = function(t) {
    var e, i2;
    return "function" == typeof _ccache[this.board.id + t] ? e = _ccache[this.board.id + t] : (i2 = this, (e = function(e2, s) {
      var r2;
      return void 0 === (r2 = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(s) ? s : {}).name && void 0 === r2.id && (r2.name = 0 !== i2.lhs[i2.scope.id] ? i2.lhs[i2.scope.id] : ""), i2.board.create(t, e2, r2);
    }).creator = true, _ccache[this.board.id + t] = e), e;
  }).clearCache = function() {
    _ccache = {};
  }, r), letvar: function(t, e) {
    this.builtIn[t] && this._warn('"' + t + '" is a predefined value.'), this.scope.locals[t] = e;
  }, isLocalVariable: function(t) {
    for (var e = this.scope; null !== e; ) {
      if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(e.locals[t]))
        return e;
      e = e.previous;
    }
    return null;
  }, isParameter: function(t) {
    for (var e = this.scope; null !== e; ) {
      if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.indexOf(e.args, t) > -1)
        return e;
      e = e.previous;
    }
    return null;
  }, isCreator: function(t) {
    return !!_jxg__WEBPACK_IMPORTED_MODULE_0__.Z.elements[t];
  }, isMathMethod: function(t) {
    return "E" !== t && !!Math[t];
  }, isBuiltIn: function(t) {
    return !!this.builtIn[t];
  }, getvar: function(t, e, i2) {
    var s;
    if (e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(e, false), null !== (s = this.isLocalVariable(t)))
      return s.locals[t];
    if ("$board" === t || "EULER" === t || "PI" === t)
      return this.builtIn[t];
    if (i2) {
      if (this.isBuiltIn(t))
        return this.builtIn[t];
      if (this.isMathMethod(t))
        return Math[t];
      if (this.isCreator(t))
        return this.creator(t);
    }
    return e || (s = this.board.select(t)) === t ? void 0 : s;
  }, resolve: function(t) {
    for (var e = this.scope; null !== e; ) {
      if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(e.locals[t]))
        return e.locals[t];
      e = e.previous;
    }
  }, getvarJS: function(t, e, i2) {
    var s, r2 = "";
    return e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(e, false), i2 = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(i2, false), null !== this.isParameter(t) ? t : null === this.isLocalVariable(t) || i2 ? this.isCreator(t) ? "(function () { var a = Array.prototype.slice.call(arguments, 0), props = " + (i2 ? "a.pop()" : "{}") + "; return $jc$.board.create.apply($jc$.board, ['" + t + "'].concat([a, props])); })" : (i2 && this._error("Syntax error (attribute values are allowed with element creators only)"), this.isBuiltIn(t) ? (r2 = this.builtIn[t].src || this.builtIn[t], _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(r2) || r2.match(/board\.select/) ? r2 : (t = r2.split(".").pop(), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(this.board.mathLib) && null !== (s = new RegExp("^Math." + t)).exec(r2) ? r2.replace(s, "$jc$.board.mathLib." + t) : _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(this.board.mathLibJXG) && null !== (s = new RegExp("^JXG.Math.")).exec(r2) ? r2.replace(s, "$jc$.board.mathLibJXG.") : r2)) : this.isMathMethod(t) ? "$jc$.board.mathLib." + t : e ? "" : (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isId(this.board, t) ? (r2 = "$jc$.board.objects['" + t + "']", "slider" === this.board.objects[t].elType && (r2 += ".Value()")) : _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isName(this.board, t) ? (r2 = "$jc$.board.elementsByName['" + t + "']", "slider" === this.board.elementsByName[t].elType && (r2 += ".Value()")) : _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isGroup(this.board, t) && (r2 = "$jc$.board.groups['" + t + "']"), r2)) : "$jc$.resolve('" + t + "')";
  }, makeMap: function(t) {
    return t.isMap = true, t;
  }, functionCodeJS: function(t) {
    var e = t.children[0].join(", "), i2 = "", s = "";
    return "op_map" === t.value && (i2 = "{ return  ", s = " }"), "function (" + e + ") {\nvar $oldscope$ = $jc$.scope;\n$jc$.scope = $jc$.scopes[" + this.scope.id + "];\nvar r = (function () " + i2 + this.compile(t.children[1], true) + s + ")();\n$jc$.scope = $oldscope$;\nreturn r;\n}";
  }, defineFunction: function(node) {
    var fun, i, that = this, list = node.children[0], scope = this.pushScope(list), _that;
    if (this.board.options.jc.compile) {
      for (this.isLHS = false, i = 0; i < list.length; i++)
        scope.locals[list[i]] = list[i];
      this.replaceNames(node.children[1]), fun = function(jc) {
        var fun, str = "var f = function($jc$) { return " + jc.functionCodeJS(node) + "}; f;";
        try {
          for (fun = eval(str)(jc), scope.argtypes = [], i = 0; i < list.length; i++)
            scope.argtypes.push(that.resolveType(list[i], node));
          return fun;
        } catch (t) {
          return jc._warn("error compiling function\n\n" + str + "\n\n" + t.toString()), function() {
          };
        }
      }(this), this.popScope();
    } else
      fun = function(t, e, i2) {
        return function() {
          var s, r2;
          for (r2 = e.scope, e.scope = e.scopes[i2], s = 0; s < t.length; s++)
            e.scope.locals[t[s]] = arguments[s];
          return s = e.execute(node.children[1]), e.scope = r2, s;
        };
      }(list, this, scope.id);
    return fun.node = node, fun.scope = scope, fun.toJS = fun.toString, fun.toString = (_that = this, function() {
      return _that.compile(_that.replaceIDs(_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.deepCopy(node)));
    }), fun.deps = {}, this.collectDependencies(node.children[1], fun.deps), fun;
  }, mergeAttributes: function(t) {
    var e, i2 = {};
    for (e = 0; e < arguments.length; e++)
      i2 = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.deepCopy(i2, arguments[e], true);
    return i2;
  }, setProp: function(t, e, i2) {
    var s, r2, o = {};
    t.elementClass !== _base_constants__WEBPACK_IMPORTED_MODULE_1__.Z.OBJECT_CLASS_POINT || "X" !== e && "Y" !== e ? t.elementClass !== _base_constants__WEBPACK_IMPORTED_MODULE_1__.Z.OBJECT_CLASS_TEXT || "X" !== e && "Y" !== e ? t.type && t.elementClass && t.visProp ? _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t[t.methodMap[e]]) && "function" != typeof t[t.methodMap[e]] ? t[t.methodMap[e]] = i2 : (o[e] = i2, t.setAttribute(o)) : t[e] = i2 : ("number" == typeof i2 ? t[e] = function() {
      return i2;
    } : "function" == typeof i2 ? (t.isDraggable = false, t[e] = i2) : "string" == typeof i2 && (t.isDraggable = false, t[e] = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.createFunction(i2, this.board, null, true), t[e + "jc"] = i2), t[e].origin = i2, this.board.update()) : (e = e.toLowerCase(), t.isDraggable && "number" == typeof i2 ? (s = "x" === e ? i2 : t.X(), r2 = "y" === e ? i2 : t.Y(), t.setPosition(_base_constants__WEBPACK_IMPORTED_MODULE_1__.Z.COORDS_BY_USER, [s, r2])) : !t.isDraggable || "function" != typeof i2 && "string" != typeof i2 ? t.isDraggable || (s = "x" === e ? i2 : t.XEval.origin, r2 = "y" === e ? i2 : t.YEval.origin, t.addConstraint([s, r2])) : (s = "x" === e ? i2 : t.coords.usrCoords[1], r2 = "y" === e ? i2 : t.coords.usrCoords[2], t.addConstraint([s, r2])), this.board.update());
  }, _genericParse: function(t, e, i2, s) {
    var r2, o, n, a, h = t.replace(/\r\n/g, "\n").split("\n"), l = [];
    s || (this.code += t + "\n"), _base_text__WEBPACK_IMPORTED_MODULE_2__.Z && (o = _base_text__WEBPACK_IMPORTED_MODULE_2__.Z.prototype.setText, _base_text__WEBPACK_IMPORTED_MODULE_2__.Z.prototype.setText = _base_text__WEBPACK_IMPORTED_MODULE_2__.Z.prototype.setTextJessieCode);
    try {
      for (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(i2) || (i2 = false), r2 = 0; r2 < h.length; r2++)
        i2 && (h[r2] = _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.GeonextParser.geonext2JS(h[r2], this.board)), l.push(h[r2]);
      switch (t = l.join("\n"), n = parser.parse(t), this.CA && (n = this.CA.expandDerivatives(n, null, n), n = this.CA.removeTrivialNodes(n)), e) {
        case "parse":
          a = this.execute(n);
          break;
        case "manipulate":
          a = this.compile(n);
          break;
        case "getAst":
          a = n;
          break;
        default:
          a = false;
      }
    } catch (t2) {
      throw t2;
    } finally {
      _base_text__WEBPACK_IMPORTED_MODULE_2__.Z && (_base_text__WEBPACK_IMPORTED_MODULE_2__.Z.prototype.setText = o);
    }
    return a;
  }, parse: function(t, e, i2) {
    return this._genericParse(t, "parse", e, i2);
  }, manipulate: function(t, e, i2) {
    return this._genericParse(t, "manipulate", e, i2);
  }, getAST: function(t, e, i2) {
    return this._genericParse(t, "getAst", e, i2);
  }, snippet: function(t, e, i2, s) {
    var r2;
    return e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(e, true), i2 = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(i2, ""), s = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(s, false), r2 = (e ? " function (" + i2 + ") { return " : "") + t + (e ? "; }" : "") + ";", this.parse(r2, s, true);
  }, replaceIDs: function(t) {
    var e, i2;
    if (t.replaced && (i2 = this.board.objects[t.children[1][0].value], _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(i2) && "" !== i2.name && (t.type = "node_var", t.value = i2.name, t.children.length = 0, delete t.replaced)), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] = this.replaceIDs(t[e]);
    if (t.children)
      for (e = t.children.length; e > 0; e--)
        _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.children[e - 1]) && (t.children[e - 1] = this.replaceIDs(t.children[e - 1]));
    return t;
  }, replaceNames: function(t) {
    var e, i2;
    if (i2 = t.value, "node_op" === t.type && "op_lhs" === i2 && 1 === t.children.length ? this.isLHS = true : "node_var" === t.type && (this.isLHS ? this.letvar(i2, true) : !_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(this.getvar(i2, true)) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(this.board.elementsByName[i2]) && (t = this.createReplacementNode(t))), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] = this.replaceNames(t[e]);
    if (t.children)
      for (e = t.children.length; e > 0; e--)
        _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.children[e - 1]) && (t.children[e - 1] = this.replaceNames(t.children[e - 1]));
    return "node_op" === t.type && "op_lhs" === t.value && 1 === t.children.length && (this.isLHS = false), t;
  }, createReplacementNode: function(t) {
    var e = t.value, i2 = this.board.elementsByName[e];
    return (t = this.createNode("node_op", "op_execfun", this.createNode("node_var", "$"), [this.createNode("node_str", i2.id)])).replaced = true, t;
  }, collectDependencies: function(t, e) {
    var i2, s, r2, o;
    if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t))
      for (o = t.length, i2 = 0; i2 < o; i2++)
        this.collectDependencies(t[i2], e);
    else if (s = t.value, "node_var" === t.type && (r2 = this.getvar(s)) && r2.visProp && r2.type && r2.elementClass && r2.id && (e[r2.id] = r2), "node_op" === t.type && "op_execfun" === t.value && t.children.length > 1 && "$" === t.children[0].value && t.children[1].length > 0 && (e[r2 = t.children[1][0].value] = this.board.objects[r2]), t.children)
      for (i2 = t.children.length; i2 > 0; i2--)
        _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.children[i2 - 1]) && this.collectDependencies(t.children[i2 - 1], e);
  }, resolveProperty: function(t, e, i2) {
    return i2 = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(i2, false), t && t.methodMap && (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.subs) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.subs[e]) ? t = t.subs : _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.methodMap[e]) ? e = t.methodMap[e] : (t = t.visProp, e = e.toLowerCase())), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isFunction(t) && this._error("Accessing function properties is not allowed."), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t) || this._error(t + " is not an object"), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t[e]) || this._error("unknown property " + e), i2 && "function" == typeof t[e] ? function() {
      return t[e].apply(t, arguments);
    } : t[e];
  }, resolveType: function(t, e) {
    var i2, s;
    if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(e)) {
      for (i2 = 0; i2 < e.length; i2++)
        if ("any" !== (s = this.resolveType(t, e[i2])))
          return s;
    }
    if ("node_op" === e.type && "op_execfun" === e.value && "node_var" === e.children[0].type && e.children[0].value === t)
      return "function";
    if ("node_op" === e.type) {
      for (i2 = 0; i2 < e.children.length; i2++)
        if ("node_var" === e.children[0].type && e.children[0].value === t && ("op_add" === e.value || "op_sub" === e.value || "op_mul" === e.value || "op_div" === e.value || "op_mod" === e.value || "op_exp" === e.value || "op_neg" === e.value))
          return "any";
      for (i2 = 0; i2 < e.children.length; i2++)
        if ("any" !== (s = this.resolveType(t, e.children[i2])))
          return s;
    }
    return "any";
  }, getLHS: function(t) {
    var e;
    if ("node_var" === t.type)
      e = { o: this.scope.locals, what: t.value };
    else if ("node_op" === t.type && "op_property" === t.value)
      e = { o: this.execute(t.children[0]), what: t.children[1] };
    else {
      if ("node_op" !== t.type || "op_extvalue" !== t.value)
        throw new Error("Syntax error: Invalid left-hand side of assignment.");
      e = { o: this.execute(t.children[0]), what: this.execute(t.children[1]) };
    }
    return e;
  }, getLHSCompiler: function(t, e) {
    var i2;
    if ("node_var" === t.type)
      i2 = t.value;
    else if ("node_op" === t.type && "op_property" === t.value)
      i2 = [this.compile(t.children[0], e), "'" + t.children[1] + "'"];
    else {
      if ("node_op" !== t.type || "op_extvalue" !== t.value)
        throw new Error("Syntax error: Invalid left-hand side of assignment.");
      i2 = [this.compile(t.children[0], e), "node_const" === t.children[1].type ? t.children[1].value : this.compile(t.children[1], e)];
    }
    return i2;
  }, execute: function(t) {
    var e, i2, s, r2, o, n, a, h, l, c, d = [];
    if (e = 0, !t)
      return e;
    switch (this.line = t.line, this.col = t.col, t.type) {
      case "node_op":
        switch (t.value) {
          case "op_none":
            t.children[0] && this.execute(t.children[0]), t.children[1] && (e = this.execute(t.children[1]));
            break;
          case "op_assign":
            i2 = this.getLHS(t.children[0]), this.lhs[this.scope.id] = i2.what, i2.o.type && i2.o.elementClass && i2.o.methodMap && "label" === i2.what && this._error("Left-hand side of assignment is read-only."), e = this.execute(t.children[1]), i2.o !== this.scope.locals || _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(i2.o) && "number" == typeof i2.what ? this.setProp(i2.o, i2.what, e) : this.letvar(i2.what, e), this.lhs[this.scope.id] = 0;
            break;
          case "op_if":
            this.execute(t.children[0]) && (e = this.execute(t.children[1]));
            break;
          case "op_conditional":
          case "op_if_else":
            e = this.execute(t.children[0]) ? this.execute(t.children[1]) : this.execute(t.children[2]);
            break;
          case "op_while":
            for (; this.execute(t.children[0]); )
              this.execute(t.children[1]);
            break;
          case "op_do":
            do {
              this.execute(t.children[0]);
            } while (this.execute(t.children[1]));
            break;
          case "op_for":
            for (this.execute(t.children[0]); this.execute(t.children[1]); this.execute(t.children[2]))
              this.execute(t.children[3]);
            break;
          case "op_proplst":
            t.children[0] && this.execute(t.children[0]), t.children[1] && this.execute(t.children[1]);
            break;
          case "op_emptyobject":
            e = {};
            break;
          case "op_proplst_val":
            this.propstack.push({}), this.propscope++, this.execute(t.children[0]), e = this.propstack[this.propscope], this.propstack.pop(), this.propscope--;
            break;
          case "op_prop":
            this.propstack[this.propscope][t.children[0]] = this.execute(t.children[1]);
            break;
          case "op_array":
            for (e = [], o = t.children[0].length, s = 0; s < o; s++)
              e.push(this.execute(t.children[0][s]));
            break;
          case "op_extvalue":
            e = this.execute(t.children[0]), e = "number" == typeof (s = this.execute(t.children[1])) && Math.abs(Math.round(s) - s) < _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.eps ? e[s] : void 0;
            break;
          case "op_return":
            if (0 !== this.scope)
              return this.execute(t.children[0]);
            this._error("Unexpected return.");
            break;
          case "op_map":
            t.children[1].isMath || "node_var" === t.children[1].type || this._error("execute: In a map only function calls and mathematical expressions are allowed."), (h = this.defineFunction(t)).isMap = true, e = h;
            break;
          case "op_function":
            (h = this.defineFunction(t)).isMap = false, e = h;
            break;
          case "op_execfun":
            if (this.dpstack.push([]), this.pscope++, n = t.children[1], _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.children[2]))
              if (t.children[3])
                for (a = t.children[2], l = {}, s = 0; s < a.length; s++)
                  l = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.deepCopy(l, this.execute(a[s]), true);
              else
                l = this.execute(t.children[2]);
            for (t.children[0]._isFunctionName = true, h = this.execute(t.children[0]), delete t.children[0]._isFunctionName, c = h && h.sc ? h.sc : this, !h.creator && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.children[2]) && this._error("Unexpected value. Only element creators are allowed to have a value after the function call."), s = 0; s < n.length; s++)
              _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(h.scope) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(h.scope.argtypes) && "function" === h.scope.argtypes[s] ? (n[s]._isFunctionName = true, d[s] = this.execute(n[s]), delete n[s]._isFunctionName) : d[s] = this.execute(n[s]), this.dpstack[this.pscope].push({ line: t.children[1][s].line, col: t.children[1][s].ecol });
            if ("function" != typeof h || h.creator)
              if ("function" == typeof h && h.creator) {
                r2 = this.line;
                try {
                  for ((e = h(d, l)).jcLineStart = r2, e.jcLineEnd = t.eline, s = r2; s <= t.line; s++)
                    this.lineToElement[s] = e;
                  e.debugParents = this.dpstack[this.pscope];
                } catch (t2) {
                  this._error(t2.toString());
                }
              } else
                this._error("Function '" + h + "' is undefined.");
            else
              e = h.apply(c, d);
            this.dpstack.pop(), this.pscope--;
            break;
          case "op_property":
            r2 = this.execute(t.children[0]), i2 = t.children[1], e = this.resolveProperty(r2, i2, false), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(e) && (e.sc = r2);
            break;
          case "op_use":
            this._warn("Use of the 'use' operator is deprecated."), this.use(t.children[0].toString());
            break;
          case "op_delete":
            this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function."), i2 = this.getvar(t.children[0]), e = this.del(i2);
            break;
          case "op_eq":
            e = this.execute(t.children[0]) == this.execute(t.children[1]);
            break;
          case "op_neq":
            e = this.execute(t.children[0]) != this.execute(t.children[1]);
            break;
          case "op_approx":
            e = Math.abs(this.execute(t.children[0]) - this.execute(t.children[1])) < _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.eps;
            break;
          case "op_gt":
            e = this.execute(t.children[0]) > this.execute(t.children[1]);
            break;
          case "op_lt":
            e = this.execute(t.children[0]) < this.execute(t.children[1]);
            break;
          case "op_geq":
            e = this.execute(t.children[0]) >= this.execute(t.children[1]);
            break;
          case "op_leq":
            e = this.execute(t.children[0]) <= this.execute(t.children[1]);
            break;
          case "op_or":
            e = this.execute(t.children[0]) || this.execute(t.children[1]);
            break;
          case "op_and":
            e = this.execute(t.children[0]) && this.execute(t.children[1]);
            break;
          case "op_not":
            e = !this.execute(t.children[0]);
            break;
          case "op_add":
            e = this.add(this.execute(t.children[0]), this.execute(t.children[1]));
            break;
          case "op_sub":
            e = this.sub(this.execute(t.children[0]), this.execute(t.children[1]));
            break;
          case "op_div":
            e = this.div(this.execute(t.children[0]), this.execute(t.children[1]));
            break;
          case "op_mod":
            e = this.mod(this.execute(t.children[0]), this.execute(t.children[1]), true);
            break;
          case "op_mul":
            e = this.mul(this.execute(t.children[0]), this.execute(t.children[1]));
            break;
          case "op_exp":
            e = this.pow(this.execute(t.children[0]), this.execute(t.children[1]));
            break;
          case "op_neg":
            e = this.neg(this.execute(t.children[0]));
        }
        break;
      case "node_var":
        e = this.getvar(t.value, false, t._isFunctionName);
        break;
      case "node_const":
        e = null === t.value ? null : Number(t.value);
        break;
      case "node_const_bool":
        e = t.value;
        break;
      case "node_str":
        e = t.value.replace(/\\(.)/g, "$1");
    }
    return e;
  }, compile: function(t, e) {
    var i2, s, r2, o = "";
    if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(e) || (e = false), !t)
      return o;
    switch (t.type) {
      case "node_op":
        switch (t.value) {
          case "op_none":
            t.children[0] && (o = this.compile(t.children[0], e)), t.children[1] && (o += this.compile(t.children[1], e));
            break;
          case "op_assign":
            e ? (i2 = this.getLHSCompiler(t.children[0], e), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(i2) ? o = "$jc$.setProp(" + i2[0] + ", " + i2[1] + ", " + this.compile(t.children[1], e) + ");\n" : (this.isLocalVariable(i2) !== this.scope && (this.scope.locals[i2] = true), o = "$jc$.scopes[" + this.scope.id + "].locals['" + i2 + "'] = " + this.compile(t.children[1], e) + ";\n")) : o = (i2 = this.compile(t.children[0])) + " = " + this.compile(t.children[1], e) + ";\n";
            break;
          case "op_if":
            o = " if (" + this.compile(t.children[0], e) + ") " + this.compile(t.children[1], e);
            break;
          case "op_if_else":
            o = " if (" + this.compile(t.children[0], e) + ")" + this.compile(t.children[1], e), o += " else " + this.compile(t.children[2], e);
            break;
          case "op_conditional":
            o = "((" + this.compile(t.children[0], e) + ")?(" + this.compile(t.children[1], e), o += "):(" + this.compile(t.children[2], e) + "))";
            break;
          case "op_while":
            o = " while (" + this.compile(t.children[0], e) + ") {\n" + this.compile(t.children[1], e) + "}\n";
            break;
          case "op_do":
            o = " do {\n" + this.compile(t.children[0], e) + "} while (" + this.compile(t.children[1], e) + ");\n";
            break;
          case "op_for":
            o = " for (" + this.compile(t.children[0], e) + this.compile(t.children[1], e) + "; " + this.compile(t.children[2], e).slice(0, -2) + ") {\n" + this.compile(t.children[3], e) + "\n}\n";
            break;
          case "op_proplst":
            t.children[0] && (o = this.compile(t.children[0], e) + ", "), o += this.compile(t.children[1], e);
            break;
          case "op_prop":
            o = t.children[0] + ": " + this.compile(t.children[1], e);
            break;
          case "op_emptyobject":
            o = e ? "{}" : "<< >>";
            break;
          case "op_proplst_val":
            o = this.compile(t.children[0], e);
            break;
          case "op_array":
            for (r2 = [], s = 0; s < t.children[0].length; s++)
              r2.push(this.compile(t.children[0][s], e));
            o = "[" + r2.join(", ") + "]";
            break;
          case "op_extvalue":
            o = this.compile(t.children[0], e) + "[" + this.compile(t.children[1], e) + "]";
            break;
          case "op_return":
            o = " return " + this.compile(t.children[0], e) + ";\n";
            break;
          case "op_map":
            t.children[1].isMath || "node_var" === t.children[1].type || this._error("compile: In a map only function calls and mathematical expressions are allowed."), r2 = t.children[0], o = e ? " $jc$.makeMap(function (" + r2.join(", ") + ") { return " + this.compile(t.children[1], e) + "; })" : "map (" + r2.join(", ") + ") -> " + this.compile(t.children[1], e);
            break;
          case "op_function":
            r2 = t.children[0], this.pushScope(r2), o = e ? this.functionCodeJS(t) : " function (" + r2.join(", ") + ") " + this.compile(t.children[1], e), this.popScope();
            break;
          case "op_execfunmath":
            console.log("op_execfunmath: TODO"), o = "-1";
            break;
          case "op_execfun":
            if (t.children[2]) {
              for (r2 = [], s = 0; s < t.children[2].length; s++)
                r2.push(this.compile(t.children[2][s], e));
              i2 = e ? "$jc$.mergeAttributes(" + r2.join(", ") + ")" : r2.join(", ");
            }
            for (t.children[0].withProps = !!t.children[2], r2 = [], s = 0; s < t.children[1].length; s++)
              r2.push(this.compile(t.children[1][s], e));
            o = this.compile(t.children[0], e) + "(" + r2.join(", ") + (t.children[2] && e ? ", " + i2 : "") + ")" + (t.children[2] && !e ? " " + i2 : ""), e && (o += "\n"), e && "$" === t.children[0].value && (o = "$jc$.board.objects[" + this.compile(t.children[1][0], e) + "]");
            break;
          case "op_property":
            o = e && "X" !== t.children[1] && "Y" !== t.children[1] ? "$jc$.resolveProperty(" + this.compile(t.children[0], e) + ", '" + t.children[1] + "', true)" : this.compile(t.children[0], e) + "." + t.children[1];
            break;
          case "op_use":
            this._warn("Use of the 'use' operator is deprecated."), o = e ? "$jc$.use('" : "use('", o += t.children[0].toString() + "');";
            break;
          case "op_delete":
            this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function."), o = e ? "$jc$.del(" : "remove(", o += this.compile(t.children[0], e) + ")";
            break;
          case "op_eq":
            o = "(" + this.compile(t.children[0], e) + " === " + this.compile(t.children[1], e) + ")";
            break;
          case "op_neq":
            o = "(" + this.compile(t.children[0], e) + " !== " + this.compile(t.children[1], e) + ")";
            break;
          case "op_approx":
            o = "(" + this.compile(t.children[0], e) + " ~= " + this.compile(t.children[1], e) + ")";
            break;
          case "op_gt":
            o = e ? "$jc$.gt(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " > " + this.compile(t.children[1], e) + ")";
            break;
          case "op_lt":
            o = e ? "$jc$.lt(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " < " + this.compile(t.children[1], e) + ")";
            break;
          case "op_geq":
            o = e ? "$jc$.geq(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " >= " + this.compile(t.children[1], e) + ")";
            break;
          case "op_leq":
            o = e ? "$jc$.leq(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " <= " + this.compile(t.children[1], e) + ")";
            break;
          case "op_or":
            o = "(" + this.compile(t.children[0], e) + " || " + this.compile(t.children[1], e) + ")";
            break;
          case "op_and":
            o = "(" + this.compile(t.children[0], e) + " && " + this.compile(t.children[1], e) + ")";
            break;
          case "op_not":
            o = "!(" + this.compile(t.children[0], e) + ")";
            break;
          case "op_add":
            o = e ? "$jc$.add(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " + " + this.compile(t.children[1], e) + ")";
            break;
          case "op_sub":
            o = e ? "$jc$.sub(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " - " + this.compile(t.children[1], e) + ")";
            break;
          case "op_div":
            o = e ? "$jc$.div(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " / " + this.compile(t.children[1], e) + ")";
            break;
          case "op_mod":
            o = e ? "$jc$.mod(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ", true)" : "(" + this.compile(t.children[0], e) + " % " + this.compile(t.children[1], e) + ")";
            break;
          case "op_mul":
            o = e ? "$jc$.mul(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + " * " + this.compile(t.children[1], e) + ")";
            break;
          case "op_exp":
            o = e ? "$jc$.pow(" + this.compile(t.children[0], e) + ", " + this.compile(t.children[1], e) + ")" : "(" + this.compile(t.children[0], e) + "^" + this.compile(t.children[1], e) + ")";
            break;
          case "op_neg":
            o = e ? "$jc$.neg(" + this.compile(t.children[0], e) + ")" : "(-" + this.compile(t.children[0], e) + ")";
        }
        break;
      case "node_var":
        o = e ? this.getvarJS(t.value, false, t.withProps) : t.value;
        break;
      case "node_const":
      case "node_const_bool":
        o = t.value;
        break;
      case "node_str":
        o = "'" + t.value + "'";
    }
    return t.needsBrackets && (o = e ? "{\n" + o + "\n}\n" : "<< " + o + " >>"), o;
  }, getName: function(t, e) {
    var i2 = "";
    return _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.getName) ? (i2 = t.getName(), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(i2) && "" !== i2 || !e || (i2 = t.id)) : e && (i2 = t.id), i2;
  }, X: function(t) {
    return t.X();
  }, Y: function(t) {
    return t.Y();
  }, V: function(t) {
    return t.Value();
  }, L: function(t) {
    return t.L();
  }, area: function(t) {
    return _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.Area) || this._error("Error: Can't calculate area."), t.Area();
  }, dist: function(t, e) {
    return _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.Dist) || this._error("Error: Can't calculate distance."), t.Dist(e);
  }, radius: function(t) {
    return _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(t.Radius) || this._error("Error: Can't calculate radius."), t.Radius();
  }, add: function(t, e) {
    var i2, s, r2;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e))
      r2 = _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.add(t, e);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(e))
      for (s = Math.min(t.length, e.length), r2 = [], i2 = 0; i2 < s; i2++)
        r2[i2] = t[i2] + e[i2];
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) ? r2 = t + e : _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isString(t) || _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isString(e) ? r2 = t.toString() + e.toString() : this._error("Operation + not defined on operands " + typeof t + " and " + typeof e);
    return r2;
  }, sub: function(t, e) {
    var i2, s, r2;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e))
      r2 = _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.sub(t, e);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(e))
      for (s = Math.min(t.length, e.length), r2 = [], i2 = 0; i2 < s; i2++)
        r2[i2] = t[i2] - e[i2];
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) ? r2 = t - e : this._error("Operation - not defined on operands " + typeof t + " and " + typeof e);
    return r2;
  }, neg: function(t) {
    var e, i2, s;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t))
      s = _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.negative(t);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t))
      for (i2 = t.length, s = [], e = 0; e < i2; e++)
        s[e] = -t[e];
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) ? s = -t : this._error("Unary operation - not defined on operand " + typeof t);
    return s;
  }, mul: function(t, e) {
    var i2, s, r2;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) && (i2 = t, e = t = e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e))
      r2 = _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.mul(t, e);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(e))
      s = Math.min(t.length, e.length), r2 = _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.innerProduct(t, e, s);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(e))
      for (s = e.length, r2 = [], i2 = 0; i2 < s; i2++)
        r2[i2] = t * e[i2];
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) ? r2 = t * e : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e);
    return r2;
  }, div: function(t, e) {
    var i2, s, r2;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e))
      r2 = _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.div(t, e);
    else if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e))
      for (s = t.length, r2 = [], i2 = 0; i2 < s; i2++)
        r2[i2] = t[i2] / e;
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) ? r2 = t / e : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e);
    return r2;
  }, mod: function(t, e) {
    var i2, s, r2;
    if (t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e))
      return _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.fmod(t, e);
    if (_utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isArray(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e))
      for (s = t.length, r2 = [], i2 = 0; i2 < s; i2++)
        r2[i2] = _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.mod(t[i2], e, true);
    else
      _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(t) && _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.isNumber(e) ? r2 = _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.mod(t, e, true) : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e);
    return r2;
  }, pow: function(t, e) {
    return t = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(t), e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.evalSlider(e), _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e) ? _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.pow(t, e) : _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.pow(t, e);
  }, lt: function(t, e) {
    return _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e) ? _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.lt(t, e) : t < e;
  }, leq: function(t, e) {
    return _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e) ? _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.leq(t, e) : t <= e;
  }, gt: function(t, e) {
    return _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e) ? _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.gt(t, e) : t > e;
  }, geq: function(t, e) {
    return _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(t) || _math_ia__WEBPACK_IMPORTED_MODULE_4__.Z.isInterval(e) ? Intervalt.geq(t, e) : t >= e;
  }, randint: function(t, e, i2) {
    return _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.exists(i2) || (i2 = 1), Math.round(Math.random() * (e - t) / i2) * i2 + t;
  }, DDD: function(t) {
    console.log("Dummy derivative function. This should never appear!");
  }, ifthen: function(t, e, i2) {
    return t ? e : i2;
  }, del: function(t) {
    "object" == typeof t && _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(t.type) && _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(t.elementClass) && this.board.removeObject(t);
  }, use: function(t) {
    var e, i2, s = false;
    if ("string" == typeof t) {
      for (e in _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.boards)
        if (_jxg__WEBPACK_IMPORTED_MODULE_0__.Z.boards.hasOwnProperty(e) && _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.boards[e].container === t) {
          i2 = _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.boards[e], s = true;
          break;
        }
    } else
      i2 = t, s = true;
    s ? (this.board = i2, this.builtIn.$board = i2, this.builtIn.$board.src = "$jc$.board") : this._error("Board '" + t + "' not found!");
  }, findSymbol: function(t, e) {
    var i2, s;
    for (s = -1 === (e = _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.def(e, -1)) ? this.scope : this.scopes[e]; null !== s; ) {
      for (i2 in s.locals)
        if (s.locals.hasOwnProperty(i2) && s.locals[i2] === t)
          return [i2, s];
      s = s.previous;
    }
    return [];
  }, importModule: function(t) {
    return priv.modules[t.toLowerCase()];
  }, defineBuiltIn: function() {
    var t = this, e = { PI: Math.PI, EULER: Math.E, D: t.DDD, X: t.X, Y: t.Y, V: t.V, L: t.L, acosh: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.acosh, acot: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.acot, asinh: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.asinh, binomial: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.binomial, cbrt: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.cbrt, cosh: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.cosh, cot: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.cot, deg: _math_geometry__WEBPACK_IMPORTED_MODULE_5__.Z.trueAngle, A: t.area, area: t.area, dist: t.dist, R: t.radius, radius: t.radius, erf: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.erf, erfc: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.erfc, erfi: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.erfi, factorial: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.factorial, gcd: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.gcd, lb: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log2, lcm: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.lcm, ld: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log2, lg: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log10, ln: Math.log, log: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log, log10: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log10, log2: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.log2, ndtr: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.ndtr, ndtri: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.ndtri, nthroot: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.nthroot, pow: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.pow, rad: _math_geometry__WEBPACK_IMPORTED_MODULE_5__.Z.rad, ratpow: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.ratpow, trunc: _utils_type__WEBPACK_IMPORTED_MODULE_7__.Z.trunc, sinh: _math_math__WEBPACK_IMPORTED_MODULE_3__.Z.sinh, randint: t.randint, IfThen: t.ifthen, import: t.importModule, use: t.use, remove: t.del, $: t.getElementById, getName: t.getName, name: t.getName, $board: t.board, $log: t.log };
    return e.rad.sc = _math_geometry__WEBPACK_IMPORTED_MODULE_5__.Z, e.deg.sc = _math_geometry__WEBPACK_IMPORTED_MODULE_5__.Z, e.factorial.sc = _math_math__WEBPACK_IMPORTED_MODULE_3__.Z, e.X.src = "$jc$.X", e.Y.src = "$jc$.Y", e.V.src = "$jc$.V", e.L.src = "$jc$.L", e.acosh.src = "JXG.Math.acosh", e.acot.src = "JXG.Math.acot", e.asinh.src = "JXG.Math.asinh", e.binomial.src = "JXG.Math.binomial", e.cbrt.src = "JXG.Math.cbrt", e.cot.src = "JXG.Math.cot", e.cosh.src = "JXG.Math.cosh", e.deg.src = "JXG.Math.Geometry.trueAngle", e.erf.src = "JXG.Math.erf", e.erfc.src = "JXG.Math.erfc", e.erfi.src = "JXG.Math.erfi", e.A.src = "$jc$.area", e.area.src = "$jc$.area", e.dist.src = "$jc$.dist", e.R.src = "$jc$.radius", e.radius.src = "$jc$.radius", e.factorial.src = "JXG.Math.factorial", e.gcd.src = "JXG.Math.gcd", e.lb.src = "JXG.Math.log2", e.lcm.src = "JXG.Math.lcm", e.ld.src = "JXG.Math.log2", e.lg.src = "JXG.Math.log10", e.ln.src = "Math.log", e.log.src = "JXG.Math.log", e.log10.src = "JXG.Math.log10", e.log2.src = "JXG.Math.log2", e.ndtr.src = "JXG.Math.ndtr", e.ndtri.src = "JXG.Math.ndtri", e.nthroot.src = "JXG.Math.nthroot", e.pow.src = "JXG.Math.pow", e.rad.src = "JXG.Math.Geometry.rad", e.ratpow.src = "JXG.Math.ratpow", e.trunc.src = "JXG.trunc", e.sinh.src = "JXG.Math.sinh", e.randint.src = "$jc$.randint", e.import.src = "$jc$.importModule", e.use.src = "$jc$.use", e.remove.src = "$jc$.del", e.IfThen.src = "$jc$.ifthen", e.$.src = "(function (n) { return $jc$.board.select(n); })", e.getName.src = "$jc$.getName", e.name.src = "$jc$.getName", e.$board && (e.$board.src = "$jc$.board"), e.$log.src = "$jc$.log", e;
  }, getPossibleOperands: function() {
    var t, e, i2, s, r2, o, n, a, h, l, c, d, u, p, _ = ["E"], f = this.defineBuiltIn(), b = Math;
    for (u = function(t2, e2) {
      return t2.toLowerCase().localeCompare(e2.toLowerCase());
    }, p = function(t2, e2) {
      var i3 = null;
      if ("jc" === e2)
        i3 = f[t2];
      else {
        if ("Math" !== e2)
          return;
        i3 = b[t2];
      }
      if (!(_.indexOf(t2) >= 0))
        return _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.isFunction(i3) ? { name: t2, type: "function", numParams: i3.length, origin: e2 } : _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.isNumber(i3) ? { name: t2, type: "constant", value: i3, origin: e2 } : void (void 0 !== i3 && console.error("undefined type", i3));
    }, t = Object.getOwnPropertyNames(f).sort(u), e = Object.getOwnPropertyNames(b).sort(u), i2 = [], s = 0, r2 = 0; s < t.length || r2 < e.length; )
      t[s] === e[r2] ? (o = p(e[r2], "Math"), _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(o) && i2.push(o), s++, r2++) : !_jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(e[r2]) || t[s].toLowerCase().localeCompare(e[r2].toLowerCase()) < 0 ? (o = p(t[s], "jc"), _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(o) && i2.push(o), s++) : (o = p(e[r2], "Math"), _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.exists(o) && i2.push(o), r2++);
    for (h = [], l = [], c = [], d = {}, n = i2.length, s = 0; s < n; s++) {
      switch ((a = i2[s]).type) {
        case "function":
          h.push(a.name), "jc" === a.origin && l.push(a.name);
          break;
        case "constant":
          c.push(a.name);
      }
      d[a.name] = a;
    }
    return { all: d, list: i2, functions: h, functions_jessiecode: l, constants: c };
  }, _debug: function(t) {
    "object" == typeof console ? console.log(t) : _utils_env__WEBPACK_IMPORTED_MODULE_8__.Z.isBrowser && document && null !== document.getElementById("debug") && (document.getElementById("debug").innerHTML += t + "<br />");
  }, _error: function(t) {
    var e = new Error("Error(" + this.line + "): " + t);
    throw e.line = this.line, e;
  }, _warn: function(t) {
    "object" == typeof console ? console.log("Warning(" + this.line + "): " + t) : _utils_env__WEBPACK_IMPORTED_MODULE_8__.Z.isBrowser && document && null !== document.getElementById(this.warnLog) && (document.getElementById(this.warnLog).innerHTML += "Warning(" + this.line + "): " + t + "<br />");
  }, _log: function(t) {
    "object" != typeof window && "object" == typeof self && self.postMessage ? self.postMessage({ type: "log", msg: "Log: " + t.toString() }) : console.log("Log: ", arguments);
  } });
  var parser = function() {
    var t = function(t2, e2, i3, s2) {
      for (i3 = i3 || {}, s2 = t2.length; s2--; i3[t2[s2]] = e2)
        ;
      return i3;
    }, e = [2, 14], i2 = [1, 13], s = [1, 37], r2 = [1, 14], o = [1, 15], n = [1, 21], a = [1, 16], h = [1, 17], l = [1, 33], c = [1, 18], d = [1, 19], u = [1, 12], p = [1, 59], _ = [1, 60], f = [1, 58], b = [1, 46], g = [1, 48], m = [1, 49], v = [1, 50], Z = [1, 51], C = [1, 52], y = [1, 53], P = [1, 54], E = [1, 45], O = [1, 38], x = [1, 39], w = [5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], S = [5, 7, 8, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], T = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], M = [2, 48], N = [1, 72], A = [10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 66, 83, 86], k = [1, 78], R = [8, 10, 16, 32, 34, 35, 37, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], D = [1, 82], L = [8, 10, 16, 32, 34, 35, 37, 39, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], B = [1, 83], I = [1, 84], Y = [1, 85], j = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], X = [1, 89], U = [1, 90], F = [1, 91], J = [1, 92], G = [1, 97], z = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 53, 54, 55, 57, 64, 65, 66, 83, 86], H = [1, 103], W = [1, 104], V = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 57, 64, 65, 66, 83, 86], $ = [1, 105], K = [1, 106], q = [1, 107], Q = [1, 126], tt = [1, 139], et = [83, 86], it = [1, 150], st = [10, 66, 86], rt = [8, 10, 16, 20, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 82, 83, 86], ot = [1, 167], nt = [10, 86], at = { trace: function() {
    }, yy: {}, symbols_: { error: 2, Program: 3, StatementList: 4, EOF: 5, IfStatement: 6, IF: 7, "(": 8, Expression: 9, ")": 10, Statement: 11, ELSE: 12, LoopStatement: 13, WHILE: 14, FOR: 15, ";": 16, DO: 17, UnaryStatement: 18, USE: 19, IDENTIFIER: 20, DELETE: 21, ReturnStatement: 22, RETURN: 23, EmptyStatement: 24, StatementBlock: 25, "{": 26, "}": 27, ExpressionStatement: 28, AssignmentExpression: 29, ConditionalExpression: 30, LeftHandSideExpression: 31, "=": 32, LogicalORExpression: 33, "?": 34, ":": 35, LogicalANDExpression: 36, "||": 37, EqualityExpression: 38, "&&": 39, RelationalExpression: 40, "==": 41, "!=": 42, "~=": 43, AdditiveExpression: 44, "<": 45, ">": 46, "<=": 47, ">=": 48, MultiplicativeExpression: 49, "+": 50, "-": 51, UnaryExpression: 52, "*": 53, "/": 54, "%": 55, ExponentExpression: 56, "^": 57, "!": 58, MemberExpression: 59, CallExpression: 60, PrimaryExpression: 61, FunctionExpression: 62, MapExpression: 63, ".": 64, "[": 65, "]": 66, BasicLiteral: 67, ObjectLiteral: 68, ArrayLiteral: 69, NullLiteral: 70, BooleanLiteral: 71, StringLiteral: 72, NumberLiteral: 73, NULL: 74, TRUE: 75, FALSE: 76, STRING: 77, NUMBER: 78, NAN: 79, INFINITY: 80, ElementList: 81, "<<": 82, ">>": 83, PropertyList: 84, Property: 85, ",": 86, PropertyName: 87, Arguments: 88, AttributeList: 89, Attribute: 90, FUNCTION: 91, ParameterDefinitionList: 92, MAP: 93, "->": 94, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 7: "IF", 8: "(", 10: ")", 12: "ELSE", 14: "WHILE", 15: "FOR", 16: ";", 17: "DO", 19: "USE", 20: "IDENTIFIER", 21: "DELETE", 23: "RETURN", 26: "{", 27: "}", 32: "=", 34: "?", 35: ":", 37: "||", 39: "&&", 41: "==", 42: "!=", 43: "~=", 45: "<", 46: ">", 47: "<=", 48: ">=", 50: "+", 51: "-", 53: "*", 54: "/", 55: "%", 57: "^", 58: "!", 64: ".", 65: "[", 66: "]", 74: "NULL", 75: "TRUE", 76: "FALSE", 77: "STRING", 78: "NUMBER", 79: "NAN", 80: "INFINITY", 82: "<<", 83: ">>", 86: ",", 91: "FUNCTION", 93: "MAP", 94: "->" }, productions_: [0, [3, 2], [6, 5], [6, 7], [13, 5], [13, 9], [13, 7], [18, 2], [18, 2], [22, 2], [22, 3], [24, 1], [25, 3], [4, 2], [4, 0], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [28, 2], [9, 1], [29, 1], [29, 3], [30, 1], [30, 5], [33, 1], [33, 3], [36, 1], [36, 3], [38, 1], [38, 3], [38, 3], [38, 3], [40, 1], [40, 3], [40, 3], [40, 3], [40, 3], [44, 1], [44, 3], [44, 3], [49, 1], [49, 3], [49, 3], [49, 3], [56, 1], [56, 3], [52, 1], [52, 2], [52, 2], [52, 2], [31, 1], [31, 1], [59, 1], [59, 1], [59, 1], [59, 3], [59, 4], [61, 1], [61, 1], [61, 1], [61, 1], [61, 3], [67, 1], [67, 1], [67, 1], [67, 1], [70, 1], [71, 1], [71, 1], [72, 1], [73, 1], [73, 1], [73, 1], [69, 2], [69, 3], [68, 2], [68, 3], [84, 1], [84, 3], [85, 3], [87, 1], [87, 1], [87, 1], [60, 2], [60, 3], [60, 2], [60, 4], [60, 3], [88, 2], [88, 3], [89, 1], [89, 3], [90, 1], [90, 1], [81, 1], [81, 3], [62, 4], [62, 5], [63, 5], [63, 6], [92, 1], [92, 3]], performAction: function(t2, e2, i3, s2, r3, o2, n2) {
      var a2 = o2.length - 1;
      switch (r3) {
        case 1:
          return o2[a2 - 1];
        case 2:
          this.$ = ht.createNode(lt(n2[a2 - 4]), "node_op", "op_if", o2[a2 - 2], o2[a2]);
          break;
        case 3:
          this.$ = ht.createNode(lt(n2[a2 - 6]), "node_op", "op_if_else", o2[a2 - 4], o2[a2 - 2], o2[a2]);
          break;
        case 4:
          this.$ = ht.createNode(lt(n2[a2 - 4]), "node_op", "op_while", o2[a2 - 2], o2[a2]);
          break;
        case 5:
          this.$ = ht.createNode(lt(n2[a2 - 8]), "node_op", "op_for", o2[a2 - 6], o2[a2 - 4], o2[a2 - 2], o2[a2]);
          break;
        case 6:
          this.$ = ht.createNode(lt(n2[a2 - 6]), "node_op", "op_do", o2[a2 - 5], o2[a2 - 2]);
          break;
        case 7:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_use", o2[a2]);
          break;
        case 8:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_delete", o2[a2]);
          break;
        case 9:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_return", void 0);
          break;
        case 10:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_return", o2[a2 - 1]);
          break;
        case 11:
        case 14:
          this.$ = ht.createNode(lt(n2[a2]), "node_op", "op_none");
          break;
        case 12:
          this.$ = o2[a2 - 1], this.$.needsBrackets = true;
          break;
        case 13:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_none", o2[a2 - 1], o2[a2]);
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 23:
        case 24:
        case 26:
        case 28:
        case 30:
        case 32:
        case 36:
        case 41:
        case 44:
        case 48:
        case 50:
        case 52:
        case 54:
        case 55:
        case 56:
        case 58:
        case 62:
        case 81:
        case 84:
        case 85:
        case 86:
          this.$ = o2[a2];
          break;
        case 22:
        case 65:
        case 93:
          this.$ = o2[a2 - 1];
          break;
        case 25:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_assign", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 27:
          this.$ = ht.createNode(lt(n2[a2 - 4]), "node_op", "op_conditional", o2[a2 - 4], o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 29:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_or", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 31:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_and", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 33:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_eq", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 34:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_neq", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 35:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_approx", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 37:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_lt", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 38:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_gt", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 39:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_leq", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 40:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_geq", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 42:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_add", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 43:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_sub", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 45:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_mul", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 46:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_div", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 47:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_mod", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 49:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_exp", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 51:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_not", o2[a2]), this.$.isMath = false;
          break;
        case 53:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_neg", o2[a2]), this.$.isMath = true;
          break;
        case 57:
        case 63:
        case 64:
        case 66:
        case 67:
        case 68:
        case 97:
          this.$ = o2[a2], this.$.isMath = false;
          break;
        case 59:
        case 91:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_property", o2[a2 - 2], o2[a2]), this.$.isMath = true;
          break;
        case 60:
        case 90:
          this.$ = ht.createNode(lt(n2[a2 - 3]), "node_op", "op_extvalue", o2[a2 - 3], o2[a2 - 1]), this.$.isMath = true;
          break;
        case 61:
          this.$ = ht.createNode(lt(n2[a2]), "node_var", o2[a2]);
          break;
        case 69:
          this.$ = o2[a2], this.$.isMath = true;
          break;
        case 70:
          this.$ = ht.createNode(lt(n2[a2]), "node_const", null);
          break;
        case 71:
          this.$ = ht.createNode(lt(n2[a2]), "node_const_bool", true);
          break;
        case 72:
          this.$ = ht.createNode(lt(n2[a2]), "node_const_bool", false);
          break;
        case 73:
          this.$ = ht.createNode(lt(n2[a2]), "node_str", o2[a2].substring(1, o2[a2].length - 1));
          break;
        case 74:
          this.$ = ht.createNode(lt(n2[a2]), "node_const", parseFloat(o2[a2]));
          break;
        case 75:
          this.$ = ht.createNode(lt(n2[a2]), "node_const", NaN);
          break;
        case 76:
          this.$ = ht.createNode(lt(n2[a2]), "node_const", 1 / 0);
          break;
        case 77:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_array", []);
          break;
        case 78:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_array", o2[a2 - 1]);
          break;
        case 79:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_emptyobject", {}), this.$.needsBrackets = true;
          break;
        case 80:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_proplst_val", o2[a2 - 1]), this.$.needsBrackets = true;
          break;
        case 82:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_proplst", o2[a2 - 2], o2[a2]);
          break;
        case 83:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_prop", o2[a2 - 2], o2[a2]);
          break;
        case 87:
        case 89:
          this.$ = ht.createNode(lt(n2[a2 - 1]), "node_op", "op_execfun", o2[a2 - 1], o2[a2]), this.$.isMath = true;
          break;
        case 88:
          this.$ = ht.createNode(lt(n2[a2 - 2]), "node_op", "op_execfun", o2[a2 - 2], o2[a2 - 1], o2[a2], true), this.$.isMath = false;
          break;
        case 92:
          this.$ = [];
          break;
        case 94:
        case 98:
        case 104:
          this.$ = [o2[a2]];
          break;
        case 95:
        case 99:
        case 105:
          this.$ = o2[a2 - 2].concat(o2[a2]);
          break;
        case 96:
          this.$ = ht.createNode(lt(n2[a2]), "node_var", o2[a2]), this.$.isMath = true;
          break;
        case 100:
          this.$ = ht.createNode(lt(n2[a2 - 3]), "node_op", "op_function", [], o2[a2]), this.$.isMath = false;
          break;
        case 101:
          this.$ = ht.createNode(lt(n2[a2 - 4]), "node_op", "op_function", o2[a2 - 2], o2[a2]), this.$.isMath = false;
          break;
        case 102:
          this.$ = ht.createNode(lt(n2[a2 - 4]), "node_op", "op_map", [], o2[a2]);
          break;
        case 103:
          this.$ = ht.createNode(lt(n2[a2 - 5]), "node_op", "op_map", o2[a2 - 3], o2[a2]);
      }
    }, table: [t([5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], e, { 3: 1, 4: 2 }), { 1: [3] }, { 5: [1, 3], 6: 6, 7: i2, 8: s, 9: 20, 11: 4, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 1: [2, 1] }, t(w, [2, 13]), t(S, [2, 15]), t(S, [2, 16]), t(S, [2, 17]), t(S, [2, 18]), t(S, [2, 19]), t(S, [2, 20]), t(S, [2, 21]), t([7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], e, { 4: 61 }), { 8: [1, 62] }, { 8: [1, 63] }, { 8: [1, 64] }, { 6: 6, 7: i2, 8: s, 9: 20, 11: 65, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 20: [1, 66] }, { 20: [1, 67] }, { 8: s, 9: 69, 16: [1, 68], 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 16: [1, 70] }, t(S, [2, 11]), t(T, [2, 23]), t(T, [2, 24]), t([8, 10, 16, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], M, { 32: [1, 71], 57: N }), t([8, 10, 16, 32, 35, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], [2, 26], { 34: [1, 73], 37: [1, 74] }), t(A, [2, 54], { 88: 77, 8: k, 64: [1, 75], 65: [1, 76] }), t(A, [2, 55], { 88: 79, 8: k, 64: [1, 81], 65: [1, 80] }), t(R, [2, 28], { 39: D }), t(T, [2, 56]), t(T, [2, 57]), t(T, [2, 58]), t(L, [2, 30], { 41: B, 42: I, 43: Y }), t(T, [2, 61]), t(T, [2, 62]), t(T, [2, 63]), t(T, [2, 64]), { 8: s, 9: 86, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: [1, 87] }, { 8: [1, 88] }, t(j, [2, 32], { 45: X, 46: U, 47: F, 48: J }), t(T, [2, 66]), t(T, [2, 67]), t(T, [2, 68]), t(T, [2, 69]), { 20: G, 72: 98, 73: 99, 77: Z, 78: C, 79: y, 80: P, 83: [1, 93], 84: 94, 85: 95, 87: 96 }, { 8: s, 20: l, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 66: [1, 100], 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 81: 101, 82: E, 91: O, 93: x }, t(z, [2, 36], { 50: H, 51: W }), t(T, [2, 70]), t(T, [2, 71]), t(T, [2, 72]), t(T, [2, 73]), t(T, [2, 74]), t(T, [2, 75]), t(T, [2, 76]), t(V, [2, 41], { 53: $, 54: K, 55: q }), t(T, [2, 44]), t(T, [2, 50]), { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 108, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 110, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 111, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 6: 6, 7: i2, 8: s, 9: 20, 11: 4, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 27: [1, 112], 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 113, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 114, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 115, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 14: [1, 116] }, t(S, [2, 7]), t(S, [2, 8]), t(S, [2, 9]), { 16: [1, 117] }, t(S, [2, 22]), { 8: s, 20: l, 29: 118, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 119, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 29: 120, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 36: 121, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 20: [1, 122] }, { 8: s, 9: 123, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(T, [2, 87], { 89: 124, 90: 125, 68: 127, 20: Q, 82: E }), { 8: s, 10: [1, 128], 20: l, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 81: 129, 82: E, 91: O, 93: x }, t(T, [2, 89]), { 8: s, 9: 130, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 20: [1, 131] }, { 8: s, 20: l, 31: 109, 38: 132, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 40: 133, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 40: 134, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 40: 135, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 10: [1, 136] }, { 10: [1, 137], 20: tt, 92: 138 }, { 10: [1, 140], 20: tt, 92: 141 }, { 8: s, 20: l, 31: 109, 44: 142, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 44: 143, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 44: 144, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 44: 145, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(T, [2, 79]), { 83: [1, 146], 86: [1, 147] }, t(et, [2, 81]), { 35: [1, 148] }, { 35: [2, 84] }, { 35: [2, 85] }, { 35: [2, 86] }, t(T, [2, 77]), { 66: [1, 149], 86: it }, t(st, [2, 98]), { 8: s, 20: l, 31: 109, 49: 151, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 49: 152, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 153, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 154, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 31: 109, 50: p, 51: _, 52: 155, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(T, [2, 51]), t([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], M, { 57: N }), t(T, [2, 52]), t(T, [2, 53]), t([5, 7, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 58, 64, 65, 66, 74, 75, 76, 77, 78, 79, 80, 82, 83, 86, 91, 93], [2, 12]), { 10: [1, 156] }, { 10: [1, 157] }, { 16: [1, 158] }, { 8: [1, 159] }, t(S, [2, 10]), t(T, [2, 25]), t(T, [2, 49]), { 35: [1, 160] }, t(R, [2, 29], { 39: D }), t(T, [2, 59]), { 66: [1, 161] }, t([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83], [2, 88], { 86: [1, 162] }), t(T, [2, 94]), t(T, [2, 96]), t(T, [2, 97]), t(rt, [2, 92]), { 10: [1, 163], 86: it }, { 66: [1, 164] }, t(T, [2, 91]), t(L, [2, 31], { 41: B, 42: I, 43: Y }), t(j, [2, 33], { 45: X, 46: U, 47: F, 48: J }), t(j, [2, 34], { 45: X, 46: U, 47: F, 48: J }), t(j, [2, 35], { 45: X, 46: U, 47: F, 48: J }), t(T, [2, 65]), { 25: 165, 26: u }, { 10: [1, 166], 86: ot }, t(nt, [2, 104]), { 94: [1, 168] }, { 10: [1, 169], 86: ot }, t(z, [2, 37], { 50: H, 51: W }), t(z, [2, 38], { 50: H, 51: W }), t(z, [2, 39], { 50: H, 51: W }), t(z, [2, 40], { 50: H, 51: W }), t(T, [2, 80]), { 20: G, 72: 98, 73: 99, 77: Z, 78: C, 79: y, 80: P, 85: 170, 87: 96 }, { 8: s, 20: l, 29: 171, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(T, [2, 78]), { 8: s, 20: l, 29: 172, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(V, [2, 42], { 53: $, 54: K, 55: q }), t(V, [2, 43], { 53: $, 54: K, 55: q }), t(T, [2, 45]), t(T, [2, 46]), t(T, [2, 47]), { 6: 6, 7: i2, 8: s, 9: 20, 11: 173, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 6: 6, 7: i2, 8: s, 9: 20, 11: 174, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 175, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 176, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 20: l, 29: 177, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(T, [2, 60]), { 20: Q, 68: 127, 82: E, 90: 178 }, t(rt, [2, 93]), t(T, [2, 90]), t(T, [2, 100]), { 25: 179, 26: u }, { 20: [1, 180] }, { 8: s, 9: 181, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 94: [1, 182] }, t(et, [2, 82]), t(et, [2, 83]), t(st, [2, 99]), t(w, [2, 2], { 12: [1, 183] }), t(S, [2, 4]), { 16: [1, 184] }, { 10: [1, 185] }, t(T, [2, 27]), t(T, [2, 95]), t(T, [2, 101]), t(nt, [2, 105]), t(T, [2, 102]), { 8: s, 9: 186, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 6: 6, 7: i2, 8: s, 9: 20, 11: 187, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 8: s, 9: 188, 20: l, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, { 16: [1, 189] }, t(T, [2, 103]), t(S, [2, 3]), { 10: [1, 190] }, t(S, [2, 6]), { 6: 6, 7: i2, 8: s, 9: 20, 11: 191, 13: 7, 14: r2, 15: o, 16: n, 17: a, 18: 8, 19: h, 20: l, 21: c, 22: 9, 23: d, 24: 11, 25: 5, 26: u, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: p, 51: _, 52: 56, 56: 57, 58: f, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: g, 75: m, 76: v, 77: Z, 78: C, 79: y, 80: P, 82: E, 91: O, 93: x }, t(S, [2, 5])], defaultActions: { 3: [2, 1], 97: [2, 84], 98: [2, 85], 99: [2, 86] }, parseError: function(t2, e2) {
      if (!e2.recoverable) {
        var i3 = new Error(t2);
        throw i3.hash = e2, i3;
      }
      this.trace(t2);
    }, parse: function(t2) {
      var e2 = this, i3 = [0], s2 = [null], r3 = [], o2 = this.table, n2 = "", a2 = 0, h2 = 0, l2 = 0, c2 = 2, d2 = 1, u2 = r3.slice.call(arguments, 1), p2 = Object.create(this.lexer), _2 = { yy: {} };
      for (var f2 in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, f2) && (_2.yy[f2] = this.yy[f2]);
      p2.setInput(t2, _2.yy), _2.yy.lexer = p2, _2.yy.parser = this, void 0 === p2.yylloc && (p2.yylloc = {});
      var b2 = p2.yylloc;
      r3.push(b2);
      var g2 = p2.options && p2.options.ranges;
      "function" == typeof _2.yy.parseError ? this.parseError = _2.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      for (var m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2 = function() {
        var t3;
        return "number" != typeof (t3 = p2.lex() || d2) && (t3 = e2.symbols_[t3] || t3), t3;
      }, S2 = {}; ; ) {
        if (Z2 = i3[i3.length - 1], this.defaultActions[Z2] ? C2 = this.defaultActions[Z2] : (null == m2 && (m2 = w2()), C2 = o2[Z2] && o2[Z2][m2]), void 0 === C2 || !C2.length || !C2[0]) {
          var T2 = "";
          for (P2 in x2 = [], o2[Z2])
            this.terminals_[P2] && P2 > c2 && x2.push("'" + this.terminals_[P2] + "'");
          T2 = p2.showPosition ? "Parse error on line " + (a2 + 1) + ":\n" + p2.showPosition() + "\nExpecting " + x2.join(", ") + ", got '" + (this.terminals_[m2] || m2) + "'" : "Parse error on line " + (a2 + 1) + ": Unexpected " + (m2 == d2 ? "end of input" : "'" + (this.terminals_[m2] || m2) + "'"), this.parseError(T2, { text: p2.match, token: this.terminals_[m2] || m2, line: p2.yylineno, loc: b2, expected: x2 });
        }
        if (C2[0] instanceof Array && C2.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Z2 + ", token: " + m2);
        switch (C2[0]) {
          case 1:
            i3.push(m2), s2.push(p2.yytext), r3.push(p2.yylloc), i3.push(C2[1]), m2 = null, v2 ? (m2 = v2, v2 = null) : (h2 = p2.yyleng, n2 = p2.yytext, a2 = p2.yylineno, b2 = p2.yylloc, l2 > 0);
            break;
          case 2:
            if (E2 = this.productions_[C2[1]][1], S2.$ = s2[s2.length - E2], S2._$ = { first_line: r3[r3.length - (E2 || 1)].first_line, last_line: r3[r3.length - 1].last_line, first_column: r3[r3.length - (E2 || 1)].first_column, last_column: r3[r3.length - 1].last_column }, g2 && (S2._$.range = [r3[r3.length - (E2 || 1)].range[0], r3[r3.length - 1].range[1]]), void 0 !== (y2 = this.performAction.apply(S2, [n2, h2, a2, _2.yy, C2[1], s2, r3].concat(u2))))
              return y2;
            E2 && (i3 = i3.slice(0, -1 * E2 * 2), s2 = s2.slice(0, -1 * E2), r3 = r3.slice(0, -1 * E2)), i3.push(this.productions_[C2[1]][0]), s2.push(S2.$), r3.push(S2._$), O2 = o2[i3[i3.length - 2]][i3[i3.length - 1]], i3.push(O2);
            break;
          case 3:
            return true;
        }
      }
      return true;
    } }, ht = { node: function(t2, e2, i3) {
      return { type: t2, value: e2, children: i3 };
    }, createNode: function(t2, e2, i3, s2) {
      var r3, o2 = this.node(e2, i3, []);
      for (r3 = 3; r3 < arguments.length; r3++)
        o2.children.push(arguments[r3]);
      return o2.line = t2[0], o2.col = t2[1], o2.eline = t2[2], o2.ecol = t2[3], o2;
    } }, lt = function(t2) {
      return [t2.first_line, t2.first_column, t2.last_line, t2.last_column];
    }, ct = function() {
      var t2 = { EOF: 1, parseError: function(t3, e2) {
        if (!this.yy.parser)
          throw new Error(t3);
        this.yy.parser.parseError(t3, e2);
      }, setInput: function(t3, e2) {
        return this.yy = e2 || this.yy || {}, this._input = t3, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, input: function() {
        var t3 = this._input[0];
        return this.yytext += t3, this.yyleng++, this.offset++, this.match += t3, this.matched += t3, t3.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t3;
      }, unput: function(t3) {
        var e2 = t3.length, i3 = t3.split(/(?:\r\n?|\n)/g);
        this._input = t3 + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - e2), this.offset -= e2;
        var s2 = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), i3.length - 1 && (this.yylineno -= i3.length - 1);
        var r3 = this.yylloc.range;
        return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: i3 ? (i3.length === s2.length ? this.yylloc.first_column : 0) + s2[s2.length - i3.length].length - i3[0].length : this.yylloc.first_column - e2 }, this.options.ranges && (this.yylloc.range = [r3[0], r3[0] + this.yyleng - e2]), this.yyleng = this.yytext.length, this;
      }, more: function() {
        return this._more = true, this;
      }, reject: function() {
        return this.options.backtrack_lexer ? (this._backtrack = true, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
      }, less: function(t3) {
        this.unput(this.match.slice(t3));
      }, pastInput: function() {
        var t3 = this.matched.substr(0, this.matched.length - this.match.length);
        return (t3.length > 20 ? "..." : "") + t3.substr(-20).replace(/\n/g, "");
      }, upcomingInput: function() {
        var t3 = this.match;
        return t3.length < 20 && (t3 += this._input.substr(0, 20 - t3.length)), (t3.substr(0, 20) + (t3.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, showPosition: function() {
        var t3 = this.pastInput(), e2 = new Array(t3.length + 1).join("-");
        return t3 + this.upcomingInput() + "\n" + e2 + "^";
      }, test_match: function(t3, e2) {
        var i3, s2, r3;
        if (this.options.backtrack_lexer && (r3 = { yylineno: this.yylineno, yylloc: { first_line: this.yylloc.first_line, last_line: this.last_line, first_column: this.yylloc.first_column, last_column: this.yylloc.last_column }, yytext: this.yytext, match: this.match, matches: this.matches, matched: this.matched, yyleng: this.yyleng, offset: this.offset, _more: this._more, _input: this._input, yy: this.yy, conditionStack: this.conditionStack.slice(0), done: this.done }, this.options.ranges && (r3.yylloc.range = this.yylloc.range.slice(0))), (s2 = t3[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += s2.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: s2 ? s2[s2.length - 1].length - s2[s2.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t3[0].length }, this.yytext += t3[0], this.match += t3[0], this.matches = t3, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = false, this._backtrack = false, this._input = this._input.slice(t3[0].length), this.matched += t3[0], i3 = this.performAction.call(this, this.yy, this, e2, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), i3)
          return i3;
        if (this._backtrack) {
          for (var o2 in r3)
            this[o2] = r3[o2];
          return false;
        }
        return false;
      }, next: function() {
        if (this.done)
          return this.EOF;
        var t3, e2, i3, s2;
        this._input || (this.done = true), this._more || (this.yytext = "", this.match = "");
        for (var r3 = this._currentRules(), o2 = 0; o2 < r3.length; o2++)
          if ((i3 = this._input.match(this.rules[r3[o2]])) && (!e2 || i3[0].length > e2[0].length)) {
            if (e2 = i3, s2 = o2, this.options.backtrack_lexer) {
              if (false !== (t3 = this.test_match(i3, r3[o2])))
                return t3;
              if (this._backtrack) {
                e2 = false;
                continue;
              }
              return false;
            }
            if (!this.options.flex)
              break;
          }
        return e2 ? false !== (t3 = this.test_match(e2, r3[s2])) && t3 : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
      }, lex: function() {
        var t3 = this.next();
        return t3 || this.lex();
      }, begin: function(t3) {
        this.conditionStack.push(t3);
      }, popState: function() {
        return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, topState: function(t3) {
        return (t3 = this.conditionStack.length - 1 - Math.abs(t3 || 0)) >= 0 ? this.conditionStack[t3] : "INITIAL";
      }, pushState: function(t3) {
        this.begin(t3);
      }, stateStackSize: function() {
        return this.conditionStack.length;
      }, options: {}, performAction: function(t3, e2, i3, s2) {
        switch (i3) {
          case 0:
          case 5:
          case 6:
            break;
          case 1:
          case 2:
            return 78;
          case 3:
          case 4:
            return 77;
          case 7:
            return 7;
          case 8:
            return 12;
          case 9:
            return 14;
          case 10:
            return 17;
          case 11:
            return 15;
          case 12:
            return 91;
          case 13:
            return 93;
          case 14:
            return 19;
          case 15:
            return 23;
          case 16:
            return 21;
          case 17:
            return 75;
          case 18:
            return 76;
          case 19:
            return 74;
          case 20:
            return 80;
          case 21:
          case 22:
            return 94;
          case 23:
            return 82;
          case 24:
            return 83;
          case 25:
            return 26;
          case 26:
            return 27;
          case 27:
            return 16;
          case 28:
            return "#";
          case 29:
            return 34;
          case 30:
            return 35;
          case 31:
            return 79;
          case 32:
            return 64;
          case 33:
            return 65;
          case 34:
            return 66;
          case 35:
            return 8;
          case 36:
            return 10;
          case 37:
            return 58;
          case 38:
            return 57;
          case 39:
            return 53;
          case 40:
            return 54;
          case 41:
            return 55;
          case 42:
            return 50;
          case 43:
            return 51;
          case 44:
            return 47;
          case 45:
            return 45;
          case 46:
            return 48;
          case 47:
            return 46;
          case 48:
            return 41;
          case 49:
            return 43;
          case 50:
            return 42;
          case 51:
            return 39;
          case 52:
            return 37;
          case 53:
            return 32;
          case 54:
            return 86;
          case 55:
            return 5;
          case 56:
            return 20;
          case 57:
            return "INVALID";
        }
      }, rules: [/^(?:\s+)/, /^(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+\b)/, /^(?:[0-9]+)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:\/\/.*)/, /^(?:\/\*(.|\n|\r)*?\*\/)/, /^(?:if\b)/, /^(?:else\b)/, /^(?:while\b)/, /^(?:do\b)/, /^(?:for\b)/, /^(?:function\b)/, /^(?:map\b)/, /^(?:use\b)/, /^(?:return\b)/, /^(?:delete\b)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:Infinity\b)/, /^(?:->)/, /^(?:=>)/, /^(?:<<)/, /^(?:>>)/, /^(?:\{)/, /^(?:\})/, /^(?:;)/, /^(?:#)/, /^(?:\?)/, /^(?::)/, /^(?:NaN\b)/, /^(?:\.)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:!)/, /^(?:\^)/, /^(?:\*)/, /^(?:\/)/, /^(?:%)/, /^(?:\+)/, /^(?:-)/, /^(?:<=)/, /^(?:<)/, /^(?:>=)/, /^(?:>)/, /^(?:==)/, /^(?:~=)/, /^(?:!=)/, /^(?:&&)/, /^(?:\|\|)/, /^(?:=)/, /^(?:,)/, /^(?:$)/, /^(?:[A-Za-z_\$][A-Za-z0-9_]*)/, /^(?:.)/], conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57], inclusive: true } } };
      return t2;
    }();
    function dt() {
      this.yy = {};
    }
    return at.lexer = ct, dt.prototype = at, at.Parser = dt, new dt();
  }();
  parser.yy.parseError = parser.parseError;
  const __WEBPACK_DEFAULT_EXPORT__ = _jxg__WEBPACK_IMPORTED_MODULE_0__.Z.JessieCode;
}, 327: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(109), o = i2(275), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }, a = [{ re: /^\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d.]{1,3})\s*\)\s*$/, example: ["rgba(123, 234, 45, 0.5)", "rgba(255,234,245,1.0)"], process: function(t2) {
    return [parseInt(t2[1], 10), parseInt(t2[2], 10), parseInt(t2[3], 10)];
  } }, { re: /^\s*rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t2) {
    return [parseInt(t2[1], 10), parseInt(t2[2], 10), parseInt(t2[3], 10)];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t2) {
    return [parseInt(t2[1], 16), parseInt(t2[2], 16), parseInt(t2[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t2) {
    return [parseInt(t2[1] + t2[1], 16), parseInt(t2[2] + t2[2], 16), parseInt(t2[3] + t2[3], 16)];
  } }];
  s.Z.rgbParser = function(t2, e2, i3) {
    var s2, o2, h2, l, c, d, u, p, _, f, b = t2;
    if (!r2.Z.exists(t2))
      return [];
    if (r2.Z.exists(e2) && r2.Z.exists(i3) && (b = [t2, e2, i3]), s2 = b, f = false, r2.Z.isArray(s2)) {
      for (d = 0; d < 3; d++)
        f = f || /\./.test(b[d].toString());
      for (d = 0; d < 3; d++)
        f = f && b[d] >= 0 && b[d] <= 1;
      return f ? [Math.ceil(255 * b[0]), Math.ceil(255 * b[1]), Math.ceil(255 * b[2])] : b;
    }
    for ("string" == typeof b && (s2 = b), "#" === s2.charAt(0) && (s2 = s2.substr(1, 6)), s2 = s2.replace(/ /g, "").toLowerCase(), s2 = n[s2] || s2, d = 0; d < a.length; d++)
      h2 = a[d].re, l = a[d].process, (c = h2.exec(s2)) && (u = (o2 = l(c))[0], p = o2[1], _ = o2[2]);
    return isNaN(u) || isNaN(p) || isNaN(_) ? [] : [u = u < 0 || isNaN(u) ? 0 : u > 255 ? 255 : u, p = p < 0 || isNaN(p) ? 0 : p > 255 ? 255 : p, _ = _ < 0 || isNaN(_) ? 0 : _ > 255 ? 255 : _];
  }, s.Z.rgb2css = function(t2, e2, i3) {
    var r3;
    return "rgb(" + (r3 = s.Z.rgbParser(t2, e2, i3))[0] + ", " + r3[1] + ", " + r3[2] + ")";
  }, s.Z.rgb2hex = function(t2, e2, i3) {
    var r3, o2, n2;
    return o2 = (r3 = s.Z.rgbParser(t2, e2, i3))[1], n2 = r3[2], r3 = (r3 = r3[0]).toString(16), o2 = o2.toString(16), n2 = n2.toString(16), 1 === r3.length && (r3 = "0" + r3), 1 === o2.length && (o2 = "0" + o2), 1 === n2.length && (n2 = "0" + n2), "#" + r3 + o2 + n2;
  }, s.Z.hex2rgb = function(t2) {
    return s.Z.deprecated("JXG.hex2rgb()", "JXG.rgb2css()"), s.Z.rgb2css(t2);
  }, s.Z.hsv2rgb = function(t2, e2, i3) {
    var s2, r3, n2, a2, h2, l, c, d, u;
    if (t2 = (t2 % 360 + 360) % 360, 0 === e2) {
      if (!(isNaN(t2) || t2 < o.Z.eps))
        return "#ffffff";
      s2 = i3, r3 = i3, n2 = i3;
    } else
      switch (l = t2 >= 360 ? 0 : t2, c = i3 * (1 - e2), d = i3 * (1 - e2 * (a2 = (l /= 60) - (h2 = Math.floor(l)))), u = i3 * (1 - e2 * (1 - a2)), h2) {
        case 0:
          s2 = i3, r3 = u, n2 = c;
          break;
        case 1:
          s2 = d, r3 = i3, n2 = c;
          break;
        case 2:
          s2 = c, r3 = i3, n2 = u;
          break;
        case 3:
          s2 = c, r3 = d, n2 = i3;
          break;
        case 4:
          s2 = u, r3 = c, n2 = i3;
          break;
        case 5:
          s2 = i3, r3 = c, n2 = d;
      }
    return ["#", s2 = 2 === (s2 = Math.round(255 * s2).toString(16)).length ? s2 : 1 === s2.length ? "0" + s2 : "00", r3 = 2 === (r3 = Math.round(255 * r3).toString(16)).length ? r3 : 1 === r3.length ? "0" + r3 : "00", n2 = 2 === (n2 = Math.round(255 * n2).toString(16)).length ? n2 : 1 === n2.length ? "0" + n2 : "00"].join("");
  }, s.Z.rgb2hsv = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l, c, d, u, p, _, f, b;
    return o2 = (r3 = s.Z.rgbParser(t2, e2, i3))[1], n2 = r3[2], a2 = (r3 = r3[0]) / 255, h2 = o2 / 255, l = n2 / 255, f = Math.max(r3, o2, n2), d = (b = Math.min(r3, o2, n2)) / 255, p = 0, (_ = c = f / 255) > 0 && (p = (_ - d) / _), u = 1 / (c - d), p > 0 && (f === r3 ? u *= h2 - l : u = f === o2 ? 2 + (l - a2) * u : 4 + (a2 - h2) * u), (u *= 60) < 0 && (u += 360), f === b && (u = 0), [u, p, _];
  }, s.Z.rgb2LMS = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l, c, d = [[0.05059983, 0.08585369, 95242e-7], [0.01893033, 0.08925308, 0.01370054], [292202e-8, 975732e-8, 0.07145979]];
    return o2 = (r3 = s.Z.rgbParser(t2, e2, i3))[1], n2 = r3[2], r3 = r3[0], r3 = Math.pow(r3, 0.476190476), o2 = Math.pow(o2, 0.476190476), n2 = Math.pow(n2, 0.476190476), (c = [a2 = r3 * d[0][0] + o2 * d[0][1] + n2 * d[0][2], h2 = r3 * d[1][0] + o2 * d[1][1] + n2 * d[1][2], l = r3 * d[2][0] + o2 * d[2][1] + n2 * d[2][2]]).l = a2, c.m = h2, c.s = l, c;
  }, s.Z.LMS2rgb = function(t2, e2, i3) {
    var s2, r3, o2, n2, a2 = [[30.830854, -29.832659, 1.610474], [-6.481468, 17.715578, -2.532642], [-0.37569, -1.199062, 14.273846]], h2 = function(t3) {
      for (var e3 = 127, i4 = 64; i4 > 0; ) {
        if (Math.pow(e3, 0.476190476) > t3)
          e3 -= i4;
        else {
          if (Math.pow(e3 + 1, 0.476190476) > t3)
            return e3;
          e3 += i4;
        }
        i4 /= 2;
      }
      return 254 === e3 && 13.994955247 < t3 ? 255 : e3;
    };
    return s2 = t2 * a2[0][0] + e2 * a2[0][1] + i3 * a2[0][2], r3 = t2 * a2[1][0] + e2 * a2[1][1] + i3 * a2[1][2], o2 = t2 * a2[2][0] + e2 * a2[2][1] + i3 * a2[2][2], (n2 = [s2 = h2(s2), r3 = h2(r3), o2 = h2(o2)]).r = s2, n2.g = r3, n2.b = o2, n2;
  }, s.Z.rgba2rgbo = function(t2) {
    var e2;
    return 9 === t2.length && "#" === t2.charAt(0) ? (e2 = parseInt(t2.substr(7, 2).toUpperCase(), 16) / 255, t2 = t2.substr(0, 7)) : e2 = 1, [t2, e2];
  }, s.Z.rgbo2rgba = function(t2, e2) {
    var i3;
    return "none" === t2 ? t2 : (1 === (i3 = Math.round(255 * e2).toString(16)).length && (i3 = "0" + i3), t2 + i3);
  }, s.Z.rgb2bw = function(t2) {
    var e2, i3, r3, o2 = "0123456789ABCDEF";
    return "none" === t2 ? t2 : (r3 = s.Z.rgbParser(t2), e2 = Math.floor(0.3 * r3[0] + 0.59 * r3[1] + 0.11 * r3[2]), t2 = "#" + (i3 = o2.charAt(e2 >> 4 & 15) + o2.charAt(15 & e2)) + i3 + i3);
  }, s.Z.rgb2cb = function(t2, e2) {
    var i3, r3, o2, n2, a2, h2, l, c, d, u, p, _ = "0123456789ABCDEF";
    if ("none" === t2)
      return t2;
    switch (r3 = (a2 = s.Z.rgb2LMS(t2))[0], o2 = a2[1], n2 = a2[2], e2 = e2.toLowerCase()) {
      case "protanopia":
        h2 = -0.06150039994295001, l = 0.08277001656812001, c = -0.013200141220000003, d = 0.05858939668799999, u = -0.07934519995360001, p = 0.013289415272000003, r3 = n2 / o2 < 0.6903216543277437 ? -(l * o2 + c * n2) / h2 : -(u * o2 + p * n2) / d;
        break;
      case "tritanopia":
        h2 = -58973116217e-14, l = 0.007690316482, c = -0.01011703519052, d = 0.025495080838999994, u = -0.0422740347, p = 0.017005316784, n2 = o2 / r3 < 0.8349489908460004 ? -(h2 * r3 + l * o2) / c : -(d * r3 + u * o2) / p;
        break;
      default:
        h2 = -0.06150039994295001, l = 0.08277001656812001, c = -0.013200141220000003, d = 0.05858939668799999, u = -0.07934519995360001, p = 0.013289415272000003, o2 = n2 / r3 < 0.5763833686400911 ? -(h2 * r3 + c * n2) / l : -(d * r3 + p * n2) / u;
    }
    return i3 = s.Z.LMS2rgb(r3, o2, n2), t2 = "#" + (_.charAt(i3[0] >> 4 & 15) + _.charAt(15 & i3[0])), t2 += _.charAt(i3[1] >> 4 & 15) + _.charAt(15 & i3[1]), t2 += _.charAt(i3[2] >> 4 & 15) + _.charAt(15 & i3[2]);
  }, s.Z.autoHighlight = function(t2) {
    var e2 = s.Z.rgba2rgbo(t2), i3 = e2[0], r3 = e2[1];
    return "#" === t2.charAt(0) ? (r3 *= r3 < 0.3 ? 1.8 : 0.4, s.Z.rgbo2rgba(i3, r3)) : t2;
  }, s.Z.contrast = function(t2, e2, i3, r3) {
    var o2, n2, a2, h2, l;
    return e2 = e2 || "#000000", i3 = i3 || "#ffffff", r3 = r3 || 7, o2 = s.Z.rgbParser(t2), n2 = s.Z.rgbParser("#000000"), l = (a2 = 0.2126 * Math.pow(o2[0] / 255, 2.2) + 0.7152 * Math.pow(o2[1] / 255, 2.2) + 0.0722 * Math.pow(o2[2] / 255, 2.2)) > (h2 = 0.2126 * Math.pow(n2[0] / 255, 2.2) + 0.7152 * Math.pow(n2[1] / 255, 2.2) + 0.0722 * Math.pow(n2[2] / 255, 2.2)) ? Math.floor((a2 + 0.05) / (h2 + 0.05)) : Math.floor((h2 + 0.05) / (a2 + 0.05)), (l -= 1) > r3 ? e2 : i3;
  }, s.Z.setClassicColors = function() {
    s.Z.Options.elements.strokeColor = "blue", s.Z.Options.elements.fillColor = "red", s.Z.Options.hatch.strokeColor = "blue", s.Z.Options.angle.fillColor = "#ff7f00", s.Z.Options.angle.highlightFillColor = "#ff7f00", s.Z.Options.angle.strokeColor = "#ff7f00", s.Z.Options.angle.label.strokeColor = "blue", s.Z.Options.arc.strokeColor = "blue", s.Z.Options.circle.center.fillColor = "red", s.Z.Options.circle.center.strokeColor = "blue", s.Z.Options.circumcircle.strokeColor = "blue", s.Z.Options.circumcircle.center.fillColor = "red", s.Z.Options.circumcircle.center.strokeColor = "blue", s.Z.Options.circumcirclearc.strokeColor = "blue", s.Z.Options.circumcirclesector.strokeColor = "blue", s.Z.Options.circumcirclesector.fillColor = "green", s.Z.Options.circumcirclesector.highlightFillColor = "green", s.Z.Options.conic.strokeColor = "blue", s.Z.Options.curve.strokeColor = "blue", s.Z.Options.incircle.strokeColor = "blue", s.Z.Options.incircle.center.fillColor = "red", s.Z.Options.incircle.center.strokeColor = "blue", s.Z.Options.inequality.fillColor = "red", s.Z.Options.integral.fillColor = "red", s.Z.Options.integral.curveLeft.color = "red", s.Z.Options.integral.curveRight.color = "red", s.Z.Options.line.strokeColor = "blue", s.Z.Options.point.fillColor = "red", s.Z.Options.point.strokeColor = "red", s.Z.Options.polygon.fillColor = "green", s.Z.Options.polygon.highlightFillColor = "green", s.Z.Options.polygon.vertices.strokeColor = "red", s.Z.Options.polygon.vertices.fillColor = "red", s.Z.Options.regularpolygon.fillColor = "green", s.Z.Options.regularpolygon.highlightFillColor = "green", s.Z.Options.regularpolygon.vertices.strokeColor = "red", s.Z.Options.regularpolygon.vertices.fillColor = "red", s.Z.Options.riemannsum.fillColor = "yellow", s.Z.Options.sector.fillColor = "green", s.Z.Options.sector.highlightFillColor = "green", s.Z.Options.semicircle.center.fillColor = "red", s.Z.Options.semicircle.center.strokeColor = "blue", s.Z.Options.slopetriangle.fillColor = "red", s.Z.Options.slopetriangle.highlightFillColor = "red", s.Z.Options.turtle.arrow.strokeColor = "blue";
  }, s.Z.extend(s.Z, { paletteWong: { black: "#000000", orange: "#E69F00", skyblue: "#56B4E9", bluishgreen: "#009E73", yellow: "#F0E442", darkblue: "#0072B2", vermillion: "#D55E00", reddishpurple: "#CC79A7", blue: "#0072B2", red: "#D55E00", green: "#009E73", purple: "#CC79A7", white: "#ffffff" } }), s.Z.palette = s.Z.paletteWong;
  const h = s.Z;
}, 503: (t, e, i2) => {
  i2.d(e, { Z: () => o });
  var s = i2(765), r2 = i2(109);
  s.Z.extendConstants(s.Z, { touchProperty: "touches" }), s.Z.extend(s.Z, { isTouchEvent: function(t2) {
    return s.Z.exists(t2[s.Z.touchProperty]);
  }, isPointerEvent: function(t2) {
    return s.Z.exists(t2.pointerId);
  }, isMouseEvent: function(t2) {
    return !s.Z.isTouchEvent(t2) && !s.Z.isPointerEvent(t2);
  }, getNumberOfTouchPoints: function(t2) {
    var e2 = -1;
    return s.Z.isTouchEvent(t2) && (e2 = t2[s.Z.touchProperty].length), e2;
  }, isFirstTouch: function(t2) {
    var e2 = s.Z.getNumberOfTouchPoints(t2);
    return s.Z.isPointerEvent(t2) ? t2.isPrimary : 1 === e2;
  }, isBrowser: "object" == typeof window && "object" == typeof document, supportsES6: function() {
    try {
      return new Function("(a = 0) => a"), true;
    } catch (t2) {
      return false;
    }
  }, supportsVML: function() {
    return this.isBrowser && !!document.namespaces;
  }, supportsSVG: function() {
    return !!this.isBrowser && (!!document.createElementNS && !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect);
  }, supportsCanvas: function() {
    var t2 = false;
    return this.isNode() && (t2 = true), t2 || this.isBrowser && !!document.createElement("canvas").getContext;
  }, isNode: function() {
    return !this.isBrowser && "undefined" != typeof process && -1 !== process.release.name.search(/node|io.js/);
  }, isWebWorker: function() {
    return !this.isBrowser && "object" == typeof self && "function" == typeof self.postMessage;
  }, supportsPointerEvents: function() {
    return !!(this.isBrowser && window.navigator && (window.PointerEvent || window.navigator.pointerEnabled || window.navigator.msPointerEnabled));
  }, isTouchDevice: function() {
    return this.isBrowser && void 0 !== window.ontouchstart;
  }, isAndroid: function() {
    return r2.Z.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("android") > -1;
  }, isWebkitAndroid: function() {
    return this.isAndroid() && navigator.userAgent.indexOf(" AppleWebKit/") > -1;
  }, isApple: function() {
    return r2.Z.exists(navigator) && (navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("iPhone") > -1);
  }, isWebkitApple: function() {
    return this.isApple() && navigator.userAgent.search(/Mobile\/[0-9A-Za-z.]*Safari/) > -1;
  }, isMetroApp: function() {
    return "object" == typeof window && window.clientInformation && window.clientInformation.appVersion && window.clientInformation.appVersion.indexOf("MSAppHost") > -1;
  }, isMozilla: function() {
    return r2.Z.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1 && -1 === navigator.userAgent.toLowerCase().indexOf("apple");
  }, isFirefoxOS: function() {
    return r2.Z.exists(navigator) && -1 === navigator.userAgent.toLowerCase().indexOf("android") && -1 === navigator.userAgent.toLowerCase().indexOf("apple") && navigator.userAgent.toLowerCase().indexOf("mobile") > -1 && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1;
  }, ieVersion: function() {
    var t2, e2, i3 = 3;
    if ("object" != typeof document)
      return 0;
    e2 = (t2 = document.createElement("div")).getElementsByTagName("i");
    do {
      t2.innerHTML = "<!--[if gt IE " + ++i3 + "]><i></i><![endif]-->";
    } while (e2[0]);
    return i3 > 4 ? i3 : void 0;
  }(), getDimensions: function(t2, e2) {
    var i3, s2, o2, n, a, h, l, c, d, u = /\d+(\.\d*)?px/;
    if (!this.isBrowser || null === t2)
      return { width: 500, height: 500 };
    if (i3 = (e2 = e2 || document).getElementById(t2), !r2.Z.exists(i3))
      throw new Error("\nJSXGraph: HTML container element '" + t2 + "' not found.");
    return "none" !== (s2 = i3.style.display) && null !== s2 ? i3.clientWidth > 0 && i3.clientHeight > 0 ? { width: i3.clientWidth, height: i3.clientHeight } : (d = window.getComputedStyle ? window.getComputedStyle(i3) : i3.style, { width: u.test(d.width) ? parseFloat(d.width) : 0, height: u.test(d.height) ? parseFloat(d.height) : 0 }) : (n = (o2 = i3.style).visibility, a = o2.position, h = o2.display, o2.visibility = "hidden", o2.position = "absolute", o2.display = "block", l = i3.clientWidth, c = i3.clientHeight, o2.display = h, o2.position = a, o2.visibility = n, { width: l, height: c });
  }, addEvent: function(t2, e2, i3, s2, o2) {
    var n = function() {
      return i3.apply(s2, arguments);
    };
    n.origin = i3, "object" == typeof s2 && r2.Z.exists(s2.BOARD_MODE_NONE) && (s2["x_internal" + e2] = s2["x_internal" + e2] || [], s2["x_internal" + e2].push(n)), r2.Z.exists(t2) && r2.Z.exists(t2.addEventListener) && (o2 = o2 || false, t2.addEventListener(e2, n, o2)), r2.Z.exists(t2) && r2.Z.exists(t2.attachEvent) && t2.attachEvent("on" + e2, n);
  }, removeEvent: function(t2, e2, i3, o2) {
    var n;
    if (r2.Z.exists(o2))
      if (r2.Z.exists(o2["x_internal" + e2]))
        if (r2.Z.isArray(o2["x_internal" + e2]))
          if (-1 !== (n = r2.Z.indexOf(o2["x_internal" + e2], i3, "origin"))) {
            try {
              r2.Z.exists(t2) && r2.Z.exists(t2.removeEventListener) && t2.removeEventListener(e2, o2["x_internal" + e2][n], false), r2.Z.exists(t2) && r2.Z.exists(t2.detachEvent) && t2.detachEvent("on" + e2, o2["x_internal" + e2][n]);
            } catch (t3) {
              s.Z.debug("event not registered in browser: (" + e2 + " -- " + i3 + ")");
            }
            o2["x_internal" + e2].splice(n, 1);
          } else
            s.Z.debug("removeEvent: no such event function in internal list: " + i3);
        else
          s.Z.debug("owner[x_internal + " + e2 + "] is not an array");
      else
        s.Z.debug("no such type: " + e2);
    else
      s.Z.debug("no such owner");
  }, removeAllEvents: function(t2, e2, i3) {
    var r3;
    if (i3["x_internal" + e2]) {
      for (r3 = i3["x_internal" + e2].length - 1; r3 >= 0; r3--)
        s.Z.removeEvent(t2, e2, i3["x_internal" + e2][r3].origin, i3);
      i3["x_internal" + e2].length > 0 && s.Z.debug("removeAllEvents: Not all events could be removed.");
    }
  }, getPosition: function(t2, e2, i3) {
    var o2, n, a, h = 0, l = 0;
    if (t2 || (t2 = window.event), a = t2[s.Z.touchProperty], r2.Z.exists(a) && 0 === a.length && (a = t2.changedTouches), r2.Z.exists(e2) && r2.Z.exists(a))
      if (-1 === e2) {
        for (n = a.length, o2 = 0; o2 < n; o2++)
          if (a[o2]) {
            t2 = a[o2];
            break;
          }
      } else
        t2 = a[e2];
    return t2.clientX && (h = t2.clientX, l = t2.clientY), [h, l];
  }, getOffset: function(t2) {
    var e2, i3 = t2, s2 = t2, r3 = i3.offsetLeft - i3.scrollLeft, o2 = i3.offsetTop - i3.scrollTop;
    for (r3 = (e2 = this.getCSSTransform([r3, o2], i3))[0], o2 = e2[1], i3 = i3.offsetParent; i3; ) {
      for (r3 += i3.offsetLeft, o2 += i3.offsetTop, i3.offsetParent && (r3 += i3.clientLeft - i3.scrollLeft, o2 += i3.clientTop - i3.scrollTop), r3 = (e2 = this.getCSSTransform([r3, o2], i3))[0], o2 = e2[1], s2 = s2.parentNode; s2 !== i3; )
        r3 += s2.clientLeft - s2.scrollLeft, o2 += s2.clientTop - s2.scrollTop, r3 = (e2 = this.getCSSTransform([r3, o2], s2))[0], o2 = e2[1], s2 = s2.parentNode;
      i3 = i3.offsetParent;
    }
    return [r3, o2];
  }, getStyle: function(t2, e2) {
    var i3, r3 = t2.ownerDocument;
    return r3.defaultView && r3.defaultView.getComputedStyle ? i3 = r3.defaultView.getComputedStyle(t2, null).getPropertyValue(e2) : t2.currentStyle && s.Z.ieVersion >= 9 ? i3 = t2.currentStyle[e2] : t2.style && (e2 = e2.replace(/-([a-z]|[0-9])/gi, function(t3, e3) {
      return e3.toUpperCase();
    }), i3 = t2.style[e2]), i3;
  }, getProp: function(t2, e2) {
    var i3 = parseInt(this.getStyle(t2, e2), 10);
    return isNaN(i3) ? 0 : i3;
  }, getCSSTransform: function(t2, e2) {
    var i3, s2, o2, n, a, h, l, c = ["transform", "webkitTransform", "MozTransform", "msTransform", "oTransform"];
    for (a = c.length, i3 = 0, o2 = ""; i3 < a; i3++)
      if (r2.Z.exists(e2.style[c[i3]])) {
        o2 = e2.style[c[i3]];
        break;
      }
    if ("" !== o2 && (n = o2.indexOf("(")) > 0) {
      for (a = o2.length, s2 = 0, h = (l = o2.substring(n + 1, a - 1).split(",")).length; s2 < h; s2++)
        l[s2] = parseFloat(l[s2]);
      0 === o2.indexOf("matrix") ? (t2[0] += l[4], t2[1] += l[5]) : 0 === o2.indexOf("translateX") ? t2[0] += l[0] : 0 === o2.indexOf("translateY") ? t2[1] += l[0] : 0 === o2.indexOf("translate") && (t2[0] += l[0], t2[1] += l[1]);
    }
    return r2.Z.exists(e2.style.zoom) && "" !== (o2 = e2.style.zoom) && (t2[0] *= parseFloat(o2), t2[1] *= parseFloat(o2)), t2;
  }, getCSSTransformMatrix: function(t2) {
    var e2, i3, s2, o2, n, a, h, l, c = t2.ownerDocument, d = ["transform", "webkitTransform", "MozTransform", "msTransform", "oTransform"], u = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    if (c.defaultView && c.defaultView.getComputedStyle)
      s2 = (l = c.defaultView.getComputedStyle(t2, null)).getPropertyValue("-webkit-transform") || l.getPropertyValue("-moz-transform") || l.getPropertyValue("-ms-transform") || l.getPropertyValue("-o-transform") || l.getPropertyValue("transform");
    else
      for (n = d.length, e2 = 0, s2 = ""; e2 < n; e2++)
        if (r2.Z.exists(t2.style[d[e2]])) {
          s2 = t2.style[d[e2]];
          break;
        }
    if ("" !== s2 && (o2 = s2.indexOf("(")) > 0) {
      for (n = s2.length, i3 = 0, a = (h = s2.substring(o2 + 1, n - 1).split(",")).length; i3 < a; i3++)
        h[i3] = parseFloat(h[i3]);
      0 === s2.indexOf("matrix") ? u = [[1, 0, 0], [0, h[0], h[1]], [0, h[2], h[3]]] : 0 === s2.indexOf("scaleX") ? u[1][1] = h[0] : 0 === s2.indexOf("scaleY") ? u[2][2] = h[0] : 0 === s2.indexOf("scale") && (u[1][1] = h[0], u[2][2] = h[1]);
    }
    return r2.Z.exists(t2.style.zoom) && "" !== (s2 = t2.style.zoom) && (u[1][1] *= parseFloat(s2), u[2][2] *= parseFloat(s2)), u;
  }, timedChunk: function(t2, e2, i3, s2) {
    var r3 = t2.concat(), o2 = function() {
      var n = +/* @__PURE__ */ new Date();
      do {
        e2.call(i3, r3.shift());
      } while (r3.length > 0 && +/* @__PURE__ */ new Date() - n < 300);
      r3.length > 0 ? window.setTimeout(o2, 1) : s2(t2);
    };
    window.setTimeout(o2, 1);
  }, scaleJSXGraphDiv: function(t2, e2, i3, s2) {
    var r3, o2, n, a, h, l, c, d, u, p, _, f = i3.styleSheets.length, b = s2, g = [":fullscreen", ":-webkit-full-screen", ":-moz-full-screen", ":-ms-fullscreen"], m = g.length, v = new RegExp(".*#" + t2 + ":.*full.*screen.*#" + e2 + ".*auto;.*transform:.*matrix");
    for (a = (h = i3.getElementById(t2).getBoundingClientRect()).height, n = h.width, c = (d = i3.getElementById(e2).getBoundingClientRect()).height, p = "{margin:0 auto;transform:matrix(" + (u = (l = d.width) / c >= n / a ? b * n / l : b * a / c) + ",0,0," + u + ",0," + 0.5 * (a - c) + ");}", 0 === f && ((r3 = document.createElement("style")).appendChild(document.createTextNode("")), i3.appendChild(r3), f = i3.styleSheets.length), i3.styleSheets[f - 1].cssRules.length > 0 && v.test(i3.styleSheets[f - 1].cssRules[0].cssText) && i3.styleSheets[f - 1].deleteRule && i3.styleSheets[f - 1].deleteRule(0), _ = 0; _ < m; _++)
      try {
        o2 = "#" + t2 + g[_] + " #" + e2 + p, i3.styleSheets[f - 1].insertRule(o2, 0);
        break;
      } catch (t3) {
      }
    _ === m && (console.log("JXG.scaleJSXGraphDiv: Could not add any CSS rule."), console.log("One possible reason could be that the id of the JSXGraph container does not start with a letter."));
  } });
  const o = s.Z;
}, 88: (t, e, i2) => {
  i2.d(e, { Z: () => o });
  var s = i2(765), r2 = i2(109);
  s.Z.EventEmitter = { eventHandlers: {}, suspended: {}, trigger: function(t2, e2) {
    var i3, s2, r3, o2, n, a;
    for (n = t2.length, s2 = 0; s2 < n; s2++)
      if (o2 = this.eventHandlers[t2[s2]], !this.suspended[t2[s2]]) {
        if (this.suspended[t2[s2]] = true, o2)
          for (a = o2.length, i3 = 0; i3 < a; i3++)
            (r3 = o2[i3]).handler.apply(r3.context, e2);
        this.suspended[t2[s2]] = false;
      }
    return this;
  }, on: function(t2, e2, i3) {
    return r2.Z.isArray(this.eventHandlers[t2]) || (this.eventHandlers[t2] = []), i3 = r2.Z.def(i3, this), this.eventHandlers[t2].push({ handler: e2, context: i3 }), this;
  }, off: function(t2, e2) {
    var i3;
    return t2 && r2.Z.isArray(this.eventHandlers[t2]) ? (e2 ? ((i3 = r2.Z.indexOf(this.eventHandlers[t2], e2, "handler")) > -1 && this.eventHandlers[t2].splice(i3, 1), 0 === this.eventHandlers[t2].length && delete this.eventHandlers[t2]) : delete this.eventHandlers[t2], this) : this;
  }, eventify: function(t2) {
    t2.eventHandlers = {}, t2.on = this.on, t2.off = this.off, t2.triggerEventHandlers = this.trigger, t2.trigger = this.trigger, t2.suspended = {};
  } };
  const o = s.Z.EventEmitter;
}, 421: (t, e, i2) => {
  i2.d(e, { Z: () => h });
  var s = i2(765), r2 = i2(109), o = i2(351), n = i2(705), a = { each: function(t2, e2, i3) {
    var s2, o2, n2 = [];
    if (r2.Z.exists(t2.length))
      for (o2 = t2.length, s2 = 0; s2 < o2; s2++)
        n2.push(e2.call(this, t2[s2], i3));
    return n2;
  }, coords: function(t2, e2) {
    var i3 = t2;
    return t2 && t2.elementClass === o.Z.OBJECT_CLASS_POINT ? i3 = t2.coords : t2.usrCoords && t2.scrCoords && t2.usr2screen && (i3 = t2), e2 && (i3 = new n.Z(o.Z.COORDS_BY_USER, i3.usrCoords, i3.board)), i3;
  }, coordsArray: function(t2, e2) {
    var i3;
    return (i3 = r2.Z.isArray(t2) ? t2 : this.coords(t2).usrCoords).length < 3 && i3.unshift(1), e2 && (i3 = [i3[0], i3[1], i3[2]]), i3;
  } };
  s.Z.Expect = a;
  const h = a;
}, 109: (t, e, i2) => {
  i2.d(e, { Z: () => o });
  var s = i2(765), r2 = i2(351);
  s.Z.extend(s.Z, { isId: function(t2, e2) {
    return "string" == typeof e2 && !!t2.objects[e2];
  }, isName: function(t2, e2) {
    return "string" == typeof e2 && !!t2.elementsByName[e2];
  }, isGroup: function(t2, e2) {
    return "string" == typeof e2 && !!t2.groups[e2];
  }, isString: function(t2) {
    return "string" == typeof t2;
  }, isNumber: function(t2) {
    return "number" == typeof t2 || "[Object Number]" === Object.prototype.toString.call(t2);
  }, isFunction: function(t2) {
    return "function" == typeof t2;
  }, isArray: function(t2) {
    return Array.isArray ? Array.isArray(t2) : null !== t2 && "object" == typeof t2 && "function" == typeof t2.splice && "function" == typeof t2.join;
  }, isObject: function(t2) {
    return "object" == typeof t2 && !this.isArray(t2);
  }, isDocumentOrFragment: function(t2) {
    return this.isObject(t2) && (9 === t2.nodeType || 11 === t2.nodeType);
  }, isPoint: function(t2) {
    return !(null === t2 || "object" != typeof t2 || !this.exists(t2.elementClass)) && t2.elementClass === r2.Z.OBJECT_CLASS_POINT;
  }, isPoint3D: function(t2) {
    return !(null === t2 || "object" != typeof t2 || !this.exists(t2.elType)) && "point3d" === t2.elType;
  }, isPointType: function(t2, e2) {
    var i3, s2;
    return !!this.isArray(e2) || (!!(this.isFunction(e2) && (i3 = e2(), this.isArray(i3) && i3.length > 1)) || (s2 = t2.select(e2), this.isPoint(s2)));
  }, isTransformationOrArray: function(t2) {
    if (null !== t2) {
      if (this.isArray(t2) && t2.length > 0)
        return this.isTransformationOrArray(t2[0]);
      if ("object" == typeof t2)
        return t2.type === r2.Z.OBJECT_TYPE_TRANSFORMATION;
    }
    return false;
  }, isEmpty: function(t2) {
    return 0 === Object.keys(t2).length;
  }, exists: function(t2, e2) {
    var i3 = !(null == t2 || null === t2);
    return (e2 = e2 || false) ? i3 && "" !== t2 : i3;
  }, def: function(t2, e2) {
    return this.exists(t2) ? t2 : e2;
  }, str2Bool: function(t2) {
    return !this.exists(t2) || ("boolean" == typeof t2 ? t2 : !!this.isString(t2) && "true" === t2.toLowerCase());
  }, createEvalFunction: function(t2, e2, i3) {
    var r3, o2, n, a = [], h = {};
    for (o2 = 0; o2 < i3; o2++)
      for (n in a[o2] = s.Z.createFunction(e2[o2], t2, "", true), a[o2].deps)
        h[n] = a[o2].deps;
    return (r3 = function(t3) {
      return a[t3]();
    }).deps = h, r3;
  }, createFunction: function(t2, e2, i3, s2) {
    var r3 = null;
    return this.exists(s2) && !s2 || !this.isString(t2) ? this.isFunction(t2) ? (r3 = t2).deps = {} : (this.isNumber(t2) || this.isString(t2)) && ((r3 = function() {
      return t2;
    }).deps = {}) : r3 = e2.jc.snippet(t2, true, i3, true), null !== r3 && (r3.origin = t2), r3;
  }, providePoints: function(t2, e2, i3, s2, r3) {
    var o2, n, a, h, l, c = 0, d = [];
    for (this.isArray(e2) || (e2 = [e2]), a = e2.length, this.exists(r3) && (c = r3.length), 0 === c && (h = this.copyAttributes(i3, t2.options, s2)), o2 = 0; o2 < a; ++o2)
      if (c > 0 && (n = Math.min(o2, c - 1), h = this.copyAttributes(i3, t2.options, s2, r3[n])), this.isArray(e2[o2]) && e2[o2].length > 1 ? (d.push(t2.create("point", e2[o2], h)), d[d.length - 1]._is_new = true) : this.isFunction(e2[o2]) ? (l = e2[o2](), this.isArray(l) && l.length > 1 && (d.push(t2.create("point", [e2[o2]], h)), d[d.length - 1]._is_new = true)) : d.push(t2.select(e2[o2])), !this.isPoint(d[o2]))
        return false;
    return d;
  }, providePoints3D: function(t2, e2, i3, s2, r3) {
    var o2, n, a, h, l, c = 0, d = [];
    for (this.isArray(e2) || (e2 = [e2]), a = e2.length, this.exists(r3) && (c = r3.length), 0 === c && (h = this.copyAttributes(i3, t2.board.options, s2)), o2 = 0; o2 < a; ++o2)
      if (c > 0 && (n = Math.min(o2, c - 1), h = this.copyAttributes(i3, t2.board.options, s2, r3[n])), this.isArray(e2[o2]) && e2[o2].length > 1 ? (d.push(t2.create("point3d", e2[o2], h)), d[d.length - 1]._is_new = true) : this.isFunction(e2[o2]) ? (l = e2[o2](), this.isArray(l) && l.length > 1 && (d.push(t2.create("point3d", [e2[o2]], h)), d[d.length - 1]._is_new = true)) : d.push(t2.select(e2[o2])), !this.isPoint3D(d[o2]))
        return false;
    return d;
  }, bind: function(t2, e2) {
    return function() {
      return t2.apply(e2, arguments);
    };
  }, evaluate: function(t2) {
    return this.isFunction(t2) ? t2() : t2;
  }, indexOf: function(t2, e2, i3) {
    var s2, r3 = this.exists(i3);
    if (Array.indexOf && !r3)
      return t2.indexOf(e2);
    for (s2 = 0; s2 < t2.length; s2++)
      if (r3 && t2[s2][i3] === e2 || !r3 && t2[s2] === e2)
        return s2;
    return -1;
  }, eliminateDuplicates: function(t2) {
    var e2, i3 = t2.length, s2 = [], r3 = {};
    for (e2 = 0; e2 < i3; e2++)
      r3[t2[e2]] = 0;
    for (e2 in r3)
      r3.hasOwnProperty(e2) && s2.push(e2);
    return s2;
  }, swap: function(t2, e2, i3) {
    var s2;
    return s2 = t2[e2], t2[e2] = t2[i3], t2[i3] = s2, t2;
  }, uniqueArray: function(t2) {
    var e2, i3, r3, o2 = [];
    if (0 === t2.length)
      return [];
    for (e2 = 0; e2 < t2.length; e2++)
      if (r3 = this.isArray(t2[e2]), this.exists(t2[e2]))
        for (i3 = e2 + 1; i3 < t2.length; i3++)
          r3 && s.Z.cmpArrays(t2[e2], t2[i3]) ? t2[e2] = [] : r3 || t2[e2] !== t2[i3] || (t2[e2] = "");
      else
        t2[e2] = "";
    for (i3 = 0, e2 = 0; e2 < t2.length; e2++)
      (r3 = this.isArray(t2[e2])) || "" === t2[e2] ? r3 && 0 !== t2[e2].length && (o2[i3] = t2[e2].slice(0), i3++) : (o2[i3] = t2[e2], i3++);
    return t2 = o2, o2;
  }, isInArray: function(t2, e2) {
    return s.Z.indexOf(t2, e2) > -1;
  }, coordsArrayToMatrix: function(t2, e2) {
    var i3, s2 = [], r3 = [];
    for (i3 = 0; i3 < t2.length; i3++)
      e2 ? (s2.push(t2[i3].usrCoords[1]), r3.push(t2[i3].usrCoords[2])) : r3.push([t2[i3].usrCoords[1], t2[i3].usrCoords[2]]);
    return e2 && (r3 = [s2, r3]), r3;
  }, cmpArrays: function(t2, e2) {
    var i3;
    if (t2 === e2)
      return true;
    if (t2.length !== e2.length)
      return false;
    for (i3 = 0; i3 < t2.length; i3++)
      if (this.isArray(t2[i3]) && this.isArray(e2[i3])) {
        if (!this.cmpArrays(t2[i3], e2[i3]))
          return false;
      } else if (t2[i3] !== e2[i3])
        return false;
    return true;
  }, removeElementFromArray: function(t2, e2) {
    var i3;
    for (i3 = 0; i3 < t2.length; i3++)
      if (t2[i3] === e2)
        return t2.splice(i3, 1), t2;
    return t2;
  }, trunc: function(t2, e2) {
    return e2 = s.Z.def(e2, 0), this.toFixed(t2, e2);
  }, _decimalAdjust: function(t2, e2, i3) {
    return void 0 === i3 || 0 == +i3 ? Math[t2](e2) : (e2 = +e2, i3 = +i3, isNaN(e2) || "number" != typeof i3 || i3 % 1 != 0 ? NaN : (e2 = e2.toString().split("e"), +((e2 = (e2 = Math[t2](+(e2[0] + "e" + (e2[1] ? +e2[1] - i3 : -i3)))).toString().split("e"))[0] + "e" + (e2[1] ? +e2[1] + i3 : i3))));
  }, _round10: function(t2, e2) {
    return this._decimalAdjust("round", t2, e2);
  }, _floor10: function(t2, e2) {
    return this._decimalAdjust("floor", t2, e2);
  }, _ceil10: function(t2, e2) {
    return this._decimalAdjust("ceil", t2, e2);
  }, toFixed: function(t2, e2) {
    return this._round10(t2, -e2).toFixed(e2);
  }, autoDigits: function(t2) {
    var e2 = Math.abs(t2);
    return e2 >= 0.1 ? this.toFixed(t2, 2) : e2 >= 0.01 ? this.toFixed(t2, 4) : e2 >= 1e-4 ? this.toFixed(t2, 6) : t2;
  }, keys: function(t2, e2) {
    var i3, s2 = [];
    for (i3 in t2)
      e2 ? t2.hasOwnProperty(i3) && s2.push(i3) : s2.push(i3);
    return s2;
  }, clone: function(t2) {
    var e2 = {};
    return e2.prototype = t2, e2;
  }, cloneAndCopy: function(t2, e2) {
    var i3, s2 = function() {
    };
    for (i3 in s2.prototype = t2, e2)
      s2[i3] = e2[i3];
    return s2;
  }, merge: function(t2, e2) {
    var i3, s2, r3, o2;
    for (i3 in e2)
      if (e2.hasOwnProperty(i3))
        if (r3 = e2[i3], this.isArray(r3))
          for (t2[i3] || (t2[i3] = []), s2 = 0; s2 < r3.length; s2++)
            o2 = e2[i3][s2], "object" == typeof e2[i3][s2] ? t2[i3][s2] = this.merge(t2[i3][s2], o2) : t2[i3][s2] = e2[i3][s2];
        else
          "object" == typeof r3 ? (t2[i3] || (t2[i3] = {}), t2[i3] = this.merge(t2[i3], r3)) : t2[i3] = r3;
    return t2;
  }, deepCopy: function(t2, e2, i3) {
    var s2, r3, o2, n;
    if (i3 = i3 || false, "object" != typeof t2 || null === t2)
      return t2;
    if (this.isArray(t2))
      for (s2 = [], r3 = 0; r3 < t2.length; r3++)
        "object" == typeof (o2 = t2[r3]) ? this.exists(o2.board) ? s2[r3] = o2.id : s2[r3] = this.deepCopy(o2) : s2[r3] = o2;
    else {
      for (r3 in s2 = {}, t2)
        t2.hasOwnProperty(r3) && (n = i3 ? r3.toLowerCase() : r3, null !== (o2 = t2[r3]) && "object" == typeof o2 ? this.exists(o2.board) ? s2[n] = o2.id : s2[n] = this.deepCopy(o2) : s2[n] = o2);
      for (r3 in e2)
        e2.hasOwnProperty(r3) && (n = i3 ? r3.toLowerCase() : r3, "object" == typeof (o2 = e2[r3]) ? this.isArray(o2) || !this.exists(s2[n]) ? s2[n] = this.deepCopy(o2) : s2[n] = this.deepCopy(s2[n], o2, i3) : s2[n] = o2);
    }
    return s2;
  }, mergeAttr: function(t2, e2, i3) {
    var s2, r3, o2;
    for (s2 in i3 = i3 || true, e2)
      e2.hasOwnProperty(s2) && (r3 = i3 ? s2.toLowerCase() : s2, o2 = e2[s2], !this.isObject(o2) || null === o2 || this.isDocumentOrFragment(o2) || this.exists(o2.board) || "string" == typeof o2.valueOf() ? t2[r3] = o2 : (void 0 !== t2[r3] && null !== t2[r3] && this.isObject(t2[r3]) || (t2[r3] = {}), this.mergeAttr(t2[r3], o2, i3)));
  }, copyAttributes: function(t2, e2, i3) {
    var r3, o2, n, a, h, l = { circle: 1, curve: 1, foreignobject: 1, image: 1, line: 1, point: 1, polygon: 1, text: 1, ticks: 1, integral: 1 };
    for (r3 = (n = arguments.length) < 3 || l[i3] ? s.Z.deepCopy(e2.elements, null, true) : {}, n < 4 && this.exists(i3) && this.exists(e2.layer[i3]) && (r3.layer = e2.layer[i3]), a = e2, h = true, o2 = 2; o2 < n; o2++) {
      if (!this.exists(a[arguments[o2]])) {
        h = false;
        break;
      }
      a = a[arguments[o2]];
    }
    for (h && (r3 = s.Z.deepCopy(r3, a, true)), a = "object" == typeof t2 ? t2 : {}, h = true, o2 = 3; o2 < n; o2++) {
      if (!this.exists(a[arguments[o2]])) {
        h = false;
        break;
      }
      a = a[arguments[o2]];
    }
    if (h && this.mergeAttr(r3, a, true), "board" === arguments[2])
      return r3;
    for (a = e2, h = true, o2 = 2; o2 < n; o2++) {
      if (!this.exists(a[arguments[o2]])) {
        h = false;
        break;
      }
      a = a[arguments[o2]];
    }
    return h && this.exists(a.label) && (r3.label = s.Z.deepCopy(a.label, r3.label)), r3.label = s.Z.deepCopy(e2.label, r3.label), r3;
  }, copyPrototypeMethods: function(t2, e2, i3) {
    var s2;
    for (s2 in t2.prototype[i3] = e2.prototype.constructor, e2.prototype)
      e2.prototype.hasOwnProperty(s2) && (t2.prototype[s2] = e2.prototype[s2]);
  }, toJSON: function(t2, e2) {
    var i3, r3, o2, n;
    if (e2 = s.Z.def(e2, false), JSON.stringify && !e2)
      try {
        return JSON.stringify(t2);
      } catch (t3) {
      }
    switch (typeof t2) {
      case "object":
        if (t2) {
          if (i3 = [], this.isArray(t2)) {
            for (o2 = 0; o2 < t2.length; o2++)
              i3.push(s.Z.toJSON(t2[o2], e2));
            return "[" + i3.join(",") + "]";
          }
          for (r3 in t2)
            if (t2.hasOwnProperty(r3)) {
              try {
                n = s.Z.toJSON(t2[r3], e2);
              } catch (t3) {
                n = "";
              }
              e2 ? i3.push(r3 + ":" + n) : i3.push('"' + r3 + '":' + n);
            }
          return "{" + i3.join(",") + "} ";
        }
        return "null";
      case "string":
        return "'" + t2.replace(/(["'])/g, "\\$1") + "'";
      case "number":
      case "boolean":
        return t2.toString();
    }
    return "0";
  }, clearVisPropOld: function(t2) {
    return t2.visPropOld = { cssclass: "", cssdefaultstyle: "", cssstyle: "", fillcolor: "", fillopacity: "", firstarrow: false, fontsize: -1, lastarrow: false, left: -1e5, linecap: "", shadow: false, strokecolor: "", strokeopacity: "", strokewidth: "", tabindex: -1e5, transitionduration: 0, top: -1e5, visible: null }, t2;
  }, isInObject: function(t2, e2) {
    var i3;
    for (i3 in t2)
      if (t2.hasOwnProperty(i3) && t2[i3] === e2)
        return true;
    return false;
  }, escapeHTML: function(t2) {
    return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }, unescapeHTML: function(t2) {
    return t2.replace(/<\/?[^>]+>/gi, "").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  }, capitalize: function(t2) {
    return t2.charAt(0).toUpperCase() + t2.substring(1).toLowerCase();
  }, trimNumber: function(t2) {
    return "." !== (t2 = (t2 = t2.replace(/^0+/, "")).replace(/0+$/, ""))[t2.length - 1] && "," !== t2[t2.length - 1] || (t2 = t2.slice(0, -1)), "." !== t2[0] && "," !== t2[0] || (t2 = "0" + t2), t2;
  }, filterElements: function(t2, e2) {
    var i3, s2, r3, o2, n, a, h, l = t2.length, c = [];
    if ("function" != typeof e2 && "object" != typeof e2)
      return c;
    for (i3 = 0; i3 < l; i3++) {
      if (h = true, r3 = t2[i3], "object" == typeof e2) {
        for (s2 in e2)
          if (e2.hasOwnProperty(s2) && (o2 = s2.toLowerCase(), n = "function" == typeof r3[s2] ? r3[s2]() : r3[s2], a = r3.visProp && "function" == typeof r3.visProp[o2] ? r3.visProp[o2]() : r3.visProp && r3.visProp[o2], !(h = "function" == typeof e2[s2] ? e2[s2](n) || e2[s2](a) : n === e2[s2] || a === e2[s2])))
            break;
      } else
        "function" == typeof e2 && (h = e2(r3));
      h && c.push(r3);
    }
    return c;
  }, trim: function(t2) {
    return t2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }, sanitizeHTML: function(t2, e2) {
    return "function" == typeof html_sanitize && e2 ? html_sanitize(t2, function() {
    }, function(t3) {
      return t3;
    }) : (t2 && "string" == typeof t2 && (t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;")), t2);
  }, evalSlider: function(t2) {
    return t2 && t2.type === r2.Z.OBJECT_TYPE_GLIDER && "function" == typeof t2.Value ? t2.Value() : t2;
  } });
  const o = s.Z;
} }, __webpack_module_cache__ = {};
function __webpack_require__(t) {
  var e = __webpack_module_cache__[t];
  if (void 0 !== e)
    return e.exports;
  var i2 = __webpack_module_cache__[t] = { exports: {} };
  return __webpack_modules__[t](i2, i2.exports, __webpack_require__), i2.exports;
}
__webpack_require__.d = (t, e) => {
  for (var i2 in e)
    __webpack_require__.o(e, i2) && !__webpack_require__.o(t, i2) && Object.defineProperty(t, i2, { enumerable: true, get: e[i2] });
}, __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var __webpack_exports__ = {};
(() => {
  __webpack_require__.d(__webpack_exports__, { $l: () => dt, fy: () => et, JU: () => it, kL: () => ut, Cd: () => pt, Zz: () => _t, fS: () => ft, mZ: () => bt, L6: () => gt, Hy: () => mt, iG: () => st, QK: () => vt, ZA: () => Zt, Ee: () => Ct, Nn: () => rt, n1: () => yt, IY: () => Nt, x1: () => Pt, ZX: () => ot, Ei: () => nt, E9: () => Et, mg: () => Ot, xv: () => xt, vb: () => wt, zA: () => St, l8: () => Tt, nY: () => Mt, vP: () => At, lZ: () => kt, I0: () => Rt, ak: () => Dt, tj: () => at, kC: () => Lt, HM: () => Bt, d9: () => It, V$: () => Yt, DV: () => jt, fG: () => Xt, DM: () => Ut, OD: () => Ft, o5: () => Jt, JI: () => Gt, fF: () => zt, Ql: () => Ht, yl: () => Wt, lU: () => Vt, p$: () => $t, Nj: () => Kt, ZP: () => fi, x9: () => qt, Rm: () => ht, XH: () => Qt, r: () => te, Lw: () => ee, ku: () => ie, a2: () => se, vn: () => re, wx: () => ne, zL: () => oe, t_: () => ae, os: () => he, bt: () => le, WJ: () => ce, wK: () => de, XG: () => ue, Dt: () => pe, mL: () => _e, kJ: () => fe, dB: () => be, oG: () => ge, EE: () => me, oP: () => ve, K9: () => Ze, UG: () => Ce, hj: () => ye, Kn: () => Pe, EJ: () => Ee, HD: () => Oe, b1: () => xe, iI: () => we, n2: () => Se, E: () => Te, Ju: () => Me, XP: () => Ne, TS: () => Ae, ZL: () => ke, DG: () => lt, od: () => ct, bU: () => Re, ui: () => De, yt: () => Le, aC: () => Be, sL: () => Ie, xC: () => Ye, OK: () => je, OW: () => Xe, KJ: () => Ue, dq: () => Fe, CO: () => Je, tu: () => Ge, KW: () => We, uh: () => He, cE: () => ze, jW: () => Ve, Xl: () => $e, uw: () => Ke, Fm: () => qe, kK: () => Qe, n: () => ti, SJ: () => ei, LF: () => ii, J6: () => si, FH: () => ri, Ls: () => oi, au: () => ni, A8: () => ai, _V: () => hi, $G: () => li, Uo: () => ci, Nb: () => di, zz: () => ui, W6: () => pi, ZK: () => _i });
  var t = __webpack_require__(765), e = __webpack_require__(503), i2 = __webpack_require__(351), s = __webpack_require__(109);
  t.Z.XML = { cleanWhitespace: function(t2) {
    for (var e2 = t2.firstChild; s.Z.exists(e2); )
      3 !== e2.nodeType || /\S/.test(e2.nodeValue) ? 1 === e2.nodeType && this.cleanWhitespace(e2) : t2.removeChild(e2), e2 = e2.nextSibling;
  }, parse: function(t2) {
    var e2, i3;
    return i3 = "function" == typeof DOMParser || "object" == typeof DOMParser ? DOMParser : function() {
      this.parseFromString = function(t3) {
        var e3;
        return "function" == typeof ActiveXObject && (e3 = new ActiveXObject("MSXML.DomDocument")).loadXML(t3), e3;
      };
    }, e2 = new i3().parseFromString(t2, "text/xml"), this.cleanWhitespace(e2), e2;
  } };
  t.Z.XML;
  var r2 = __webpack_require__(88), o = (__webpack_require__(421), __webpack_require__(275));
  o.Z.ProbFuncs = { MAXNUM: 17014118346046923e22, SQRTH: 0.7071067811865476, SQRT2: 1.4142135623730951, MAXLOG: 708.3964185322641, P: [2461969814735305e-25, 0.5641895648310689, 7.463210564422699, 48.63719709856814, 196.5208329560771, 526.4451949954773, 934.5285271719576, 1027.5518868951572, 557.5353353693994], Q: [13.228195115474499, 86.70721408859897, 354.9377788878199, 975.7085017432055, 1823.9091668790973, 2246.3376081871097, 1656.6630919416134, 557.5353408177277], R: [0.5641895835477551, 1.275366707599781, 5.019050422511805, 6.160210979930536, 7.4097426995044895, 2.9788666537210022], S: [2.2605286322011726, 9.396035249380015, 12.048953980809666, 17.08144507475659, 9.608968090632859, 3.369076451000815], T: [9.604973739870516, 90.02601972038427, 2232.005345946843, 7003.325141128051, 55592.30130103949], U: [33.56171416475031, 521.3579497801527, 4594.323829709801, 22629.000061389095, 49267.39426086359], M: 128, MINV: 78125e-7, expx2: function(t2, e2) {
    var i3, s2, r3, o2;
    return t2 = Math.abs(t2), e2 < 0 && (t2 = -t2), i3 = (r3 = this.MINV * Math.floor(this.M * t2 + 0.5)) * r3, s2 = 2 * r3 * (o2 = t2 - r3) + o2 * o2, e2 < 0 && (i3 = -i3, s2 = -s2), i3 + s2 > this.MAXLOG ? 1 / 0 : i3 = Math.exp(i3) * Math.exp(s2);
  }, polevl: function(t2, e2, i3) {
    var r3, o2;
    if (s.Z.exists(e2.reduce))
      return e2.reduce(function(e3, i4) {
        return e3 * t2 + i4;
      }, 0);
    for (o2 = 0, r3 = 0; o2 <= i3; o2++)
      r3 = r3 * t2 + e2[o2];
    return r3;
  }, p1evl: function(t2, e2, i3) {
    var r3, o2;
    if (s.Z.exists(e2.reduce))
      return e2.reduce(function(e3, i4) {
        return e3 * t2 + i4;
      }, 1);
    for (o2 = 0, r3 = 1; o2 < i3; o2++)
      r3 = r3 * t2 + e2[o2];
    return r3;
  }, ndtr: function(t2) {
    var e2, i3, s2;
    return e2 = t2 * this.SQRTH, (s2 = Math.abs(e2)) < 1 ? i3 = 0.5 + 0.5 * this.erf(e2) : (i3 = 0.5 * this.erfce(s2), s2 = this.expx2(t2, -1), i3 *= Math.sqrt(s2), e2 > 0 && (i3 = 1 - i3)), i3;
  }, _underflow: function(t2) {
    return console.log("erfc", "UNDERFLOW"), t2 < 0 ? 2 : 0;
  }, erfc: function(t2) {
    var e2, i3, s2, r3, o2;
    return (s2 = t2 < 0 ? -t2 : t2) < 1 ? 1 - this.erf(t2) : (o2 = -t2 * t2) < -this.MAXLOG ? this._underflow(t2) : (o2 = this.expx2(t2, -1), s2 < 8 ? (e2 = this.polevl(s2, this.P, 8), i3 = this.p1evl(s2, this.Q, 8)) : (e2 = this.polevl(s2, this.R, 5), i3 = this.p1evl(s2, this.S, 6)), r3 = o2 * e2 / i3, t2 < 0 && (r3 = 2 - r3), 0 === r3 ? this._underflow(t2) : r3);
  }, erfce: function(t2) {
    var e2, i3;
    return t2 < 8 ? (e2 = this.polevl(t2, this.P, 8), i3 = this.p1evl(t2, this.Q, 8)) : (e2 = this.polevl(t2, this.R, 5), i3 = this.p1evl(t2, this.S, 6)), e2 / i3;
  }, erf: function(t2) {
    var e2;
    return Math.abs(t2) > 1 ? 1 - this.erfc(t2) : (e2 = t2 * t2, t2 * this.polevl(e2, this.T, 4) / this.p1evl(e2, this.U, 5));
  }, s2pi: 2.5066282746310007, P0: [-59.96335010141079, 98.00107541859997, -56.67628574690703, 13.931260938727968, -1.2391658386738125], Q0: [1.9544885833814176, 4.676279128988815, 86.36024213908905, -225.46268785411937, 200.26021238006066, -82.03722561683334, 15.90562251262117, -1.1833162112133], P1: [4.0554489230596245, 31.525109459989388, 57.16281922464213, 44.08050738932008, 14.684956192885803, 2.1866330685079025, -0.1402560791713545, -0.03504246268278482, -8574567851546854e-19], Q1: [15.779988325646675, 45.39076351288792, 41.3172038254672, 15.04253856929075, 2.504649462083094, -0.14218292285478779, -0.03808064076915783, -9332594808954574e-19], P2: [3.2377489177694603, 6.915228890689842, 3.9388102529247444, 1.3330346081580755, 0.20148538954917908, 0.012371663481782003, 30158155350823543e-20, 26580697468673755e-22, 6239745391849833e-24], Q2: [6.02427039364742, 3.6798356385616087, 1.3770209948908132, 0.21623699359449663, 0.013420400608854318, 32801446468212774e-20, 28924786474538068e-22, 6790194080099813e-24], ndtri: function(t2) {
    var e2, i3, s2, r3, o2;
    return t2 <= 0 ? -1 / 0 : t2 >= 1 ? 1 / 0 : (o2 = 1, (i3 = t2) > 0.8646647167633873 && (i3 = 1 - i3, o2 = 0), i3 > 0.1353352832366127 ? (e2 = (i3 -= 0.5) + i3 * ((r3 = i3 * i3) * this.polevl(r3, this.P0, 4) / this.p1evl(r3, this.Q0, 8)), e2 *= this.s2pi) : (s2 = 1 / (e2 = Math.sqrt(-2 * Math.log(i3))), e2 = e2 - Math.log(e2) / e2 - (e2 < 8 ? s2 * this.polevl(s2, this.P1, 8) / this.p1evl(s2, this.Q1, 8) : s2 * this.polevl(s2, this.P2, 8) / this.p1evl(s2, this.Q2, 8)), 0 !== o2 && (e2 = -e2), e2));
  }, erfi: function(t2) {
    return this.ndtri(0.5 * (t2 + 1)) * this.SQRTH;
  } };
  o.Z.ProbFuncs;
  var n = __webpack_require__(785);
  o.Z.Extrapolate = { upper: 15, infty: 1e4, wynnEps: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2;
    if (i3[e2] = t2, 0 === e2)
      a2 = t2;
    else {
      for (o2 = 0, s2 = e2; s2 > 0; s2--)
        r3 = o2, o2 = i3[s2 - 1], n2 = i3[s2] - o2, Math.abs(n2) <= 1e-15 ? i3[s2 - 1] = 1e20 : i3[s2 - 1] = 1 * r3 + 1 / n2;
      a2 = i3[e2 % 2];
    }
    return a2;
  }, aitken: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2;
    if (i3[e2] = t2, e2 < 2)
      s2 = t2;
    else {
      for (n2 = e2 / 2, a2 = 1; a2 <= n2; a2++)
        r3 = i3[(h2 = e2 - 2 * a2) + 2] - 2 * i3[h2 + 1] + i3[h2], Math.abs(r3) < 1e-15 ? i3[h2] = 1e20 : (o2 = i3[h2] - i3[h2 + 1], i3[h2] -= o2 * o2 / r3);
      s2 = i3[e2 % 2];
    }
    return s2;
  }, brezinski: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2, l2, c2;
    if (i3[e2] = t2, e2 < 3)
      s2 = t2;
    else {
      for (h2 = e2 / 3, c2 = e2, l2 = 1; l2 <= h2; l2++)
        o2 = i3[(c2 -= 3) + 1] - i3[c2], n2 = i3[c2 + 2] - i3[c2 + 1], r3 = (a2 = i3[c2 + 3] - i3[c2 + 2]) * (n2 - o2) - o2 * (a2 - n2), Math.abs(r3) < 1e-15 ? i3[c2] = 1e20 : i3[c2] = i3[c2 + 1] - o2 * n2 * (a2 - n2) / r3;
      s2 = i3[e2 % 3];
    }
    return s2;
  }, iteration: function(t2, e2, i3, s2, r3) {
    var o2, n2, a2, h2, l2 = NaN, c2 = [], d2 = "finite", u2 = e2;
    for (r3 = r3 || 0, o2 = 1; o2 <= this.upper; o2++) {
      if (n2 = i3(t2 + (u2 = 0 === r3 ? e2 / (o2 + 1) : 0.5 * u2), true), a2 = this[s2](n2, o2 - 1, c2), isNaN(a2)) {
        d2 = "NaN";
        break;
      }
      if (0 !== n2 && a2 / n2 > this.infty) {
        l2 = a2, d2 = "infinite";
        break;
      }
      if (h2 = a2 - l2, Math.abs(h2) < 1e-7)
        break;
      l2 = a2;
    }
    return [l2, d2, 1 - (o2 - 1) / this.upper];
  }, levin: function(t2, e2, i3, s2, r3, o2) {
    var n2, a2, h2, l2;
    if (l2 = 1 / (s2 + e2), r3[e2] = t2 / i3, o2[e2] = 1 / i3, e2 > 0 && (r3[e2 - 1] = r3[e2] - r3[e2 - 1], o2[e2 - 1] = o2[e2] - o2[e2 - 1], e2 > 1))
      for (h2 = (s2 + e2 - 1) * l2, n2 = 2; n2 <= e2; n2++)
        a2 = (s2 + e2 - n2) * Math.pow(h2, n2 - 2) * l2, r3[e2 - n2] = r3[e2 - n2 + 1] - a2 * r3[e2 - n2], o2[e2 - n2] = o2[e2 - n2 + 1] - a2 * o2[e2 - n2], l2 *= h2;
    return Math.abs(o2[0]) < 1e-15 ? 1e20 : r3[0] / o2[0];
  }, iteration_levin: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2, h2, l2, c2, d2 = NaN, u2 = [], p2 = [], _2 = "finite", f2 = e2;
    for (s2 = s2 || 0, a2 = i3(t2 + e2, true), r3 = 1; r3 <= this.upper; r3++) {
      if (h2 = (o2 = i3(t2 + (f2 = 0 === s2 ? e2 / (r3 + 1) : 0.5 * f2), true)) - a2, c2 = "u" === (Math.abs(h2) < 1 ? "u" : "t") ? (1 + r3) * h2 : h2, a2 = o2, l2 = (n2 = this.levin(o2, r3 - 1, c2, 1, u2, p2)) - d2, isNaN(n2)) {
        _2 = "NaN";
        break;
      }
      if (0 !== o2 && n2 / o2 > this.infty) {
        d2 = n2, _2 = "infinite";
        break;
      }
      if (Math.abs(l2) < 1e-7)
        break;
      d2 = n2;
    }
    return [d2, _2, 1 - (r3 - 1) / this.upper];
  }, limit: function(t2, e2, i3) {
    return this.iteration_levin(t2, e2, i3, 0);
  } };
  const a = o.Z.Extrapolate;
  o.Z.Quadtree = function(t2) {
    this.capacity = 10, this.points = [], this.xlb = t2[0], this.xub = t2[2], this.ylb = t2[3], this.yub = t2[1], this.northWest = null, this.northEast = null, this.southEast = null, this.southWest = null;
  }, s.Z.extend(o.Z.Quadtree.prototype, { contains: function(t2, e2) {
    return this.xlb < t2 && t2 <= this.xub && this.ylb < e2 && e2 <= this.yub;
  }, insert: function(t2) {
    return !!this.contains(t2.usrCoords[1], t2.usrCoords[2]) && (this.points.length < this.capacity ? (this.points.push(t2), true) : (null === this.northWest && this.subdivide(), !!this.northWest.insert(t2) || (!!this.northEast.insert(t2) || (!!this.southEast.insert(t2) || !!this.southWest.insert(t2)))));
  }, subdivide: function() {
    var t2, e2 = this.points.length, i3 = this.xlb + (this.xub - this.xlb) / 2, s2 = this.ylb + (this.yub - this.ylb) / 2;
    for (this.northWest = new o.Z.Quadtree([this.xlb, this.yub, i3, s2]), this.northEast = new o.Z.Quadtree([i3, this.yub, this.xub, s2]), this.southEast = new o.Z.Quadtree([this.xlb, s2, i3, this.ylb]), this.southWest = new o.Z.Quadtree([i3, s2, this.xub, this.ylb]), t2 = 0; t2 < e2; t2 += 1)
      this.northWest.insert(this.points[t2]), this.northEast.insert(this.points[t2]), this.southEast.insert(this.points[t2]), this.southWest.insert(this.points[t2]);
  }, _query: function(t2, e2) {
    var i3;
    if (this.contains(t2, e2)) {
      if (null === this.northWest)
        return this;
      if (i3 = this.northWest._query(t2, e2))
        return i3;
      if (i3 = this.northEast._query(t2, e2))
        return i3;
      if (i3 = this.southEast._query(t2, e2))
        return i3;
      if (i3 = this.southWest._query(t2, e2))
        return i3;
    }
    return false;
  }, query: function(t2, e2) {
    var i3, r3;
    return s.Z.exists(e2) ? (i3 = t2, r3 = e2) : (i3 = t2.usrCoords[1], r3 = t2.usrCoords[2]), this._query(i3, r3);
  } });
  const h = o.Z.Quadtree;
  var l = __webpack_require__(336);
  t.Z.Math.Nlp = { arr: function(t2) {
    return new Float64Array(t2);
  }, arr2: function(t2, e2) {
    for (var i3 = 0, s2 = new Array(t2); i3 < t2; )
      s2[i3] = this.arr(e2), i3++;
    return s2;
  }, arraycopy: function(t2, e2, i3, s2, r3) {
    for (var o2 = 0; o2 < r3; )
      i3[o2 + s2] = t2[o2 + e2], o2++;
  }, lastNumberOfEvaluations: 0, GetLastNumberOfEvaluations: function() {
    return this.lastNumberOfEvaluations;
  }, Normal: 0, MaxIterationsReached: 1, DivergingRoundingErrors: 2, FindMinimum: function(t2, e2, i3, s2, r3, o2, n2, a2, h2) {
    var l2, c2, d2 = i3 + 2, u2 = this.arr(e2 + 1), p2 = this;
    return this.lastNumberOfEvaluations = 0, h2 && console.log("Experimental feature 'testForRoundingErrors' is activated."), u2[0] = 0, this.arraycopy(s2, 0, u2, 1, e2), c2 = function(e3, i4, s3, r4) {
      var o3, n3, a3 = p2.arr(e3);
      return p2.lastNumberOfEvaluations = p2.lastNumberOfEvaluations + 1, p2.arraycopy(s3, 1, a3, 0, e3), o3 = p2.arr(i4), n3 = t2(e3, i4, a3, o3), p2.arraycopy(o3, 0, r4, 1, i4), n3;
    }, l2 = this.cobylb(c2, e2, i3, d2, u2, r3, o2, n2, a2, h2), this.arraycopy(u2, 1, s2, 0, e2), l2;
  }, cobylb: function(t2, e2, i3, s2, r3, o2, n2, a2, h2, l2) {
    var c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2, S2, T2, M2, N2, A2, k2, R2, D2, L2, B2, I2, Y2 = -1, j2 = 0, X2 = 0, U2 = e2 + 1, F2 = i3 + 1, J2 = o2, G2 = 0, z2 = false, H2 = false, W2 = 0, V2 = 0, $2 = 0, K2 = this.arr(1 + s2), q2 = this.arr2(1 + e2, 1 + U2), Q2 = this.arr2(1 + e2, 1 + e2), tt2 = this.arr2(1 + s2, 1 + U2), et2 = this.arr2(1 + e2, 1 + F2), it2 = this.arr(1 + e2), st2 = this.arr(1 + e2), rt2 = this.arr(1 + e2), ot2 = this.arr(1 + e2), nt2 = this.arr(1 + e2);
    for (a2 >= 2 && console.log("The initial value of RHO is " + J2 + " and PARMU is set to zero."), g2 = 0, f2 = 1 / J2, d2 = 1; d2 <= e2; ++d2)
      q2[d2][U2] = r3[d2], q2[d2][d2] = J2, Q2[d2][d2] = f2;
    m2 = U2, v2 = false;
    t:
      for (; ; ) {
        if (g2 >= h2 && g2 > 0) {
          Y2 = this.MaxIterationsReached;
          break t;
        }
        for (++g2, j2 = t2(e2, i3, r3, K2), X2 = 0, p2 = 1; p2 <= i3; ++p2)
          X2 = Math.max(X2, -K2[p2]);
        if (g2 !== a2 - 1 && 3 !== a2 || this.PrintIterationResult(g2, j2, X2, r3, e2, a2), K2[F2] = j2, K2[s2] = X2, Z2 = true, !v2) {
          for (Z2 = false, d2 = 1; d2 <= s2; ++d2)
            tt2[d2][m2] = K2[d2];
          if (g2 <= U2) {
            if (m2 <= e2)
              if (tt2[F2][U2] <= j2)
                r3[m2] = q2[m2][U2];
              else {
                for (q2[m2][U2] = r3[m2], p2 = 1; p2 <= s2; ++p2)
                  tt2[p2][m2] = tt2[p2][U2], tt2[p2][U2] = K2[p2];
                for (p2 = 1; p2 <= m2; ++p2) {
                  for (q2[m2][p2] = -J2, f2 = 0, d2 = p2; d2 <= m2; ++d2)
                    f2 -= Q2[d2][p2];
                  Q2[m2][p2] = f2;
                }
              }
            if (g2 <= e2) {
              r3[m2 = g2] += J2;
              continue t;
            }
          }
          v2 = true;
        }
        e:
          for (; ; ) {
            i:
              do {
                if (!Z2) {
                  for (C2 = tt2[F2][U2] + G2 * tt2[s2][U2], y2 = U2, u2 = 1; u2 <= e2; ++u2)
                    (f2 = tt2[F2][u2] + G2 * tt2[s2][u2]) < C2 ? (y2 = u2, C2 = f2) : f2 === C2 && 0 === G2 && tt2[s2][u2] < tt2[s2][y2] && (y2 = u2);
                  if (y2 <= e2) {
                    for (d2 = 1; d2 <= s2; ++d2)
                      f2 = tt2[d2][U2], tt2[d2][U2] = tt2[d2][y2], tt2[d2][y2] = f2;
                    for (d2 = 1; d2 <= e2; ++d2) {
                      for (f2 = q2[d2][y2], q2[d2][y2] = 0, q2[d2][U2] += f2, b2 = 0, p2 = 1; p2 <= e2; ++p2)
                        q2[d2][p2] -= f2, b2 -= Q2[p2][d2];
                      Q2[y2][d2] = b2;
                    }
                  }
                  if (P2 = 0, l2)
                    for (d2 = 1; d2 <= e2; ++d2)
                      for (u2 = 1; u2 <= e2; ++u2)
                        f2 = this.DOT_PRODUCT_ROW_COL(Q2, d2, q2, u2, 1, e2) - (d2 === u2 ? 1 : 0), P2 = Math.max(P2, Math.abs(f2));
                  if (P2 > 0.1) {
                    Y2 = this.DivergingRoundingErrors;
                    break t;
                  }
                  for (p2 = 1; p2 <= F2; ++p2) {
                    for (K2[p2] = -tt2[p2][U2], u2 = 1; u2 <= e2; ++u2)
                      nt2[u2] = tt2[p2][u2] + K2[p2];
                    for (d2 = 1; d2 <= e2; ++d2)
                      et2[d2][p2] = (p2 === F2 ? -1 : 1) * this.DOT_PRODUCT_ROW_COL(nt2, -1, Q2, d2, 1, e2);
                  }
                  for (z2 = true, W2 = 0.25 * J2, E2 = 2.1 * J2, u2 = 1; u2 <= e2; ++u2) {
                    for (O2 = 0, x2 = 0, p2 = 1; p2 <= e2; ++p2)
                      O2 += Q2[u2][p2] * Q2[u2][p2], x2 += q2[p2][u2] * q2[p2][u2];
                    it2[u2] = 1 / Math.sqrt(O2), st2[u2] = Math.sqrt(x2), (it2[u2] < W2 || st2[u2] > E2) && (z2 = false);
                  }
                  if (!v2 && !z2) {
                    for (m2 = 0, f2 = E2, u2 = 1; u2 <= e2; ++u2)
                      st2[u2] > f2 && (m2 = u2, f2 = st2[u2]);
                    if (0 === m2)
                      for (u2 = 1; u2 <= e2; ++u2)
                        it2[u2] < f2 && (m2 = u2, f2 = it2[u2]);
                    for (f2 = 0.5 * J2 * it2[m2], p2 = 1; p2 <= e2; ++p2)
                      ot2[p2] = f2 * Q2[m2][p2];
                    for (w2 = 0, S2 = 0, c2 = 0, p2 = 1; p2 <= F2; ++p2)
                      c2 = this.DOT_PRODUCT_ROW_COL(ot2, -1, et2, p2, 1, e2), p2 < F2 && (f2 = tt2[p2][U2], w2 = Math.max(w2, -c2 - f2), S2 = Math.max(S2, c2 - f2));
                    for (T2 = G2 * (w2 - S2) > 2 * c2 ? -1 : 1, f2 = 0, d2 = 1; d2 <= e2; ++d2)
                      ot2[d2] = T2 * ot2[d2], q2[d2][m2] = ot2[d2], f2 += Q2[m2][d2] * ot2[d2];
                    for (p2 = 1; p2 <= e2; ++p2)
                      Q2[m2][p2] /= f2;
                    for (u2 = 1; u2 <= e2; ++u2) {
                      if (u2 !== m2)
                        for (f2 = this.DOT_PRODUCT_ROW_COL(Q2, u2, ot2, -1, 1, e2), p2 = 1; p2 <= e2; ++p2)
                          Q2[u2][p2] -= f2 * Q2[m2][p2];
                      r3[u2] = q2[u2][U2] + ot2[u2];
                    }
                    continue t;
                  }
                  if (!(H2 = this.trstlp(e2, i3, et2, K2, J2, ot2))) {
                    for (f2 = 0, p2 = 1; p2 <= e2; ++p2)
                      f2 += ot2[p2] * ot2[p2];
                    if (f2 < 0.25 * J2 * J2) {
                      v2 = true;
                      break i;
                    }
                  }
                  for (c2 = 0, M2 = 0, K2[F2] = 0, p2 = 1; p2 <= F2; ++p2)
                    c2 = K2[p2] - this.DOT_PRODUCT_ROW_COL(ot2, -1, et2, p2, 1, e2), p2 < F2 && (M2 = Math.max(M2, c2));
                  if (G2 < 1.5 * (N2 = (V2 = tt2[s2][U2] - M2) > 0 ? c2 / V2 : 0)) {
                    for (G2 = 2 * N2, a2 >= 2 && console.log("Increase in PARMU to " + G2), A2 = tt2[F2][U2] + G2 * tt2[s2][U2], u2 = 1; u2 <= e2; ++u2)
                      if ((f2 = tt2[F2][u2] + G2 * tt2[s2][u2]) < A2 || f2 === A2 && 0 === G2 && tt2[s2][u2] < tt2[s2][U2])
                        continue e;
                  }
                  for ($2 = G2 * V2 - c2, p2 = 1; p2 <= e2; ++p2)
                    r3[p2] = q2[p2][U2] + ot2[p2];
                  v2 = true;
                  continue t;
                }
                for (Z2 = false, k2 = tt2[F2][U2] + G2 * tt2[s2][U2] - (j2 + G2 * X2), 0 === G2 && j2 === tt2[F2][U2] && ($2 = V2, k2 = tt2[s2][U2] - X2), R2 = k2 <= 0 ? 1 : 0, m2 = 0, u2 = 1; u2 <= e2; ++u2)
                  (f2 = Math.abs(this.DOT_PRODUCT_ROW_COL(Q2, u2, ot2, -1, 1, e2))) > R2 && (m2 = u2, R2 = f2), rt2[u2] = f2 * it2[u2];
                for (D2 = 1.1 * J2, _2 = 0, u2 = 1; u2 <= e2; ++u2)
                  if (rt2[u2] >= W2 || rt2[u2] >= it2[u2]) {
                    if (f2 = st2[u2], k2 > 0) {
                      for (f2 = 0, p2 = 1; p2 <= e2; ++p2)
                        f2 += Math.pow(ot2[p2] - q2[p2][u2], 2);
                      f2 = Math.sqrt(f2);
                    }
                    f2 > D2 && (_2 = u2, D2 = f2);
                  }
                if (_2 > 0 && (m2 = _2), 0 !== m2) {
                  for (f2 = 0, d2 = 1; d2 <= e2; ++d2)
                    q2[d2][m2] = ot2[d2], f2 += Q2[m2][d2] * ot2[d2];
                  for (p2 = 1; p2 <= e2; ++p2)
                    Q2[m2][p2] /= f2;
                  for (u2 = 1; u2 <= e2; ++u2)
                    if (u2 !== m2)
                      for (f2 = this.DOT_PRODUCT_ROW_COL(Q2, u2, ot2, -1, 1, e2), p2 = 1; p2 <= e2; ++p2)
                        Q2[u2][p2] -= f2 * Q2[m2][p2];
                  for (p2 = 1; p2 <= s2; ++p2)
                    tt2[p2][m2] = K2[p2];
                  if (k2 > 0 && k2 >= 0.1 * $2)
                    continue e;
                }
              } while (0);
            if (z2) {
              if (J2 <= n2) {
                Y2 = this.Normal;
                break t;
              }
              if (L2 = 0, B2 = 0, (J2 *= 0.5) <= 1.5 * n2 && (J2 = n2), G2 > 0) {
                for (I2 = 0, p2 = 1; p2 <= F2; ++p2) {
                  for (B2 = L2 = tt2[p2][U2], d2 = 1; d2 <= e2; ++d2)
                    L2 = Math.min(L2, tt2[p2][d2]), B2 = Math.max(B2, tt2[p2][d2]);
                  p2 <= i3 && L2 < 0.5 * B2 && (f2 = Math.max(B2, 0) - L2, I2 = I2 <= 0 ? f2 : Math.min(I2, f2));
                }
                0 === I2 ? G2 = 0 : B2 - L2 < G2 * I2 && (G2 = (B2 - L2) / I2);
              }
              a2 >= 2 && console.log("Reduction in RHO to " + J2 + "  and PARMU = " + G2), 2 === a2 && this.PrintIterationResult(g2, tt2[F2][U2], tt2[s2][U2], this.COL(q2, U2), e2, a2);
            } else
              v2 = false;
          }
      }
    switch (Y2) {
      case this.Normal:
        if (a2 >= 1 && console.log("%nNormal return from subroutine COBYLA%n"), H2)
          return a2 >= 1 && this.PrintIterationResult(g2, j2, X2, r3, e2, a2), Y2;
        break;
      case this.MaxIterationsReached:
        a2 >= 1 && console.log("%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n");
        break;
      case this.DivergingRoundingErrors:
        a2 >= 1 && console.log("%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n");
    }
    for (p2 = 1; p2 <= e2; ++p2)
      r3[p2] = q2[p2][U2];
    return j2 = tt2[F2][U2], X2 = tt2[s2][U2], a2 >= 1 && this.PrintIterationResult(g2, j2, X2, r3, e2, a2), Y2;
  }, trstlp: function(t2, e2, i3, s2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2, S2, T2, M2, N2, A2, k2, R2, D2, L2, B2, I2, Y2 = 0, j2 = 0, X2 = 0, U2 = this.arr2(1 + t2, 1 + t2), F2 = this.arr(2 + e2), J2 = this.arr(2 + e2), G2 = this.arr(1 + t2), z2 = this.arr(1 + t2), H2 = this.arr(2 + e2), W2 = this.arr(2 + e2), V2 = e2, $2 = 0;
    for (h2 = 1; h2 <= t2; ++h2)
      U2[h2][h2] = 1, o2[h2] = 0;
    if (n2 = 0, a2 = 0, e2 >= 1) {
      for (l2 = 1; l2 <= e2; ++l2)
        s2[l2] > a2 && (a2 = s2[l2], n2 = l2);
      for (l2 = 1; l2 <= e2; ++l2)
        W2[l2] = l2, J2[l2] = a2 - s2[l2];
    }
    c2 = true;
    do {
      t:
        for (; ; ) {
          (!c2 || c2 && 0 === a2) && (n2 = V2 = e2 + 1, W2[V2] = V2, J2[V2] = 0), c2 = false, d2 = 0, u2 = 0, p2 = 0, _2 = 0;
          e:
            do {
              if (f2 = V2 === e2 ? a2 : -this.DOT_PRODUCT_ROW_COL(o2, -1, i3, V2, 1, t2), 0 === u2 || f2 < d2 ? (d2 = f2, j2 = $2, u2 = 3) : $2 > j2 ? (j2 = $2, u2 = 3) : --u2, 0 === u2)
                break t;
              if (b2 = 0, n2 <= $2) {
                if (n2 < $2) {
                  g2 = W2[n2], m2 = J2[n2], l2 = n2;
                  do {
                    for (C2 = W2[Z2 = l2 + 1], y2 = this.DOT_PRODUCT(this.PART(this.COL(U2, l2), 1, t2), this.PART(this.COL(i3, C2), 1, t2)), Y2 = Math.sqrt(y2 * y2 + F2[Z2] * F2[Z2]), P2 = F2[Z2] / Y2, E2 = y2 / Y2, F2[Z2] = P2 * F2[l2], F2[l2] = Y2, h2 = 1; h2 <= t2; ++h2)
                      Y2 = P2 * U2[h2][Z2] + E2 * U2[h2][l2], U2[h2][Z2] = P2 * U2[h2][l2] - E2 * U2[h2][Z2], U2[h2][l2] = Y2;
                    W2[l2] = C2, J2[l2] = J2[Z2], l2 = Z2;
                  } while (l2 < $2);
                  W2[l2] = g2, J2[l2] = m2;
                }
                if (--$2, V2 > e2)
                  for (Y2 = 1 / F2[$2], l2 = 1; l2 <= t2; ++l2)
                    G2[l2] = Y2 * U2[l2][$2];
                else
                  for (Y2 = this.DOT_PRODUCT_ROW_COL(G2, -1, U2, $2 + 1, 1, t2), l2 = 1; l2 <= t2; ++l2)
                    G2[l2] -= Y2 * U2[l2][$2 + 1];
              } else {
                for (C2 = W2[n2], l2 = 1; l2 <= t2; ++l2)
                  z2[l2] = i3[l2][C2];
                for (O2 = 0, l2 = t2; l2 > $2; ) {
                  for (y2 = 0, x2 = 0, h2 = 1; h2 <= t2; ++h2)
                    y2 += Y2 = U2[h2][l2] * z2[h2], x2 += Math.abs(Y2);
                  if (w2 = x2 + 0.1 * Math.abs(y2), S2 = x2 + 0.2 * Math.abs(y2), (x2 >= w2 || w2 >= S2) && (y2 = 0), 0 === O2)
                    O2 = y2;
                  else
                    for (Z2 = l2 + 1, P2 = y2 / (Y2 = Math.sqrt(y2 * y2 + O2 * O2)), E2 = O2 / Y2, O2 = Y2, h2 = 1; h2 <= t2; ++h2)
                      Y2 = P2 * U2[h2][l2] + E2 * U2[h2][Z2], U2[h2][Z2] = P2 * U2[h2][Z2] - E2 * U2[h2][l2], U2[h2][l2] = Y2;
                  --l2;
                }
                if (0 === O2) {
                  b2 = -1, l2 = $2;
                  do {
                    for (T2 = 0, M2 = 0, h2 = 1; h2 <= t2; ++h2)
                      T2 += Y2 = U2[h2][l2] * z2[h2], M2 += Math.abs(Y2);
                    if (w2 = M2 + 0.1 * Math.abs(T2), S2 = M2 + 0.2 * Math.abs(T2), M2 < w2 && w2 < S2) {
                      if ((Y2 = T2 / F2[l2]) > 0 && W2[l2] <= e2 && (I2 = J2[l2] / Y2, (b2 < 0 || I2 < b2) && (b2 = I2)), l2 >= 2)
                        for (N2 = W2[l2], h2 = 1; h2 <= t2; ++h2)
                          z2[h2] -= Y2 * i3[h2][N2];
                      H2[l2] = Y2;
                    } else
                      H2[l2] = 0;
                  } while (--l2 > 0);
                  if (b2 < 0)
                    break t;
                  for (l2 = 1; l2 <= $2; ++l2)
                    J2[l2] = Math.max(0, J2[l2] - b2 * H2[l2]);
                  if (n2 < $2) {
                    g2 = W2[n2], m2 = J2[n2], l2 = n2;
                    do {
                      for (N2 = W2[Z2 = l2 + 1], y2 = this.DOT_PRODUCT(this.PART(this.COL(U2, l2), 1, t2), this.PART(this.COL(i3, N2), 1, t2)), Y2 = Math.sqrt(y2 * y2 + F2[Z2] * F2[Z2]), P2 = F2[Z2] / Y2, E2 = y2 / Y2, F2[Z2] = P2 * F2[l2], F2[l2] = Y2, h2 = 1; h2 <= t2; ++h2)
                        Y2 = P2 * U2[h2][Z2] + E2 * U2[h2][l2], U2[h2][Z2] = P2 * U2[h2][l2] - E2 * U2[h2][Z2], U2[h2][l2] = Y2;
                      W2[l2] = N2, J2[l2] = J2[Z2], l2 = Z2;
                    } while (l2 < $2);
                    W2[l2] = g2, J2[l2] = m2;
                  }
                  if (0 === (Y2 = this.DOT_PRODUCT(this.PART(this.COL(U2, $2), 1, t2), this.PART(this.COL(i3, C2), 1, t2))))
                    break t;
                  F2[$2] = Y2, J2[n2] = 0, J2[$2] = b2;
                } else
                  F2[++$2] = O2, J2[n2] = J2[$2], J2[$2] = 0;
                if (W2[n2] = W2[$2], W2[$2] = C2, V2 > e2 && C2 !== V2) {
                  for (l2 = $2 - 1, y2 = this.DOT_PRODUCT(this.PART(this.COL(U2, l2), 1, t2), this.PART(this.COL(i3, C2), 1, t2)), Y2 = Math.sqrt(y2 * y2 + F2[$2] * F2[$2]), P2 = F2[$2] / Y2, E2 = y2 / Y2, F2[$2] = P2 * F2[l2], F2[l2] = Y2, h2 = 1; h2 <= t2; ++h2)
                    Y2 = P2 * U2[h2][$2] + E2 * U2[h2][l2], U2[h2][$2] = P2 * U2[h2][l2] - E2 * U2[h2][$2], U2[h2][l2] = Y2;
                  W2[$2] = W2[l2], W2[l2] = C2, Y2 = J2[l2], J2[l2] = J2[$2], J2[$2] = Y2;
                }
                if (V2 > e2)
                  for (Y2 = 1 / F2[$2], l2 = 1; l2 <= t2; ++l2)
                    G2[l2] = Y2 * U2[l2][$2];
                else
                  for (C2 = W2[$2], Y2 = (this.DOT_PRODUCT_ROW_COL(G2, -1, i3, C2, 1, t2) - 1) / F2[$2], l2 = 1; l2 <= t2; ++l2)
                    G2[l2] -= Y2 * U2[l2][$2];
              }
              for (A2 = r3 * r3, R2 = 0, k2 = 0, h2 = 1; h2 <= t2; ++h2)
                Math.abs(o2[h2]) >= 1e-6 * r3 && (A2 -= o2[h2] * o2[h2]), R2 += o2[h2] * G2[h2], k2 += G2[h2] * G2[h2];
              if (A2 <= 0)
                break t;
              if (Y2 = Math.sqrt(k2 * A2), Math.abs(R2) >= 1e-6 * Y2 && (Y2 = Math.sqrt(k2 * A2 + R2 * R2)), p2 = _2 = A2 / (Y2 + R2), V2 === e2) {
                if (S2 = p2 + 0.2 * a2, p2 >= (w2 = p2 + 0.1 * a2) || w2 >= S2)
                  break e;
                p2 = Math.min(p2, a2);
              }
              for (l2 = 1; l2 <= t2; ++l2)
                z2[l2] = o2[l2] + p2 * G2[l2];
              if (V2 === e2)
                for (X2 = a2, a2 = 0, l2 = 1; l2 <= $2; ++l2)
                  Y2 = s2[C2 = W2[l2]] - this.DOT_PRODUCT_ROW_COL(z2, -1, i3, C2, 1, t2), a2 = Math.max(a2, Y2);
              l2 = $2;
              do {
                for (D2 = 0, L2 = 0, h2 = 1; h2 <= t2; ++h2)
                  D2 += Y2 = U2[h2][l2] * z2[h2], L2 += Math.abs(Y2);
                if (w2 = L2 + 0.1 * Math.abs(D2), S2 = L2 + 0.2 * Math.abs(D2), (L2 >= w2 || w2 >= S2) && (D2 = 0), H2[l2] = D2 / F2[l2], l2 >= 2)
                  for (C2 = W2[l2], h2 = 1; h2 <= t2; ++h2)
                    z2[h2] -= H2[l2] * i3[h2][C2];
              } while (l2-- >= 2);
              for (V2 > e2 && (H2[$2] = Math.max(0, H2[$2])), l2 = 1; l2 <= t2; ++l2)
                z2[l2] = o2[l2] + p2 * G2[l2];
              if (V2 > $2)
                for (l2 = $2 + 1; l2 <= V2; ++l2) {
                  for (v2 = a2 - s2[C2 = W2[l2]], B2 = a2 + Math.abs(s2[C2]), h2 = 1; h2 <= t2; ++h2)
                    v2 += Y2 = i3[h2][C2] * z2[h2], B2 += Math.abs(Y2);
                  w2 = B2 + 0.1 * Math.abs(v2), S2 = B2 + 0.2 * Math.abs(v2), (B2 >= w2 || w2 >= S2) && (v2 = 0), H2[l2] = v2;
                }
              for (b2 = 1, n2 = 0, l2 = 1; l2 <= V2; ++l2)
                H2[l2] < 0 && (Y2 = J2[l2] / (J2[l2] - H2[l2])) < b2 && (b2 = Y2, n2 = l2);
              for (Y2 = 1 - b2, l2 = 1; l2 <= t2; ++l2)
                o2[l2] = Y2 * o2[l2] + b2 * z2[l2];
              for (l2 = 1; l2 <= V2; ++l2)
                J2[l2] = Math.max(0, Y2 * J2[l2] + b2 * H2[l2]);
              V2 === e2 && (a2 = X2 + b2 * (a2 - X2));
            } while (n2 > 0);
          if (p2 === _2)
            return true;
        }
    } while (V2 === e2);
    return false;
  }, PrintIterationResult: function(t2, e2, i3, s2, r3, o2) {
    o2 > 1 && console.log("NFVALS = " + t2 + "  F = " + e2 + "  MAXCV = " + i3), o2 > 1 && console.log("X = " + this.PART(s2, 1, r3));
  }, ROW: function(t2, e2) {
    return t2[e2].slice();
  }, COL: function(t2, e2) {
    var i3, s2 = t2.length, r3 = [];
    for (i3 = 0; i3 < s2; ++i3)
      r3[i3] = t2[i3][e2];
    return r3;
  }, PART: function(t2, e2, i3) {
    return t2.slice(e2, i3 + 1);
  }, FORMAT: function(t2) {
    return t2.join(",");
  }, DOT_PRODUCT: function(t2, e2) {
    var i3, s2 = 0, r3 = t2.length;
    for (i3 = 0; i3 < r3; ++i3)
      s2 += t2[i3] * e2[i3];
    return s2;
  }, DOT_PRODUCT_ROW_COL: function(t2, e2, i3, s2, r3, o2) {
    var n2, a2 = 0;
    if (-1 === e2)
      for (n2 = r3; n2 <= o2; ++n2)
        a2 += t2[n2] * i3[n2][s2];
    else if (-1 === s2)
      for (n2 = r3; n2 <= o2; ++n2)
        a2 += t2[e2][n2] * i3[n2];
    else
      for (n2 = r3; n2 <= o2; ++n2)
        a2 += t2[e2][n2] * i3[n2][s2];
    return a2;
  } };
  t.Z.Math.Nlp;
  var c = __webpack_require__(705), d = __webpack_require__(309), u = __webpack_require__(922);
  o.Z.Plot = { checkReal: function(t2) {
    var e2, i3, s2 = false, r3 = t2.length;
    for (e2 = 0; e2 < r3; e2++)
      if (i3 = t2[e2].usrCoords, !isNaN(i3[1]) && !isNaN(i3[2]) && Math.abs(i3[0]) > o.Z.eps) {
        s2 = true;
        break;
      }
    return s2;
  }, updateParametricCurveNaive: function(t2, e2, s2, r3) {
    var o2, n2, a2 = false, h2 = (s2 - e2) / r3;
    for (o2 = 0; o2 < r3; o2++)
      n2 = e2 + o2 * h2, t2.points[o2].setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(n2, a2), t2.Y(n2, a2)], false), t2.points[o2]._t = n2, a2 = true;
    return t2;
  }, isSegmentOutside: function(t2, e2, i3, s2, r3) {
    return e2 < 0 && s2 < 0 || e2 > r3.canvasHeight && s2 > r3.canvasHeight || t2 < 0 && i3 < 0 || t2 > r3.canvasWidth && i3 > r3.canvasWidth;
  }, isDistOK: function(t2, e2, i3, s2) {
    return Math.abs(t2) < i3 && Math.abs(e2) < s2 && !isNaN(t2 + e2);
  }, isSegmentDefined: function(t2, e2, i3, s2) {
    return !(isNaN(t2 + e2) && isNaN(i3 + s2));
  }, updateParametricCurveOld: function(e2, s2, r3) {
    var n2, a2, h2, l2, d2, u2, p2, _2, f2, b2, g2, m2 = false, v2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], e2.board, false), Z2 = [], C2 = [], y2 = [], P2 = [], E2 = false, O2 = 0, x2 = function(t2, e3, i3) {
      var s3, r4, n3 = i3[1] - t2[1], a3 = i3[2] - t2[2], h3 = e3[0] - t2[1], l3 = e3[1] - t2[2], c2 = h3 * h3 + l3 * l3;
      return c2 >= o.Z.eps && (s3 = (n3 * h3 + a3 * l3) / c2) > 0 && (s3 <= 1 ? (n3 -= s3 * h3, a3 -= s3 * l3) : (n3 -= h3, a3 -= l3)), r4 = n3 * n3 + a3 * a3, Math.sqrt(r4);
    };
    for (t.Z.deprecated("Curve.updateParametricCurveOld()"), e2.board.updateQuality === e2.board.BOARD_QUALITY_LOW ? (f2 = 15, b2 = 10, g2 = 10) : (f2 = 21, b2 = 0.7, g2 = 0.7), P2[0] = r3 - s2, n2 = 1; n2 < f2; n2++)
      P2[n2] = 0.5 * P2[n2 - 1];
    n2 = 1, Z2[0] = 1, C2[0] = 0, a2 = s2, v2.setCoordinates(i2.Z.COORDS_BY_USER, [e2.X(a2, m2), e2.Y(a2, m2)], false), m2 = true, d2 = v2.scrCoords[1], u2 = v2.scrCoords[2], a2 = r3, v2.setCoordinates(i2.Z.COORDS_BY_USER, [e2.X(a2, m2), e2.Y(a2, m2)], false), h2 = v2.scrCoords[1], l2 = v2.scrCoords[2], y2[0] = [h2, l2], p2 = 1, _2 = 0, e2.points = [], e2.points[O2++] = new c.Z(i2.Z.COORDS_BY_SCREEN, [d2, u2], e2.board, false);
    do {
      for (E2 = this.isDistOK(h2 - d2, l2 - u2, b2, g2) || this.isSegmentOutside(d2, u2, h2, l2, e2.board); _2 < f2 && (!E2 || _2 < 6) && (_2 <= 7 || this.isSegmentDefined(d2, u2, h2, l2)); )
        Z2[p2] = n2, C2[p2] = _2, y2[p2] = [h2, l2], p2 += 1, a2 = s2 + (n2 = 2 * n2 - 1) * P2[++_2], v2.setCoordinates(i2.Z.COORDS_BY_USER, [e2.X(a2, m2), e2.Y(a2, m2)], false, true), h2 = v2.scrCoords[1], l2 = v2.scrCoords[2], E2 = this.isDistOK(h2 - d2, l2 - u2, b2, g2) || this.isSegmentOutside(d2, u2, h2, l2, e2.board);
      O2 > 1 && x2(e2.points[O2 - 2].scrCoords, [h2, l2], e2.points[O2 - 1].scrCoords) < 0.015 && (O2 -= 1), e2.points[O2] = new c.Z(i2.Z.COORDS_BY_SCREEN, [h2, l2], e2.board, false), e2.points[O2]._t = a2, O2 += 1, d2 = h2, u2 = l2, h2 = y2[p2 -= 1][0], l2 = y2[p2][1], _2 = C2[p2] + 1, n2 = 2 * Z2[p2];
    } while (p2 > 0 && O2 < 5e5);
    return e2.numberPoints = e2.points.length, e2;
  }, _insertPoint_v2: function(t2, e2, i3) {
    var s2 = !isNaN(this._lastCrds[1] + this._lastCrds[2]), r3 = !isNaN(e2.scrCoords[1] + e2.scrCoords[2]), o2 = t2.board.canvasWidth, n2 = t2.board.canvasHeight, a2 = 500;
    (!(r3 = r3 && e2.scrCoords[1] > -500 && e2.scrCoords[2] > -500 && e2.scrCoords[1] < o2 + a2 && e2.scrCoords[2] < n2 + a2) && s2 || r3 && (!s2 || Math.abs(e2.scrCoords[1] - this._lastCrds[1]) > 0.7 || Math.abs(e2.scrCoords[2] - this._lastCrds[2]) > 0.7)) && (e2._t = i3, t2.points.push(e2), this._lastCrds = e2.copy("scrCoords"));
  }, neighborhood_isNaN_v2: function(t2, e2) {
    var s2, r3, n2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false);
    return s2 = e2 + o.Z.eps, n2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(s2, true), t2.Y(s2, true)], false), r3 = n2.usrCoords, !!(isNaN(r3[1] + r3[2]) || (s2 = e2 - o.Z.eps, n2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(s2, true), t2.Y(s2, true)], false), r3 = n2.usrCoords, isNaN(r3[1] + r3[2])));
  }, _borderCase: function(t2, e2, s2, r3, o2, n2, a2, h2) {
    var l2, d2, u2, p2, _2, f2, b2, g2 = null, m2 = false;
    if (h2 <= 1) {
      if (d2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false), isNaN(e2[1] + e2[2]) && !isNaN(r3[1] + r3[2]) && !this.neighborhood_isNaN_v2(t2, o2))
        return false;
      if (isNaN(s2[1] + s2[2]) && !isNaN(r3[1] + r3[2]) && !this.neighborhood_isNaN_v2(t2, n2))
        return false;
      if (isNaN(r3[1] + r3[2]) && (!isNaN(e2[1] + e2[2]) || !isNaN(s2[1] + s2[2])) && !this.neighborhood_isNaN_v2(t2, a2))
        return false;
      p2 = 0;
      do {
        if (isNaN(e2[1] + e2[2]) && !isNaN(r3[1] + r3[2]))
          _2 = o2, f2 = a2, b2 = n2;
        else if (isNaN(s2[1] + s2[2]) && !isNaN(r3[1] + r3[2]))
          _2 = n2, f2 = a2, b2 = o2;
        else if (isNaN(r3[1] + r3[2]) && !isNaN(s2[1] + s2[2]))
          _2 = a2, f2 = n2, b2 = n2 + (n2 - a2);
        else {
          if (!isNaN(r3[1] + r3[2]) || isNaN(e2[1] + e2[2]))
            return false;
          _2 = a2, f2 = o2, b2 = o2 - (a2 - o2);
        }
        l2 = 0.5 * (_2 + f2), d2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(l2, true), t2.Y(l2, true)], false), u2 = d2.usrCoords, (m2 = isNaN(u2[1] + u2[2])) ? _2 = l2 : (b2 = f2, f2 = l2), ++p2;
      } while (m2 && p2 < 30);
      if (p2 < 30 && (g2 = u2.slice(), r3 = u2.slice(), f2 = l2), (t2.X(f2, true) - t2.X(b2, true)) / (f2 - b2), (t2.Y(f2, true) - t2.Y(b2, true)) / (f2 - b2), null !== g2)
        return this._insertPoint_v2(t2, new c.Z(i2.Z.COORDS_BY_USER, g2, t2.board, false)), true;
    }
    return false;
  }, _plotRecursive_v2: function(t2, e2, s2, r3, o2, n2, a2) {
    var h2, l2, d2, u2, p2, _2 = 0, f2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false);
    if (!(t2.numberPoints > 65536))
      return n2 < this.nanLevel && this._isUndefined(t2, e2, s2, r3, o2) || n2 < this.nanLevel && this._isOutside(e2, s2, r3, o2, t2.board) ? this : (h2 = 0.5 * (s2 + o2), f2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(h2, true), t2.Y(h2, true)], false), l2 = f2.scrCoords, this._borderCase(t2, e2, r3, l2, s2, o2, h2, n2) || (d2 = this._triangleDists(e2, r3, l2), u2 = n2 < this.smoothLevel && d2[3] < a2, p2 = n2 < this.jumpLevel && (d2[2] > 0.99 * d2[0] || d2[1] > 0.99 * d2[0] || d2[0] === 1 / 0 || d2[1] === 1 / 0 || d2[2] === 1 / 0), n2 < this.smoothLevel + 2 && d2[0] < 0.5 * (d2[1] + d2[2]) && (_2 = 0, u2 = false), --n2, p2 ? this._insertPoint_v2(t2, new c.Z(i2.Z.COORDS_BY_SCREEN, [NaN, NaN], t2.board, false), h2) : n2 <= _2 || u2 ? this._insertPoint_v2(t2, f2, h2) : (this._plotRecursive_v2(t2, e2, s2, l2, h2, n2, a2), isNaN(f2.scrCoords[1] + f2.scrCoords[2]) || this._insertPoint_v2(t2, f2, h2), this._plotRecursive_v2(t2, l2, h2, r3, o2, n2, a2))), this);
  }, updateParametricCurve_v2: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, d2, u2, p2, _2, f2 = false, b2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false), g2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false);
    return t2.board.updateQuality === t2.board.BOARD_QUALITY_LOW ? (l2 = s.Z.evaluate(t2.visProp.recursiondepthlow) || 13, d2 = 2, this.smoothLevel = l2 - 6, this.jumpLevel = 3) : (l2 = s.Z.evaluate(t2.visProp.recursiondepthhigh) || 17, d2 = 2, this.smoothLevel = l2 - 9, this.jumpLevel = 2), this.nanLevel = l2 - 4, t2.points = [], "x" === this.xterm ? (u2 = 0.3 * ((p2 = t2.board.getBoundingBox())[2] - p2[0]), 0.3 * (p2[1] - p2[3]), o2 = Math.max(e2, p2[0] - u2), n2 = Math.min(r3, p2[2] + u2)) : (o2 = e2, n2 = r3), b2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(o2, f2), t2.Y(o2, f2)], false), f2 = true, g2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(n2, f2), t2.Y(n2, f2)], false), _2 = this._findStartPoint(t2, b2.scrCoords, o2, g2.scrCoords, n2), b2.setCoordinates(i2.Z.COORDS_BY_SCREEN, _2[0], false), o2 = _2[1], _2 = this._findStartPoint(t2, g2.scrCoords, n2, b2.scrCoords, o2), g2.setCoordinates(i2.Z.COORDS_BY_SCREEN, _2[0], false), n2 = _2[1], this._visibleArea = [o2, n2], a2 = b2.copy("scrCoords"), h2 = g2.copy("scrCoords"), b2._t = o2, t2.points.push(b2), this._lastCrds = b2.copy("scrCoords"), this._plotRecursive_v2(t2, a2, o2, h2, n2, l2, d2), g2._t = n2, t2.points.push(g2), t2.numberPoints = t2.points.length, t2;
  }, _insertLimesPoint: function(t2, e2, s2, r3, n2) {
    var a2, h2, l2;
    Math.abs(this._lastUsrCrds[1]) === 1 / 0 && Math.abs(n2.left_x) === 1 / 0 || Math.abs(this._lastUsrCrds[2]) === 1 / 0 && Math.abs(n2.left_y) === 1 / 0 || ((a2 = new c.Z(i2.Z.COORDS_BY_USER, [n2.left_x, n2.left_y], t2.board))._t = s2, t2.points.push(a2), isNaN(n2.left_x) || isNaN(n2.left_y) || isNaN(n2.right_x) || isNaN(n2.right_y) || !(Math.abs(n2.left_x - n2.right_x) > o.Z.eps || Math.abs(n2.left_y - n2.right_y) > o.Z.eps) || ((h2 = new c.Z(i2.Z.COORDS_BY_SCREEN, e2, t2.board))._t = s2, t2.points.push(h2)), (l2 = new c.Z(i2.Z.COORDS_BY_USER, [n2.right_x, n2.right_y], t2.board))._t = s2, t2.points.push(l2), this._lastScrCrds = l2.copy("scrCoords"), this._lastUsrCrds = l2.copy("usrCoords"));
  }, _insertPoint: function(t2, e2, r3, o2, n2) {
    var a2, h2 = !isNaN(this._lastScrCrds[1] + this._lastScrCrds[2]), l2 = !isNaN(e2[1] + e2[2]), d2 = t2.board.canvasWidth, u2 = t2.board.canvasHeight, p2 = 500;
    s.Z.exists(n2) ? this._insertLimesPoint(t2, e2, r3, o2, n2) : (l2 = l2 && e2[1] > -500 && e2[2] > -500 && e2[1] < d2 + p2 && e2[2] < u2 + p2, (h2 || l2) && (l2 && h2 && Math.abs(e2[1] - this._lastScrCrds[1]) < 0.8 && Math.abs(e2[2] - this._lastScrCrds[2]) < 0.8 || Math.abs(e2[1]) === 1 / 0 && Math.abs(this._lastUsrCrds[1]) === 1 / 0 || Math.abs(e2[2]) === 1 / 0 && Math.abs(this._lastUsrCrds[2]) === 1 / 0 || ((a2 = new c.Z(i2.Z.COORDS_BY_SCREEN, e2, t2.board))._t = r3, t2.points.push(a2), this._lastScrCrds = a2.copy("scrCoords"), this._lastUsrCrds = a2.copy("usrCoords"))));
  }, _triangleDists: function(t2, e2, i3) {
    var s2;
    return s2 = [t2[0] * e2[0], 0.5 * (t2[1] + e2[1]), 0.5 * (t2[2] + e2[2])], [u.Z.distance(t2, e2, 3), u.Z.distance(t2, i3, 3), u.Z.distance(i3, e2, 3), u.Z.distance(i3, s2, 3)];
  }, _isUndefined: function(t2, e2, s2, r3, o2) {
    var n2, a2, h2;
    if (!isNaN(e2[1] + e2[2]) || !isNaN(r3[1] + r3[2]))
      return false;
    for (h2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false), a2 = 0; a2 < 20; ++a2)
      if (n2 = s2 + Math.random() * (o2 - s2), h2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(n2, true), t2.Y(n2, true)], false), !isNaN(h2.scrCoords[0] + h2.scrCoords[1] + h2.scrCoords[2]))
        return false;
    return true;
  }, _isOutside: function(t2, e2, i3, s2, r3) {
    var o2 = 500, n2 = r3.canvasWidth, a2 = r3.canvasHeight;
    return !!(t2[1] < -500 && i3[1] < -500 || t2[2] < -500 && i3[2] < -500 || t2[1] > n2 + o2 && i3[1] > n2 + o2 || t2[2] > a2 + o2 && i3[2] > a2 + o2);
  }, _isOutsidePoint: function(t2, e2) {
    var i3 = 500, s2 = e2.canvasWidth, r3 = e2.canvasHeight;
    return !!(t2[1] < -500 || t2[2] < -500 || t2[1] > s2 + i3 || t2[2] > r3 + i3);
  }, _findStartPoint: function(t2, e2, i3, s2, r3) {
    return [e2, i3];
  }, _getBorderPos: function(t2, e2, s2, r3, n2, a2, h2) {
    var l2, d2, u2, p2, _2, f2;
    if (d2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false), p2 = 0, isNaN(s2[1] + s2[2]) && !isNaN(n2[1] + n2[2]))
      f2 = e2, _2 = r3;
    else if (isNaN(h2[1] + h2[2]) && !isNaN(n2[1] + n2[2]))
      f2 = a2, _2 = r3;
    else if (isNaN(n2[1] + n2[2]) && !isNaN(h2[1] + h2[2]))
      f2 = r3, _2 = a2;
    else {
      if (!isNaN(n2[1] + n2[2]) || isNaN(s2[1] + s2[2]))
        return false;
      f2 = r3, _2 = e2;
    }
    do {
      l2 = 0.5 * (_2 + f2), d2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(l2, true), t2.Y(l2, true)], false), u2 = d2.usrCoords, isNaN(u2[1] + u2[2]) ? f2 = l2 : _2 = l2, ++p2;
    } while (p2 < 30 && Math.abs(_2 - f2) > o.Z.eps);
    return l2;
  }, _getCuspPos: function(t2, e2, i3) {
    var s2 = [t2.X(e2, true), t2.Y(e2, true)], r3 = [t2.X(i3, true), t2.Y(i3, true)];
    return l.Z.fminbr(function(e3) {
      var i4 = [t2.X(e3, true), t2.Y(e3, true)];
      return -(Math.sqrt((s2[0] - i4[0]) * (s2[0] - i4[0]) + (s2[1] - i4[1]) * (s2[1] - i4[1])) + Math.sqrt((r3[0] - i4[0]) * (r3[0] - i4[0]) + (r3[1] - i4[1]) * (r3[1] - i4[1])));
    }, [e2, i3], t2);
  }, _getJumpPos: function(t2, e2, i3) {
    return l.Z.fminbr(function(e3) {
      var i4 = o.Z.eps * o.Z.eps, s2 = [t2.X(e3, true), t2.Y(e3, true)], r3 = [t2.X(e3 + i4, true), t2.Y(e3 + i4, true)];
      return -Math.abs((r3[1] - s2[1]) / (r3[0] - s2[0]));
    }, [e2, i3], t2);
  }, _getLimits: function(t2, e2) {
    var i3, s2, r3, o2, n2, h2 = 2 / (t2.maxX() - t2.minX());
    return s2 = (i3 = a.limit(e2, -h2, t2.X))[0], "infinite" === i3[1] && (s2 = Math.sign(s2) * (1 / 0)), o2 = (i3 = a.limit(e2, -h2, t2.Y))[0], "infinite" === i3[1] && (o2 = Math.sign(o2) * (1 / 0)), r3 = (i3 = a.limit(e2, h2, t2.X))[0], "infinite" === i3[1] && (r3 = Math.sign(r3) * (1 / 0)), n2 = (i3 = a.limit(e2, h2, t2.Y))[0], "infinite" === i3[1] && (n2 = Math.sign(n2) * (1 / 0)), { left_x: s2, left_y: o2, right_x: r3, right_y: n2, t: e2 };
  }, _getLimes: function(t2, e2, i3, s2, r3, o2, n2, a2, h2) {
    var l2;
    return "border" === a2 ? l2 = this._getBorderPos(t2, e2, i3, s2, r3, o2, n2) : "cusp" === a2 ? l2 = this._getCuspPos(t2, e2, o2) : "jump" === a2 && (l2 = this._getJumpPos(t2, e2, o2)), this._getLimits(t2, l2);
  }, _plotNonRecursive: function(t2, e2, i3, s2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2 = null, m2 = false, v2 = "", Z2 = [], C2 = 0;
    for (p2 = t2.board.origin.scrCoords, Z2[C2++] = [e2, i3, s2, r3, o2, 1 / 0]; C2 > 0; ) {
      if (e2 = (b2 = Z2[--C2])[0], i3 = b2[1], s2 = b2[2], r3 = b2[3], _2 = b2[4], f2 = b2[5], m2 = false, v2 = "", g2 = null, t2.points.length > 65536)
        return;
      if (_2 < this.nanLevel) {
        if (this._isUndefined(t2, e2, i3, s2, r3))
          continue;
        if (this._isOutside(e2, i3, s2, r3, t2.board))
          continue;
      }
      n2 = 0.5 * (i3 + r3), d2 = t2.X(n2, true), u2 = t2.Y(n2, true), a2 = [1, p2[1] + d2 * t2.board.unitX, p2[2] - u2 * t2.board.unitY], h2 = this._triangleDists(e2, s2, a2), l2 = isNaN(e2[1] + e2[2]), c2 = isNaN(s2[1] + s2[2]), l2 && !c2 || !l2 && c2 ? v2 = "border" : h2[0] > 0.66 * f2 || h2[0] < this.cusp_threshold * (h2[1] + h2[2]) || h2[1] > 5 * h2[2] || h2[2] > 5 * h2[1] ? v2 = "cusp" : (h2[2] > this.jump_threshold * h2[0] || h2[1] > this.jump_threshold * h2[0] || h2[0] === 1 / 0 || h2[1] === 1 / 0 || h2[2] === 1 / 0) && (v2 = "jump"), m2 = "" === v2 && _2 < this.smoothLevel && h2[3] < this.smooth_threshold, _2 < this.testLevel && !m2 && ("" === v2 ? m2 = true : g2 = this._getLimes(t2, i3, e2, n2, a2, r3, s2, v2, _2)), null !== g2 ? (a2 = [1, NaN, NaN], this._insertPoint(t2, a2, n2, _2, g2)) : _2 <= 0 || m2 ? this._insertPoint(t2, a2, n2, _2, null) : (Z2[C2++] = [a2, n2, s2, r3, _2 - 1, h2[0]], Z2[C2++] = [e2, i3, a2, n2, _2 - 1, h2[0]]);
    }
    return this;
  }, updateParametricCurve_v3: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, d2, u2, p2, _2 = false, f2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false), b2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], t2.board, false);
    return l2 = t2.board.updateQuality === t2.board.BOARD_QUALITY_LOW ? s.Z.evaluate(t2.visProp.recursiondepthlow) || 14 : s.Z.evaluate(t2.visProp.recursiondepthhigh) || 17, this.smoothLevel = 7, this.nanLevel = l2 - 4, this.testLevel = 4, this.cusp_threshold = 0.5, this.jump_threshold = 0.99, this.smooth_threshold = 2, t2.points = [], "x" === t2.xterm ? (d2 = 0.3 * ((u2 = t2.board.getBoundingBox())[2] - u2[0]), o2 = Math.max(e2, u2[0] - d2), n2 = Math.min(r3, u2[2] + d2)) : (o2 = e2, n2 = r3), f2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(o2, _2), t2.Y(o2, _2)], false), _2 = true, b2.setCoordinates(i2.Z.COORDS_BY_USER, [t2.X(n2, _2), t2.Y(n2, _2)], false), p2 = this._findStartPoint(t2, f2.scrCoords, o2, b2.scrCoords, n2), f2.setCoordinates(i2.Z.COORDS_BY_SCREEN, p2[0], false), o2 = p2[1], p2 = this._findStartPoint(t2, b2.scrCoords, n2, f2.scrCoords, o2), b2.setCoordinates(i2.Z.COORDS_BY_SCREEN, p2[0], false), n2 = p2[1], this._visibleArea = [o2, n2], a2 = f2.copy("scrCoords"), h2 = b2.copy("scrCoords"), f2._t = o2, t2.points.push(f2), this._lastScrCrds = f2.copy("scrCoords"), this._lastUsrCrds = f2.copy("usrCoords"), this._plotNonRecursive(t2, a2, o2, h2, n2, l2), b2._t = n2, t2.points.push(b2), t2.numberPoints = t2.points.length, t2;
  }, _criticalInterval: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2, l2, c2 = false, u2 = -1 / 0, p2 = false, _2 = false, f2 = 0, b2 = [], g2 = [], m2 = [];
    for (l2 = d.Z.abs(t2), (n2 = d.Z.median(l2)) < 1e-7 ? (n2 = 1e-7, p2 = true) : n2 *= this.criticalThreshold, s2 = 0; s2 < e2; s2++)
      l2[s2] > n2 ? (m2.push({ i: s2, v: t2[s2], group: f2 }), u2 = s2, c2 || (c2 = true)) : c2 && s2 > u2 + 4 && (m2.length > 0 && b2.push(m2.slice(0)), m2 = [], c2 = false, f2++);
    for (c2 && m2.length > 1 && b2.push(m2.slice(0)), p2 && 0 === b2.length && (_2 = true), r3 = 0; r3 < b2.length; r3++)
      if (g2[r3] = "point", !((o2 = b2[r3].length) < 64)) {
        for (h2 = 0, a2 = Math.sign(b2[r3][0].v), s2 = 1; s2 < o2; s2++)
          Math.sign(b2[r3][s2].v) !== a2 && (h2++, a2 = Math.sign(b2[r3][s2].v));
        6 * h2 > o2 && (g2[r3] = "interval");
      }
    return { smooth: _2, groups: b2, types: g2 };
  }, Component: function() {
    this.left_isNaN = false, this.right_isNaN = false, this.left_t = null, this.right_t = null, this.t_values = [], this.x_values = [], this.y_values = [], this.len = 0;
  }, findComponents: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2, h2, l2, c2 = [], d2 = 0, u2 = 0, p2 = 0, _2 = false, f2 = false;
    for (n2 = (i3 - e2) / s2, c2[d2] = new this.Component(), l2 = c2[d2], r3 = 0, o2 = e2; r3 <= s2; r3++, o2 += n2)
      a2 = t2.X(o2, f2), h2 = t2.Y(o2, f2), isNaN(a2) || isNaN(h2) ? ++p2 > 1 && _2 && (l2.right_isNaN = true, l2.right_t = o2 - n2, l2.len = u2, _2 = false, c2[++d2] = new this.Component(), l2 = c2[d2], p2 = 0) : (_2 || (_2 = true, u2 = 0, p2 > 0 && (l2.left_t = o2 - n2, l2.left_isNaN = true)), p2 = 0, l2.t_values[u2] = o2, l2.x_values[u2] = a2, l2.y_values[u2] = h2, u2++), 0 === r3 && (f2 = true);
    return _2 ? l2.len = u2 : c2.pop(), c2;
  }, getPointType: function(t2, e2, i3, s2, r3, o2, n2) {
    var a2 = r3[0], h2 = o2[0], l2 = s2.length, c2 = { idx: e2, t: i3, x: a2[e2], y: h2[e2], type: "other" };
    return e2 < 5 ? (c2.type = "borderleft", c2.idx = 0, c2.t = s2[0], c2.x = a2[0], c2.y = h2[0], c2) : e2 > n2 - 6 ? (c2.type = "borderright", c2.idx = l2 - 1, c2.t = s2[l2 - 1], c2.x = a2[l2 - 1], c2.y = h2[l2 - 1], c2) : c2;
  }, newtonApprox: function(t2, e2, i3, s2, r3) {
    var o2, n2 = 0;
    for (o2 = s2; o2 > 0; o2--)
      n2 = (n2 + r3[o2][t2]) * (e2 - (o2 - 1) * i3) / o2;
    return n2 + r3[0][t2];
  }, thiele: function(t2, e2, i3, s2, r3) {
    var o2, n2 = 0;
    for (o2 = r3; o2 > 1; o2--)
      n2 = (t2 - i3[s2 + o2]) / (e2[o2][s2 + 1] - e2[o2 - 2][s2 + 1] + n2);
    return e2[0][s2 + 1] + (t2 - i3[s2 + 1]) / (e2[1][s2 + 1] + n2);
  }, differenceMethodExperiments: function(t2, e2) {
    var i3, s2, r3, o2, n2, a2, h2, l2, c2, d2, u2, p2 = t2.t_values, _2 = t2.x_values, f2 = t2.y_values, b2 = [], g2 = [], m2 = [], v2 = [], Z2 = [], C2 = [], y2 = [], P2 = [], E2 = 0, O2 = [];
    for (n2 = p2[1] - p2[0], Z2.push([]), C2.push([]), y2.push([]), P2.push([]), r3 = f2.length, i3 = 0; i3 < r3; i3++)
      Z2[0][i3] = _2[i3], C2[0][i3] = f2[i3], y2[0][i3] = _2[i3], P2[0][i3] = f2[i3];
    for (Z2.push([]), C2.push([]), y2.push([]), P2.push([]), a2 = n2, r3 = f2.length - 1, i3 = 0; i3 < r3; i3++)
      b2[i3] = _2[i3 + 1] - _2[i3], g2[i3] = f2[i3 + 1] - f2[i3], m2[i3] = b2[i3], v2[i3] = g2[i3], Z2[1][i3] = b2[i3], C2[1][i3] = g2[i3], y2[1][i3] = a2 / b2[i3], P2[1][i3] = a2 / g2[i3];
    for (r3--, o2 = Math.min(8, f2.length - 1), s2 = 1; s2 < o2; s2++) {
      for (Z2.push([]), C2.push([]), y2.push([]), P2.push([]), a2 *= n2, i3 = 0; i3 < r3; i3++)
        b2[i3] = b2[i3 + 1] - b2[i3], g2[i3] = g2[i3 + 1] - g2[i3], Z2[s2 + 1][i3] = b2[i3], C2[s2 + 1][i3] = g2[i3], y2[s2 + 1][i3] = a2 / (y2[s2][i3 + 1] - y2[s2][i3]) + y2[s2 - 1][i3 + 1], P2[s2 + 1][i3] = a2 / (P2[s2][i3 + 1] - P2[s2][i3]) + P2[s2 - 1][i3 + 1];
      if (false === (u2 = this._criticalPoints(g2, r3, s2))) {
        console.log("Polynomial of degree", s2), u2 = [];
        break;
      }
      if (u2.length > 0 && ++E2 > 1 && s2 % 2 == 0)
        break;
      r3--;
    }
    for (i3 = 0; i3 < u2.length; i3++) {
      for (l2 = -1 / 0, c2 = 0; c2 < u2[i3].length; c2++)
        (d2 = Math.abs(u2[i3][c2].v)) > l2 && (l2 = d2, h2 = c2);
      h2 = Math.floor(u2[i3][h2].i + s2 / 2), O2.push(this.getPointType(e2, h2, p2, _2, f2, m2, v2, r3 + 1));
    }
    return [O2, Z2, C2, y2, P2];
  }, getCenterOfCriticalInterval: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2, h2 = 0, l2 = 0, c2 = i3[1] - i3[0], d2 = [];
    for (s2 = -1 / 0, d2 = [], r3 = 0; r3 < t2.length; r3++)
      (n2 = Math.abs(t2[r3].v)) > s2 ? (d2 = [r3], s2 = n2, o2 = r3) : s2 === n2 && d2.push(r3);
    if (d2.length > 0 && (a2 = d2.reduce(function(t3, e3) {
      return t3 + e3;
    }, 0) / d2.length, o2 = Math.floor(a2), a2 += t2[0].i), s2 < 1 / 0) {
      for (r3 = 0; r3 < t2.length; r3++)
        h2 += Math.abs(t2[r3].v) * t2[r3].i, l2 += Math.abs(t2[r3].v);
      a2 = h2 / l2;
    }
    return a2 += e2 / 2, [t2[o2].i + e2 / 2, a2, i3[Math.floor(a2)] + c2 * (a2 - Math.floor(a2))];
  }, differenceMethod: function(t2, e2) {
    var i3, s2, r3, o2, n2, a2, h2, l2, c2, d2, u2 = t2.t_values, p2 = t2.x_values, _2 = t2.y_values, f2 = [], b2 = [], g2 = 0, m2 = -1, v2 = -1, Z2 = [], C2 = [];
    for (r3 = _2.length, f2.push(new Float64Array(p2)), b2.push(new Float64Array(_2)), r3--, o2 = Math.min(12, r3), s2 = 0; s2 < o2 && (f2.push(new Float64Array(r3)), b2.push(new Float64Array(r3)), f2[s2 + 1] = f2[s2].map(function(t3, e3, i4) {
      return i4[e3 + 1] - t3;
    }), b2[s2 + 1] = b2[s2].map(function(t3, e3, i4) {
      return i4[e3 + 1] - t3;
    }), true === (l2 = this._criticalInterval(b2[s2 + 1], r3, s2)).smooth && (v2 = s2, Z2 = []), h2 = this._criticalInterval(f2[s2 + 1], r3, s2), -1 === m2 && true === h2.smooth && (m2 = s2), !(v2 >= 0)); s2++) {
      if (l2.groups.length > 0 && ++g2 > 2 && (s2 + 1) % 2 == 0) {
        Z2 = l2.groups, d2 = l2.types;
        break;
      }
      r3--;
    }
    for (i3 = 0; i3 < Z2.length; i3++)
      "interval" !== d2[i3] && (a2 = this.getCenterOfCriticalInterval(Z2[i3], s2 + 1, u2), l2[0], n2 = Math.floor(a2[1]), c2 = a2[2], C2.push(this.getPointType(e2, n2, c2, u2, f2, b2, r3 + 1)));
    return [C2, f2, b2, m2, v2];
  }, _insertPoint_v4: function(t2, e2, s2, r3) {
    var o2, n2, a2, h2 = null;
    t2.points.length > 0 && (h2 = t2.points[t2.points.length - 1].scrCoords), o2 = new c.Z(i2.Z.COORDS_BY_USER, e2, t2.board), null !== h2 && (n2 = o2.scrCoords[1] - h2[1]) * n2 + (a2 = o2.scrCoords[2] - h2[2]) * a2 < 0.8 * 0.8 || (o2._t = s2, t2.points.push(o2));
  }, getInterval: function(e2, i3, s2) {
    var r3, o2;
    return n.Z.disable(), r3 = n.Z.Interval(i3, s2), e2.board.mathLib = n.Z, e2.board.mathLibJXG = n.Z, e2.X(r3, true), o2 = e2.Y(r3, true), e2.board.mathLib = Math, e2.board.mathLibJXG = t.Z.Math, o2;
  }, sign: function(t2) {
    return t2 < 0 ? -1 : t2 > 0 ? 1 : 0;
  }, handleBorder: function(t2, e2, i3, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2 = i3.idx;
    if (g2 = e2.t_values[1] - e2.t_values[0], "borderleft" === i3.type ? h2 = (a2 = n2 = e2.left_isNaN ? e2.left_t : i3.t - g2) + g2 : "borderright" === i3.type ? a2 = (h2 = n2 = e2.right_isNaN ? e2.right_t : i3.t + g2) - g2 : console.log("No bordercase!!!"), 0 !== (f2 = this.findComponents(t2, a2, h2, 32)).length) {
      for ("borderleft" === i3.type && (a2 = f2[0].left_t, h2 = f2[0].t_values[0], g2 = f2[0].t_values[1] - f2[0].t_values[0], n2 = a2 = null === a2 ? h2 - g2 : a2, l2 = this.getInterval(t2, a2, h2), s.Z.isObject(l2) && (u2 = l2.lo, p2 = l2.hi, c2 = t2.X(n2, true), d2 = o2[1][m2] < 0 ? p2 : u2, this._insertPoint_v4(t2, [1, c2, d2], n2))), b2 = f2[0].t_values.length, _2 = 0; _2 < b2; _2++)
        n2 = f2[0].t_values[_2], c2 = f2[0].x_values[_2], d2 = f2[0].y_values[_2], this._insertPoint_v4(t2, [1, c2, d2], n2);
      "borderright" === i3.type && (a2 = f2[0].t_values[b2 - 1], h2 = f2[0].right_t, g2 = f2[0].t_values[1] - f2[0].t_values[0], n2 = h2 = null === h2 ? a2 + g2 : h2, l2 = this.getInterval(t2, a2, h2), s.Z.isObject(l2) && (u2 = l2.lo, p2 = l2.hi, c2 = t2.X(n2, true), d2 = o2[1][m2] > 0 ? p2 : u2, this._insertPoint_v4(t2, [1, c2, d2], n2)));
    }
  }, _seconditeration_v4: function(t2, e2, i3, s2, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2;
    for (n2 = e2.t_values[i3.idx - 2], a2 = e2.t_values[i3.idx + 2], l2 = this.findComponents(t2, n2, a2, 64), d2 = 0; d2 < l2.length; d2++) {
      for (c2 = l2[d2], u2 = (h2 = this.differenceMethod(c2, t2))[0], _2 = h2[1], f2 = h2[2], b2 = 0, p2 = 0; p2 <= u2.length; p2++) {
        for (g2 = p2 === u2.length ? c2.len : u2[p2].idx, o2 = b2; o2 < g2; o2++)
          isNaN(c2.x_values[o2]) || isNaN(c2.y_values[o2]) || this._insertPoint_v4(t2, [1, c2.x_values[o2], c2.y_values[o2]], c2.t_values[o2]);
        p2 < u2.length && (this.handleSingularity(t2, c2, u2[p2], _2, f2), b2 = u2[p2].idx + 1);
      }
      g2 = c2.len, d2 < l2.length - 1 && this._insertPoint_v4(t2, [1, NaN, NaN], c2.right_t);
    }
    return this;
  }, _recurse_v4: function(t2, e2, i3, s2, r3, o2, n2, a2) {
    var h2, l2, c2 = 0.5 * (e2 + i3), d2 = t2.X(c2, true), u2 = t2.Y(c2, true);
    0 !== a2 ? (h2 = (d2 - s2) * t2.board.unitX, l2 = (u2 - r3) * t2.board.unitY, Math.sqrt(h2 * h2 + l2 * l2) > 2 ? this._recurse_v4(t2, e2, c2, s2, r3, d2, u2, a2 - 1) : this._insertPoint_v4(t2, [1, d2, u2], c2), h2 = (d2 - o2) * t2.board.unitX, l2 = (u2 - n2) * t2.board.unitY, Math.sqrt(h2 * h2 + l2 * l2) > 2 ? this._recurse_v4(t2, c2, i3, d2, u2, o2, n2, a2 - 1) : this._insertPoint_v4(t2, [1, d2, u2], c2)) : this._insertPoint_v4(t2, [1, NaN, NaN], c2);
  }, handleSingularity: function(t2, e2, i3, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2 = i3.idx, m2 = 100;
    n2 = i3.t, console.log("HandleSingularity at t =", n2), a2 = e2.t_values[g2 - 5], h2 = e2.t_values[g2 + 5], l2 = this.getInterval(t2, a2, h2), s.Z.isObject(l2) ? (p2 = l2.lo, _2 = l2.hi) : o2[0][g2 - 1] < o2[0][g2 + 1] ? (p2 = o2[0][g2 - 1], _2 = o2[0][g2 + 1]) : (p2 = o2[0][g2 + 1], _2 = o2[0][g2 - 1]), u2 = t2.X(n2, true), f2 = (o2[0][g2 - 3] - o2[0][g2 - 5]) / (e2.t_values[g2 - 3] - e2.t_values[g2 - 5]), b2 = (o2[0][g2 + 3] - o2[0][g2 + 5]) / (e2.t_values[g2 + 3] - e2.t_values[g2 + 5]), console.log(":::", f2, b2), f2 < -100 ? (this._insertPoint_v4(t2, [1, u2, p2], n2, true), b2 <= m2 && this._insertPoint_v4(t2, [1, NaN, NaN], n2)) : f2 > m2 ? (this._insertPoint_v4(t2, [1, u2, _2], n2), b2 >= -100 && this._insertPoint_v4(t2, [1, NaN, NaN], n2)) : (p2 === -1 / 0 && (this._insertPoint_v4(t2, [1, u2, p2], n2, true), this._insertPoint_v4(t2, [1, NaN, NaN], n2)), _2 === 1 / 0 && (this._insertPoint_v4(t2, [1, NaN, NaN], n2), this._insertPoint_v4(t2, [1, u2, _2], n2, true)), i3.t < e2.t_values[g2] ? (c2 = g2 - 1, d2 = g2) : (c2 = g2, d2 = g2 + 1), a2 = e2.t_values[c2], h2 = e2.t_values[d2], this._recurse_v4(t2, a2, h2, r3[0][c2], o2[0][c2], r3[0][d2], o2[0][d2], 10)), b2 < -100 ? this._insertPoint_v4(t2, [1, u2, _2], n2) : b2 > m2 && this._insertPoint_v4(t2, [1, u2, p2], n2);
  }, steps: 1021, criticalThreshold: 1e3, plot_v4: function(t2, e2, i3, r3) {
    var o2, n2, a2, h2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2 = (i3 - e2) / r3, y2 = function(e3) {
      return t2.Y(e3, true);
    }, P2 = function(e3) {
      return -t2.Y(e3, true);
    }, E2 = 0.5 * C2;
    for (a2 = this.findComponents(t2, e2, i3, r3), h2 = 0; h2 < a2.length; h2++) {
      for (c2 = a2[h2], d2 = (_2 = this.differenceMethod(c2, t2))[0], f2 = _2[1], b2 = _2[2], _2[3], _2[4], 0 !== d2.length && "borderleft" === d2[0].type || d2.unshift({ idx: 0, t: c2.t_values[0], x: c2.x_values[0], y: c2.y_values[0], type: "borderleft" }), "borderright" !== d2[d2.length - 1].type && (n2 = c2.t_values.length, d2.push({ idx: n2 - 1, t: c2.t_values[n2 - 1], x: c2.x_values[n2 - 1], y: c2.y_values[n2 - 1], type: "borderright" })), p2 = 0, u2 = 0; u2 <= d2.length; u2++) {
        for (n2 = u2 === d2.length ? c2.len : d2[u2].idx - 1, o2 = p2; o2 < n2 - 2; o2++)
          this._insertPoint_v4(t2, [1, c2.x_values[o2], c2.y_values[o2]], c2.t_values[o2]), o2 >= p2 + 3 && o2 < n2 - 3 && b2.length > 3 && Math.abs(b2[2][o2]) > 0.2 * Math.abs(b2[0][o2]) ? (g2 = c2.t_values[o2], E2 = 0.25 * C2, Z2 = this.getInterval(t2, g2, g2 + C2), s.Z.isObject(Z2) ? b2[2][o2] > 0 ? this._insertPoint_v4(t2, [1, g2 + E2, Z2.lo], g2 + E2) : this._insertPoint_v4(t2, [1, g2 + C2 - E2, Z2.hi], g2 + C2 - E2) : (m2 = l.Z.fminbr(y2, [g2, g2 + C2])) < (v2 = l.Z.fminbr(P2, [g2, g2 + C2])) ? (this._insertPoint_v4(t2, [1, t2.X(m2, true), t2.Y(m2, true)], m2), this._insertPoint_v4(t2, [1, t2.X(v2, true), t2.Y(v2, true)], v2)) : (this._insertPoint_v4(t2, [1, t2.X(v2, true), t2.Y(v2, true)], v2), this._insertPoint_v4(t2, [1, t2.X(m2, true), t2.Y(m2, true)], m2))) : 0;
        u2 < d2.length && (o2 = d2[u2].idx, "borderleft" === d2[u2].type || "borderright" === d2[u2].type ? this.handleBorder(t2, c2, d2[u2], f2, b2) : this._seconditeration_v4(t2, c2, d2[u2], f2, b2), p2 = d2[u2].idx + 1 + 1);
      }
      n2 = c2.len, h2 < a2.length - 1 && this._insertPoint_v4(t2, [1, NaN, NaN], c2.right_t);
    }
  }, updateParametricCurve_v4: function(t2, e2, i3) {
    var s2, r3, o2, n2;
    "x" === t2.xterm ? (o2 = 0.3 * ((n2 = t2.board.getBoundingBox())[2] - n2[0]), s2 = Math.max(e2, n2[0] - o2), r3 = Math.min(i3, n2[2] + o2)) : (s2 = e2, r3 = i3), t2.points = [], this.plot_v4(t2, s2, r3, this.steps), t2.numberPoints = t2.points.length;
  }, updateParametricCurve: function(t2, e2, i3) {
    return this.updateParametricCurve_v2(t2, e2, i3);
  } };
  const p = o.Z.Plot;
  o.Z.Metapost = { MP_ENDPOINT: 0, MP_EXPLICIT: 1, MP_GIVEN: 2, MP_CURL: 3, MP_OPEN: 4, MP_END_CYCLE: 5, UNITY: 1, FRACTION_ONE: 1, FRACTION_THREE: 3, ONE_EIGHTY_DEG: Math.PI, THREE_SIXTY_DEG: 2 * Math.PI, EPS_SQ: 1e-5 * 1e-5, make_choices: function(t2) {
    var e2, i3, s2, r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2;
    a2 = t2[0];
    do {
      if (!a2)
        break;
      n2 = a2.next, a2.rtype > this.MP_EXPLICIT && (a2.x - n2.x) * (a2.x - n2.x) + (a2.y - n2.y) * (a2.y - n2.y) < this.EPS_SQ && (a2.rtype = this.MP_EXPLICIT, a2.ltype === this.MP_OPEN && (a2.ltype = this.MP_CURL, a2.set_left_curl(this.UNITY)), n2.ltype = this.MP_EXPLICIT, n2.rtype === this.MP_OPEN && (n2.rtype = this.MP_CURL, n2.set_right_curl(this.UNITY)), a2.rx = a2.x, n2.lx = a2.x, a2.ry = a2.y, n2.ly = a2.y), a2 = n2;
    } while (a2 !== t2[0]);
    for (i3 = t2[0]; i3.ltype === this.MP_OPEN && i3.rtype === this.MP_OPEN; )
      if ((i3 = i3.next) === t2[0]) {
        i3.ltype = this.MP_END_CYCLE;
        break;
      }
    for (a2 = i3; a2; ) {
      if (n2 = a2.next, a2.rtype >= this.MP_GIVEN) {
        for (; n2.ltype === this.MP_OPEN && n2.rtype === this.MP_OPEN; )
          n2 = n2.next;
        for (s2 = 0, h2 = a2, o2 = t2.length, u2 = [], p2 = [], _2 = [], f2 = [null]; c2 = h2.next, u2.push(c2.x - h2.x), p2.push(c2.y - h2.y), _2.push(this.mp_pyth_add(u2[s2], p2[s2])), s2 > 0 && (d2 = p2[s2 - 1] / _2[s2 - 1], l2 = u2[s2 - 1] / _2[s2 - 1], f2.push(Math.atan2(p2[s2] * l2 - u2[s2] * d2, u2[s2] * l2 + p2[s2] * d2))), s2++, (h2 = c2) === n2 && (o2 = s2), !(s2 >= o2 && h2.ltype !== this.MP_END_CYCLE); )
          ;
        s2 === o2 ? f2.push(0) : f2.push(f2[1]), n2.ltype === this.MP_OPEN && ((r3 = n2.rx - n2.x) * r3 + (e2 = n2.ry - n2.y) * e2 < this.EPS_SQ ? (n2.ltype = this.MP_CURL, n2.set_left_curl(this.UNITY)) : (n2.ltype = this.MP_GIVEN, n2.set_left_given(Math.atan2(e2, r3)))), a2.rtype === this.MP_OPEN && a2.ltype === this.MP_EXPLICIT && ((r3 = a2.x - a2.lx) * r3 + (e2 = a2.y - a2.ly) * e2 < this.EPS_SQ ? (a2.rtype = this.MP_CURL, a2.set_right_curl(this.UNITY)) : (a2.rtype = this.MP_GIVEN, a2.set_right_given(Math.atan2(e2, r3)))), this.mp_solve_choices(a2, n2, o2, u2, p2, _2, f2);
      } else
        a2.rtype === this.MP_ENDPOINT && (a2.rx = a2.x, a2.ry = a2.y, n2.lx = n2.x, n2.ly = n2.y);
      if ((a2 = n2) === i3)
        break;
    }
  }, mp_solve_choices: function(t2, e2, i3, s2, r3, o2, n2) {
    var a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2, S2, T2, M2, N2, A2;
    for (d2 = o2.length + 1, b2 = new Array(d2), f2 = new Array(d2), l2 = new Array(d2), C2 = new Array(d2), N2 = 0; N2 < d2; N2++)
      C2[N2] = l2[N2] = f2[N2] = b2[N2] = 0;
    for (p2 = 0, _2 = t2, m2 = 0; ; ) {
      if (v2 = _2.next, 0 === p2)
        if (_2.rtype === this.MP_GIVEN) {
          if (v2.ltype === this.MP_GIVEN)
            return a2 = Math.atan2(r3[0], s2[0]), x2 = (O2 = this.mp_n_sin_cos(t2.right_given() - a2))[0], w2 = O2[1], T2 = (S2 = this.mp_n_sin_cos(e2.left_given() - a2))[0], M2 = S2[1], void this.mp_set_controls(t2, e2, s2[0], r3[0], w2, x2, -M2, T2);
          l2[0] = _2.right_given() - Math.atan2(r3[0], s2[0]), l2[0] = this.reduce_angle(l2[0]), b2[0] = 0, f2[0] = 0;
        } else if (_2.rtype === this.MP_CURL) {
          if (v2.ltype === this.MP_CURL)
            return t2.rtype = this.MP_EXPLICIT, e2.ltype = this.MP_EXPLICIT, g2 = Math.abs(e2.left_tension()), y2 = Math.abs(t2.right_tension()), Z2 = this.UNITY / (3 * y2), t2.rx = t2.x + s2[0] * Z2, t2.ry = t2.y + r3[0] * Z2, Z2 = this.UNITY / (3 * g2), e2.lx = e2.x - s2[0] * Z2, void (e2.ly = e2.y - r3[0] * Z2);
          E2 = _2.right_curl(), g2 = Math.abs(v2.left_tension()), y2 = Math.abs(_2.right_tension()), b2[0] = this.mp_curl_ratio(E2, y2, g2), l2[0] = -n2[1] * b2[0], f2[0] = 0;
        } else
          _2.rtype === this.MP_OPEN && (b2[0] = 0, l2[0] = 0, f2[0] = this.FRACTION_ONE);
      else if (_2.ltype === this.MP_END_CYCLE || _2.ltype === this.MP_OPEN) {
        if (a2 = this.UNITY / (3 * Math.abs(m2.right_tension()) - this.UNITY), P2 = o2[p2] * (this.FRACTION_THREE - this.UNITY / Math.abs(m2.right_tension())), c2 = this.UNITY / (3 * Math.abs(v2.left_tension()) - this.UNITY), u2 = o2[p2 - 1] * (this.FRACTION_THREE - this.UNITY / Math.abs(v2.left_tension())), P2 *= E2 = this.FRACTION_ONE - b2[p2 - 1] * a2, (g2 = Math.abs(_2.left_tension())) < (y2 = Math.abs(_2.right_tension())) ? P2 *= Math.pow(g2 / y2, 2) : g2 > y2 && (u2 *= Math.pow(y2 / g2, 2)), Z2 = u2 / (u2 + P2), b2[p2] = Z2 * c2, h2 = -n2[p2 + 1] * b2[p2], m2.rtype === this.MP_CURL ? (f2[p2] = 0, l2[p2] = h2 - n2[1] * (this.FRACTION_ONE - Z2)) : (Z2 = (this.FRACTION_ONE - Z2) / E2, h2 -= n2[p2] * Z2, Z2 *= a2, l2[p2] = h2 - l2[p2 - 1] * Z2, f2[p2] = -f2[p2 - 1] * Z2), _2.ltype === this.MP_END_CYCLE) {
          for (a2 = 0, c2 = this.FRACTION_ONE; 0 === (p2 -= 1) && (p2 = i3), a2 = l2[p2] - a2 * b2[p2], c2 = f2[p2] - c2 * b2[p2], p2 !== i3; )
            ;
          for (a2 /= this.FRACTION_ONE - c2, C2[i3] = a2, l2[0] = a2, A2 = 1; A2 < i3; A2++)
            l2[A2] = l2[A2] + a2 * f2[A2];
          break;
        }
      } else {
        if (_2.ltype === this.MP_CURL) {
          E2 = _2.left_curl(), g2 = Math.abs(_2.left_tension()), y2 = Math.abs(m2.right_tension()), Z2 = this.mp_curl_ratio(E2, g2, y2), C2[i3] = -l2[i3 - 1] * Z2 / (this.FRACTION_ONE - Z2 * b2[i3 - 1]);
          break;
        }
        if (_2.ltype === this.MP_GIVEN) {
          C2[i3] = _2.left_given() - Math.atan2(r3[i3 - 1], s2[i3 - 1]), C2[i3] = this.reduce_angle(C2[i3]);
          break;
        }
      }
      m2 = _2, _2 = v2, p2 += 1;
    }
    for (p2 = i3 - 1; p2 > -1; p2--)
      C2[p2] = l2[p2] - C2[p2 + 1] * b2[p2];
    for (_2 = t2, p2 = 0; v2 = _2.next, x2 = (O2 = this.mp_n_sin_cos(C2[p2]))[0], w2 = O2[1], T2 = (S2 = this.mp_n_sin_cos(-n2[p2 + 1] - C2[p2 + 1]))[0], M2 = S2[1], this.mp_set_controls(_2, v2, s2[p2], r3[p2], w2, x2, M2, T2), _2 = v2, ++p2 !== i3; )
      ;
  }, mp_n_sin_cos: function(t2) {
    return [Math.cos(t2), Math.sin(t2)];
  }, mp_set_controls: function(t2, e2, i3, s2, r3, o2, n2, a2) {
    var h2, l2, c2, d2, u2;
    c2 = Math.abs(e2.left_tension()), h2 = Math.abs(t2.right_tension()), u2 = this.mp_velocity(r3, o2, n2, a2, h2), l2 = this.mp_velocity(n2, a2, r3, o2, c2), (t2.right_tension() < 0 || e2.left_tension() < 0) && (r3 >= 0 && n2 >= 0 || r3 <= 0 && n2 <= 0) && (d2 = Math.abs(r3) * a2 + Math.abs(n2) * o2) > 0 && (d2 *= 1.00024414062, t2.right_tension() < 0 && this.mp_ab_vs_cd(Math.abs(n2), this.FRACTION_ONE, u2, d2) < 0 && (u2 = Math.abs(n2) / d2), e2.left_tension() < 0 && this.mp_ab_vs_cd(Math.abs(r3), this.FRACTION_ONE, l2, d2) < 0 && (l2 = Math.abs(r3) / d2)), t2.rx = t2.x + (i3 * o2 - s2 * r3) * u2, t2.ry = t2.y + (s2 * o2 + i3 * r3) * u2, e2.lx = e2.x - (i3 * a2 + s2 * n2) * l2, e2.ly = e2.y - (s2 * a2 - i3 * n2) * l2, t2.rtype = this.MP_EXPLICIT, e2.ltype = this.MP_EXPLICIT;
  }, mp_pyth_add: function(t2, e2) {
    return Math.sqrt(t2 * t2 + e2 * e2);
  }, mp_curl_ratio: function(t2, e2, i3) {
    var s2 = 1 / e2, r3 = 1 / i3;
    return Math.min(4, ((3 - s2) * s2 * s2 * t2 + r3 * r3 * r3) / (s2 * s2 * s2 * t2 + (3 - r3) * r3 * r3));
  }, mp_ab_vs_cd: function(t2, e2, i3, s2) {
    return t2 * e2 == i3 * s2 ? 0 : t2 * e2 > i3 * s2 ? 1 : -1;
  }, mp_velocity: function(t2, e2, i3, s2, r3) {
    return Math.min(4, (2 + Math.sqrt(2) * (t2 - i3 / 16) * (i3 - t2 / 16) * (e2 - s2)) / (1.5 * r3 * (2 + (Math.sqrt(5) - 1) * e2 + (3 - Math.sqrt(5)) * s2)));
  }, reduce_angle: function(t2) {
    return Math.abs(t2) > this.ONE_EIGHTY_DEG && (t2 > 0 ? t2 -= this.THREE_SIXTY_DEG : t2 += this.THREE_SIXTY_DEG), t2;
  }, makeknots: function(t2, e2) {
    var i3, s2, r3 = [];
    for (s2 = t2.length, i3 = 0; i3 < s2; i3++)
      r3.push({ x: t2[i3][0], y: t2[i3][1], ltype: this.MP_OPEN, rtype: this.MP_OPEN, lx: false, rx: false, ly: e2, ry: e2, left_curl: function() {
        return this.lx || 0;
      }, right_curl: function() {
        return this.rx || 0;
      }, left_tension: function() {
        return this.ly || 1;
      }, right_tension: function() {
        return this.ry || 1;
      }, set_right_curl: function(t3) {
        this.rx = t3 || 0;
      }, set_left_curl: function(t3) {
        this.lx = t3 || 0;
      } });
    for (s2 = r3.length, i3 = 0; i3 < s2; i3++)
      r3[i3].next = r3[i3 + 1] || r3[i3], r3[i3].set_right_given = r3[i3].set_right_curl, r3[i3].set_left_given = r3[i3].set_left_curl, r3[i3].right_given = r3[i3].right_curl, r3[i3].left_given = r3[i3].left_curl;
    return r3[s2 - 1].next = r3[0], r3;
  }, curve: function(t2, e2) {
    var i3, r3, o2, n2, a2, h2, l2 = false, c2 = [], d2 = [];
    for (n2 in a2 = 1, (e2 = e2 || { tension: 1, direction: {}, curl: {}, isClosed: false }).hasOwnProperty("tension") && (a2 = s.Z.evaluate(e2.tension)), r3 = (i3 = this.makeknots(t2, a2)).length, s.Z.exists(e2.isClosed) && s.Z.evaluate(e2.isClosed) && (l2 = true), l2 || (i3[0].ltype = this.MP_ENDPOINT, i3[0].rtype = this.MP_CURL, i3[r3 - 1].rtype = this.MP_ENDPOINT, i3[r3 - 1].ltype = this.MP_CURL), e2)
      if (e2.hasOwnProperty(n2)) {
        if (o2 = parseInt(n2, 10), isNaN(o2) || o2 < 0 || o2 >= r3)
          continue;
        if (h2 = e2[o2], s.Z.exists(h2.type) && "curl" === h2.type)
          a2 = s.Z.evaluate(h2.curl), 0 === o2 ? (i3[o2].rtype = this.MP_CURL, i3[o2].set_right_curl(a2)) : o2 === r3 - 1 ? (i3[o2].ltype = this.MP_CURL, i3[o2].set_left_curl(a2)) : (i3[o2].ltype = this.MP_CURL, i3[o2].rtype = this.MP_CURL, i3[o2].lx = a2, i3[o2].rx = a2);
        s.Z.exists(h2.direction) && (a2 = s.Z.evaluate(h2.direction), s.Z.isArray(a2) ? (false !== a2[0] && (i3[o2].lx = a2[0] * Math.PI / 180, i3[o2].ltype = this.MP_GIVEN), false !== a2[1] && (i3[o2].rx = a2[1] * Math.PI / 180, i3[o2].rtype = this.MP_GIVEN)) : (i3[o2].lx = a2 * Math.PI / 180, i3[o2].rx = a2 * Math.PI / 180, i3[o2].ltype = i3[o2].rtype = this.MP_GIVEN)), s.Z.exists(h2.tension) && (a2 = s.Z.evaluate(h2.tension), s.Z.isArray(a2) ? (false !== a2[0] && (i3[o2].ly = s.Z.evaluate(a2[0])), false !== a2[1] && (i3[o2].ry = s.Z.evaluate(a2[1]))) : (i3[o2].ly = a2, i3[o2].ry = a2));
      }
    for (this.make_choices(i3), o2 = 0; o2 < r3 - 1; o2++)
      c2.push(i3[o2].x), c2.push(i3[o2].rx), c2.push(i3[o2 + 1].lx), d2.push(i3[o2].y), d2.push(i3[o2].ry), d2.push(i3[o2 + 1].ly);
    return c2.push(i3[r3 - 1].x), d2.push(i3[r3 - 1].y), l2 && (c2.push(i3[r3 - 1].rx), d2.push(i3[r3 - 1].ry), c2.push(i3[0].lx), d2.push(i3[0].ly), c2.push(i3[0].x), d2.push(i3[0].y)), [c2, d2];
  } };
  o.Z.Metapost;
  var _ = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255], f = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], b = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], g = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], m = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], v = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  t.Z.Util = t.Z.Util || {}, t.Z.Util.Unzip = function(e2) {
    var i3, s2, r3, o2, n2 = [], a2 = 0, h2 = [], l2 = new Array(32768), c2 = 0, d2 = false, u2 = e2.length, p2 = 0, Z2 = 1, C2 = new Array(288), y2 = new Array(32), P2 = 0, E2 = null, O2 = (new Array(64), new Array(64), 0), x2 = new Array(17), w2 = [];
    function S2() {
      return p2 < u2 ? e2[p2++] : -1;
    }
    function T2() {
      Z2 = 1;
    }
    function M2() {
      var t2;
      try {
        t2 = 1 & Z2, 0 === (Z2 >>= 1) && (t2 = 1 & (Z2 = S2()), Z2 = Z2 >> 1 | 128);
      } catch (t3) {
        throw console.log("Probably problems on iOS7 with >>"), t3;
      }
      return t2;
    }
    function N2(t2) {
      var e3 = 0, i4 = t2;
      try {
        for (; i4--; )
          e3 = e3 << 1 | M2();
        t2 && (e3 = _[e3] >> 8 - t2);
      } catch (t3) {
        throw console.log("Probably problems on iOS7 with >>"), t3;
      }
      return e3;
    }
    function A2() {
      c2 = 0;
    }
    function k2(t2) {
      l2[c2++] = t2, n2.push(String.fromCharCode(t2)), 32768 === c2 && (c2 = 0);
    }
    function R2() {
      this.b0 = 0, this.b1 = 0, this.jump = null, this.jumppos = -1;
    }
    function D2() {
      for (; ; ) {
        if (x2[O2] >= o2)
          return -1;
        if (r3[x2[O2]] === O2)
          return x2[O2]++;
        x2[O2]++;
      }
    }
    function L2() {
      var t2, e3 = E2[P2];
      if (17 === O2)
        return -1;
      if (P2++, O2++, (t2 = D2()) >= 0)
        e3.b0 = t2;
      else if (e3.b0 = 32768, L2())
        return -1;
      if ((t2 = D2()) >= 0)
        e3.b1 = t2, e3.jump = null;
      else if (e3.b1 = 32768, e3.jump = E2[P2], e3.jumppos = P2, L2())
        return -1;
      return O2--, 0;
    }
    function B2(t2, e3, i4, s3) {
      var n3;
      for (E2 = t2, P2 = 0, r3 = i4, o2 = e3, n3 = 0; n3 < 17; n3++)
        x2[n3] = 0;
      return O2 = 0, L2() ? -1 : 0;
    }
    function I2(t2) {
      for (var e3, i4, s3 = 0, r4 = t2[s3]; ; )
        if (M2()) {
          if (!(32768 & r4.b1))
            return r4.b1;
          for (r4 = r4.jump, e3 = t2.length, i4 = 0; i4 < e3; i4++)
            if (t2[i4] === r4) {
              s3 = i4;
              break;
            }
        } else {
          if (!(32768 & r4.b0))
            return r4.b0;
          r4 = t2[++s3];
        }
    }
    function Y2() {
      var e3, i4, s3, r4, o3, n3, a3, h3, d3, u3, p3, Z3, P3, E3, O3;
      do {
        if (e3 = M2(), 0 === (i4 = N2(2)))
          for (T2(), d3 = S2(), d3 |= S2() << 8, p3 = S2(), 65535 & (d3 ^ ~(p3 |= S2() << 8)) && t.Z.debug("BlockLen checksum mismatch\n"); d3--; )
            k2(S2());
        else if (1 === i4)
          for (; ; )
            if ((r4 = _[N2(7)] >> 1) > 23 ? (r4 = r4 << 1 | M2()) > 199 ? r4 = (r4 -= 128) << 1 | M2() : (r4 -= 48) > 143 && (r4 += 136) : r4 += 256, r4 < 256)
              k2(r4);
            else {
              if (256 === r4)
                break;
              for (h3 = N2(b[r4 -= 257]) + f[r4], r4 = _[N2(5)] >> 3, m[r4] > 8 ? (u3 = N2(8), u3 |= N2(m[r4] - 8) << 8) : u3 = N2(m[r4]), u3 += g[r4], r4 = 0; r4 < h3; r4++)
                k2(l2[c2 - u3 & 32767]);
            }
        else if (2 === i4) {
          for (n3 = new Array(320), P3 = 257 + N2(5), E3 = 1 + N2(5), O3 = 4 + N2(4), r4 = 0; r4 < 19; r4++)
            n3[r4] = 0;
          for (r4 = 0; r4 < O3; r4++)
            n3[v[r4]] = N2(3);
          for (h3 = y2.length, s3 = 0; s3 < h3; s3++)
            y2[s3] = new R2();
          if (B2(y2, 19, n3))
            return A2(), 1;
          for (Z3 = P3 + E3, s3 = 0, -1; s3 < Z3; )
            if ((r4 = I2(y2)) < 16)
              n3[s3++] = r4;
            else if (16 === r4) {
              if (s3 + (r4 = 3 + N2(2)) > Z3)
                return A2(), 1;
              for (o3 = s3 ? n3[s3 - 1] : 0; r4--; )
                n3[s3++] = o3;
            } else {
              if (s3 + (r4 = 17 === r4 ? 3 + N2(3) : 11 + N2(7)) > Z3)
                return A2(), 1;
              for (; r4--; )
                n3[s3++] = 0;
            }
          for (h3 = C2.length, s3 = 0; s3 < h3; s3++)
            C2[s3] = new R2();
          if (B2(C2, P3, n3))
            return A2(), 1;
          for (h3 = C2.length, s3 = 0; s3 < h3; s3++)
            y2[s3] = new R2();
          for (a3 = [], s3 = P3; s3 < n3.length; s3++)
            a3[s3 - P3] = n3[s3];
          if (B2(y2, E3, a3))
            return A2(), 1;
          for (; ; )
            if ((r4 = I2(C2)) >= 256) {
              if (0 === (r4 -= 256))
                break;
              for (h3 = N2(b[r4 -= 1]) + f[r4], r4 = I2(y2), m[r4] > 8 ? (u3 = N2(8), u3 |= N2(m[r4] - 8) << 8) : u3 = N2(m[r4]), u3 += g[r4]; h3--; )
                k2(l2[c2 - u3 & 32767]);
            } else
              k2(r4);
        }
      } while (!e3);
      return A2(), T2(), 0;
    }
    function j2() {
      var t2, e3, r4, o3, l3, c3 = [];
      try {
        if (n2 = [], d2 = false, c3[0] = S2(), c3[1] = S2(), 120 === c3[0] && 218 === c3[1] && (Y2(), h2[a2] = [n2.join(""), "geonext.gxt"], a2++), 31 === c3[0] && 139 === c3[1] && (X2(), h2[a2] = [n2.join(""), "file"], a2++), 80 === c3[0] && 75 === c3[1]) {
          if (d2 = true, c3[2] = S2(), c3[3] = S2(), 3 === c3[2] && 4 === c3[3]) {
            for (c3[0] = S2(), c3[1] = S2(), i3 = S2(), i3 |= S2() << 8, l3 = S2(), l3 |= S2() << 8, S2(), S2(), S2(), S2(), S2(), S2() << 8, S2() << 16, S2() << 24, S2(), S2() << 8, S2() << 16, S2() << 24, S2(), S2() << 8, S2() << 16, S2() << 24, o3 = S2(), o3 |= S2() << 8, r4 = S2(), r4 |= S2() << 8, t2 = 0, w2 = []; o3--; )
              "/" === (e3 = S2()) | ":" === e3 ? t2 = 0 : t2 < 255 && (w2[t2++] = String.fromCharCode(e3));
            for (s2 || (s2 = w2), t2 = 0; t2 < r4; )
              e3 = S2(), t2++;
            if (0, 8 === l3 && (Y2(), h2[a2] = new Array(2), h2[a2][0] = n2.join(""), h2[a2][1] = w2.join(""), a2++), X2())
              return false;
          }
          return true;
        }
      } catch (t3) {
        throw console.log("Probably problems on iOS7 with >>"), t3;
      }
      return false;
    }
    function X2() {
      var t2, e3, s3 = [];
      if (8 & i3 && (s3[0] = S2(), s3[1] = S2(), s3[2] = S2(), s3[3] = S2(), 80 === s3[0] && 75 === s3[1] && 7 === s3[2] && 8 === s3[3] ? (S2(), S2() << 8, S2() << 16, S2() << 24) : s3[0] | s3[1] << 8 | s3[2] << 16 | s3[3] << 24, S2(), S2() << 8, S2() << 16, S2() << 24, S2(), S2() << 8, S2() << 16, S2() << 24), d2 && j2())
        return false;
      if (s3[0] = S2(), 8 !== s3[0])
        return true;
      if (i3 = S2(), S2(), S2(), S2(), S2(), S2(), S2(), 4 & i3)
        for (s3[0] = S2(), s3[2] = S2(), O2 = s3[0] + 256 * s3[1], t2 = 0; t2 < O2; t2++)
          S2();
      if (8 & i3)
        for (t2 = 0, w2 = [], e3 = S2(); e3; )
          "7" !== e3 && ":" !== e3 || (t2 = 0), t2 < 255 && (w2[t2++] = e3), e3 = S2();
      if (16 & i3)
        for (e3 = S2(); e3; )
          e3 = S2();
      return 2 & i3 && (S2(), S2()), Y2(), S2(), S2() << 8, S2() << 16, S2() << 24, S2(), S2() << 8, S2() << 16, S2() << 24, d2 && j2(), false;
    }
    x2[0] = 0, t.Z.Util.Unzip.prototype.unzipFile = function(t2) {
      var e3;
      for (this.unzip(), e3 = 0; e3 < h2.length; e3++)
        if (h2[e3][1] === t2)
          return h2[e3][0];
      return "";
    }, t.Z.Util.Unzip.prototype.unzip = function() {
      return j2(), h2;
    };
  };
  const Z = t.Z.Util;
  var C = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 11, 6, 6, 6, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 12, 24, 36, 60, 96, 84, 12, 12, 12, 48, 72, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 12, 12, 12, 12, 12, 0, 12, 0, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12];
  t.Z.Util = t.Z.Util || {}, t.Z.Util.UTF8 = { encode: function(t2) {
    var e2, i3, s2 = "", r3 = t2.length;
    if (t2 = t2.replace(/\r\n/g, "\n"), "function" == typeof unescape && "function" == typeof encodeURIComponent)
      return unescape(encodeURIComponent(t2));
    for (e2 = 0; e2 < r3; e2++)
      (i3 = t2.charCodeAt(e2)) < 128 ? s2 += String.fromCharCode(i3) : i3 > 127 && i3 < 2048 ? (s2 += String.fromCharCode(i3 >> 6 | 192), s2 += String.fromCharCode(63 & i3 | 128)) : (s2 += String.fromCharCode(i3 >> 12 | 224), s2 += String.fromCharCode(i3 >> 6 & 63 | 128), s2 += String.fromCharCode(63 & i3 | 128));
    return s2;
  }, decode: function(t2) {
    var e2, i3, s2, r3 = 0, o2 = 0, n2 = 0, a2 = [], h2 = t2.length, l2 = [];
    for (e2 = 0; e2 < h2; e2++)
      i3 = t2.charCodeAt(e2), s2 = C[i3], o2 = 0 !== n2 ? 63 & i3 | o2 << 6 : 255 >> s2 & i3, 0 === (n2 = C[256 + n2 + s2]) && (o2 > 65535 ? a2.push(55232 + (o2 >> 10), 56320 + (1023 & o2)) : a2.push(o2), ++r3 % 1e4 == 0 && (l2.push(String.fromCharCode.apply(null, a2)), a2 = []));
    return l2.push(String.fromCharCode.apply(null, a2)), l2.join("");
  }, asciiCharCodeAt: function(t2, e2) {
    var i3 = t2.charCodeAt(e2);
    if (i3 > 255)
      switch (i3) {
        case 8364:
          i3 = 128;
          break;
        case 8218:
          i3 = 130;
          break;
        case 402:
          i3 = 131;
          break;
        case 8222:
          i3 = 132;
          break;
        case 8230:
          i3 = 133;
          break;
        case 8224:
          i3 = 134;
          break;
        case 8225:
          i3 = 135;
          break;
        case 710:
          i3 = 136;
          break;
        case 8240:
          i3 = 137;
          break;
        case 352:
          i3 = 138;
          break;
        case 8249:
          i3 = 139;
          break;
        case 338:
          i3 = 140;
          break;
        case 381:
          i3 = 142;
          break;
        case 8216:
          i3 = 145;
          break;
        case 8217:
          i3 = 146;
          break;
        case 8220:
          i3 = 147;
          break;
        case 8221:
          i3 = 148;
          break;
        case 8226:
          i3 = 149;
          break;
        case 8211:
          i3 = 150;
          break;
        case 8212:
          i3 = 151;
          break;
        case 732:
          i3 = 152;
          break;
        case 8482:
          i3 = 153;
          break;
        case 353:
          i3 = 154;
          break;
        case 8250:
          i3 = 155;
          break;
        case 339:
          i3 = 156;
          break;
        case 382:
          i3 = 158;
          break;
        case 376:
          i3 = 159;
      }
    return i3;
  } };
  const y = t.Z.Util.UTF8;
  var P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", E = "=";
  t.Z.Util = t.Z.Util || {}, t.Z.Util.Base64 = { _getByte: function(t2, e2) {
    return 255 & t2.charCodeAt(e2);
  }, _getIndex: function(t2, e2) {
    return P.indexOf(t2.charAt(e2));
  }, encode: function(t2) {
    var e2, i3, s2, r3, o2, n2 = [];
    for (r3 = (s2 = (o2 = y.encode(t2)).length) % 3, e2 = 0; e2 < s2 - r3; e2 += 3)
      i3 = this._getByte(o2, e2) << 16 | this._getByte(o2, e2 + 1) << 8 | this._getByte(o2, e2 + 2), n2.push(P.charAt(i3 >> 18), P.charAt(i3 >> 12 & 63), P.charAt(i3 >> 6 & 63), P.charAt(63 & i3));
    switch (r3) {
      case 1:
        i3 = this._getByte(o2, s2 - 1), n2.push(P.charAt(i3 >> 2), P.charAt(i3 << 4 & 63), E, E);
        break;
      case 2:
        i3 = this._getByte(o2, s2 - 2) << 8 | this._getByte(o2, s2 - 1), n2.push(P.charAt(i3 >> 10), P.charAt(i3 >> 4 & 63), P.charAt(i3 << 2 & 63), E);
    }
    return n2.join("");
  }, decode: function(t2, e2) {
    var i3, s2, r3, o2, n2, a2, h2 = [], l2 = [];
    if ((r3 = (i3 = t2.replace(/[^A-Za-z0-9+/=]/g, "")).length) % 4 != 0)
      throw new Error("JSXGraph/utils/base64: Can't decode string (invalid input length).");
    for (i3.charAt(r3 - 1) === E && (o2 = 1, i3.charAt(r3 - 2) === E && (o2 = 2), r3 -= 4), s2 = 0; s2 < r3; s2 += 4)
      n2 = this._getIndex(i3, s2) << 18 | this._getIndex(i3, s2 + 1) << 12 | this._getIndex(i3, s2 + 2) << 6 | this._getIndex(i3, s2 + 3), l2.push(n2 >> 16, n2 >> 8 & 255, 255 & n2), s2 % 1e4 == 0 && (h2.push(String.fromCharCode.apply(null, l2)), l2 = []);
    switch (o2) {
      case 1:
        n2 = this._getIndex(i3, r3) << 12 | this._getIndex(i3, r3 + 1) << 6 | this._getIndex(i3, r3 + 2), l2.push(n2 >> 10, n2 >> 2 & 255);
        break;
      case 2:
        n2 = this._getIndex(i3, s2) << 6 | this._getIndex(i3, s2 + 1), l2.push(n2 >> 4);
    }
    return h2.push(String.fromCharCode.apply(null, l2)), a2 = h2.join(""), e2 && (a2 = y.decode(a2)), a2;
  }, decodeAsArray: function(t2) {
    var e2, i3 = this.decode(t2), s2 = [], r3 = i3.length;
    for (e2 = 0; e2 < r3; e2++)
      s2[e2] = i3.charCodeAt(e2);
    return s2;
  } };
  const O = t.Z.Util.Base64;
  t.Z.Server = { modules: {}, runningCalls: {}, handleError: function(e2) {
    t.Z.debug("error occured, server says: " + e2.message);
  }, callServer: function(e2, i3, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2;
    for (d2 in o2 = o2 || false, r3)
      r3.hasOwnProperty(d2) && "&" + escape(d2) + "=" + escape(r3[d2]);
    c2 = s.Z.toJSON(r3);
    do {
      l2 = e2 + Math.floor(4096 * Math.random());
    } while (s.Z.exists(this.runningCalls[l2]));
    return this.runningCalls[l2] = { action: e2 }, s.Z.exists(r3.module) && (this.runningCalls[l2].module = r3.module), n2 = t.Z.serverBase + "JXGServer.py", a2 = "action=" + escape(e2) + "&id=" + l2 + "&dataJSON=" + escape(O.encode(c2)), this.cbp = function(t2) {
      var e3, r4, o3, n3, a3, h3, l3, c3;
      if (e3 = new Z.Unzip(O.decodeAsArray(t2)).unzip(), s.Z.isArray(e3) && e3.length > 0 && (e3 = e3[0][0]), s.Z.exists(e3)) {
        if ("error" === (r4 = window.JSON && window.JSON.parse ? window.JSON.parse(e3) : new Function("return " + e3)()).type)
          this.handleError(r4);
        else if ("response" === r4.type) {
          for (h3 = r4.id, l3 = 0; l3 < r4.fields.length; l3++)
            n3 = (o3 = r4.fields[l3]).namespace + ("object" == typeof new Function("return " + o3.namespace)() ? "." : ".prototype.") + o3.name + " = " + o3.value, new Function(n3)();
          for (l3 = 0; l3 < r4.handler.length; l3++) {
            for (o3 = r4.handler[l3], a3 = [], c3 = 0; c3 < o3.parameters.length; c3++)
              a3[c3] = '"' + o3.parameters[c3] + '": ' + o3.parameters[c3];
            n3 = "if(typeof JXG.Server.modules." + this.runningCalls[h3].module + ' == "undefined")JXG.Server.modules.' + this.runningCalls[h3].module + " = {};", n3 += "JXG.Server.modules." + this.runningCalls[h3].module + "." + o3.name + "_cb = " + o3.callback + ";", n3 += "JXG.Server.modules." + this.runningCalls[h3].module + "." + o3.name + " = function (" + o3.parameters.join(",") + ', __JXGSERVER_CB__, __JXGSERVER_SYNC) {if(typeof __JXGSERVER_CB__ == "undefined") __JXGSERVER_CB__ = JXG.Server.modules.' + this.runningCalls[h3].module + "." + o3.name + "_cb;var __JXGSERVER_PAR__ = {" + a3.join(",") + ', "module": "' + this.runningCalls[h3].module + '", "handler": "' + o3.name + '" };JXG.Server.callServer("exec", __JXGSERVER_CB__, __JXGSERVER_PAR__, __JXGSERVER_SYNC);};', new Function(n3)();
          }
          delete this.runningCalls[h3], i3(r4.data);
        }
      }
    }, this.cb = t.Z.bind(this.cbp, this), window.XMLHttpRequest ? (h2 = new XMLHttpRequest()).overrideMimeType("text/plain; charset=iso-8859-1") : h2 = new ActiveXObject("Microsoft.XMLHTTP"), !(!h2 || (h2.open("POST", n2, !o2), h2.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), o2 || (h2.onreadystatechange = (u2 = this.cb, function() {
      return 4 === h2.readyState && 200 === h2.status && (u2(h2.responseText), true);
    })), h2.send(a2), !o2)) && (this.cb(h2.responseText), true);
  }, loadModule_cb: function(e2) {
    var i3;
    for (i3 = 0; i3 < e2.length; i3++)
      t.Z.debug(e2[i3].name + ": " + e2[i3].value);
  }, loadModule: function(e2) {
    return t.Z.Server.callServer("load", t.Z.Server.loadModule_cb, { module: e2 }, true);
  } }, t.Z.Server.load = t.Z.Server.loadModule;
  const x = t.Z.Server;
  var w;
  o.Z.Symbolic = { generateSymbolicCoordinatesPartial: function(t2, e2, i3, r3) {
    var o2, n2, a2, h2 = e2.ancestors, l2 = 0, c2 = function(t3) {
      return "underscore" === r3 ? i3 + "_{" + t3 + "}" : "brace" === r3 ? i3 + "[" + t3 + "]" : i3 + t3;
    };
    for (n2 in t2.listOfFreePoints = [], t2.listOfDependantPoints = [], h2)
      if (h2.hasOwnProperty(n2) && (o2 = 0, s.Z.isPoint(h2[n2]))) {
        for (a2 in h2[n2].ancestors)
          h2[n2].ancestors.hasOwnProperty(a2) && o2++;
        0 === o2 ? (h2[n2].symbolic.x = h2[n2].coords.usrCoords[1], h2[n2].symbolic.y = h2[n2].coords.usrCoords[2], t2.listOfFreePoints.push(h2[n2])) : (l2 += 1, h2[n2].symbolic.x = c2(l2), l2 += 1, h2[n2].symbolic.y = c2(l2), t2.listOfDependantPoints.push(h2[n2]));
      }
    return s.Z.isPoint(e2) && (e2.symbolic.x = "x", e2.symbolic.y = "y"), l2;
  }, clearSymbolicCoordinates: function(t2) {
    var e2 = function(t3) {
      var e3, i3 = t3 && t3.length || 0;
      for (e3 = 0; e3 < i3; e3++)
        s.Z.isPoint(t3[e3]) && (t3[e3].symbolic.x = "", t3[e3].symbolic.y = "");
    };
    e2(t2.listOfFreePoints), e2(t2.listOfDependantPoints), delete t2.listOfFreePoints, delete t2.listOfDependantPoints;
  }, generatePolynomials: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2 = e2.ancestors, l2 = [], c2 = [];
    for (r3 in i3 && this.generateSymbolicCoordinatesPartial(t2, e2, "u", "brace"), h2[e2.id] = e2, h2)
      if (h2.hasOwnProperty(r3) && (a2 = 0, l2 = [], s.Z.isPoint(h2[r3]))) {
        for (o2 in h2[r3].ancestors)
          h2[r3].ancestors.hasOwnProperty(o2) && a2++;
        if (a2 > 0)
          for (l2 = h2[r3].generatePolynomial(), n2 = 0; n2 < l2.length; n2++)
            c2.push(l2[n2]);
      }
    return i3 && this.clearSymbolicCoordinates(t2), c2;
  }, geometricLocusByGroebnerBase: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2, m2, v2 = t2.options.locus, Z2 = {}, C2 = this.generateSymbolicCoordinatesPartial(t2, e2, "u", "brace"), y2 = new c.Z(i2.Z.COORDS_BY_USR, [0, 0], t2), P2 = new c.Z(i2.Z.COORDS_BY_USR, [t2.canvasWidth, t2.canvasHeight], t2), E2 = 1, O2 = 0, S2 = 0, T2 = 0;
    if (x.modules.geoloci === w && x.loadModule("geoloci"), x.modules.geoloci === w)
      throw new Error("JSXGraph: Unable to load JXG.Server module 'geoloci.py'.");
    if (d2 = y2.usrCoords[1], p2 = P2.usrCoords[1], _2 = P2.usrCoords[2], f2 = y2.usrCoords[2], v2.translateToOrigin && t2.listOfFreePoints.length > 0) {
      for (O2 = (a2 = v2.toOrigin !== w && null !== v2.toOrigin && s.Z.isInArray(t2.listOfFreePoints, v2.toOrigin.id) ? v2.toOrigin : t2.listOfFreePoints[0]).symbolic.x, S2 = a2.symbolic.y, l2 = 0; l2 < t2.listOfFreePoints.length; l2++)
        t2.listOfFreePoints[l2].symbolic.x -= O2, t2.listOfFreePoints[l2].symbolic.y -= S2;
      if (d2 -= O2, p2 -= O2, _2 -= S2, f2 -= S2, v2.translateTo10 && t2.listOfFreePoints.length > 1) {
        for (h2 = v2.to10 !== w && null !== v2.to10 && v2.to10.id !== v2.toOrigin.id && s.Z.isInArray(t2.listOfFreePoints, v2.to10.id) ? v2.to10 : t2.listOfFreePoints[0].id === a2.id ? t2.listOfFreePoints[1] : t2.listOfFreePoints[0], T2 = u.Z.rad([1, 0], [0, 0], [h2.symbolic.x, h2.symbolic.y]), b2 = Math.cos(-T2), g2 = Math.sin(-T2), l2 = 0; l2 < t2.listOfFreePoints.length; l2++)
          m2 = t2.listOfFreePoints[l2].symbolic.x, t2.listOfFreePoints[l2].symbolic.x = b2 * t2.listOfFreePoints[l2].symbolic.x - g2 * t2.listOfFreePoints[l2].symbolic.y, t2.listOfFreePoints[l2].symbolic.y = g2 * m2 + b2 * t2.listOfFreePoints[l2].symbolic.y;
        if (h2.symbolic.y = 0, m2 = d2, d2 = b2 * d2 - g2 * _2, _2 = g2 * m2 + b2 * _2, m2 = p2, p2 = b2 * p2 - g2 * f2, f2 = g2 * m2 + b2 * f2, v2.stretch && Math.abs(h2.symbolic.x) > o.Z.eps) {
          for (E2 = h2.symbolic.x, l2 = 0; l2 < t2.listOfFreePoints.length; l2++)
            t2.listOfFreePoints[l2].symbolic.x /= E2, t2.listOfFreePoints[l2].symbolic.y /= E2;
          for (l2 = 0; l2 < t2.objectsList.length; l2++)
            t2.objectsList[l2].elementClass === i2.Z.OBJECT_CLASS_CIRCLE && "pointRadius" === t2.objectsList[l2].method && (Z2[l2] = t2.objectsList[l2].radius, t2.objectsList[l2].radius /= E2);
          d2 /= E2, p2 /= E2, _2 /= E2, f2 /= E2, h2.symbolic.x = 1;
        }
      }
      for (l2 = 0; l2 < t2.listOfFreePoints.length; l2++)
        m2 = t2.listOfFreePoints[l2].symbolic.x, Math.abs(m2) < o.Z.eps && (t2.listOfFreePoints[l2].symbolic.x = 0), Math.abs(m2 - Math.round(m2)) < o.Z.eps && (t2.listOfFreePoints[l2].symbolic.x = Math.round(m2)), m2 = t2.listOfFreePoints[l2].symbolic.y, Math.abs(m2) < o.Z.eps && (t2.listOfFreePoints[l2].symbolic.y = 0), Math.abs(m2 - Math.round(m2)) < o.Z.eps && (t2.listOfFreePoints[l2].symbolic.y = Math.round(m2));
    }
    for (l2 in r3 = this.generatePolynomials(t2, e2).join(","), this.cbp = function(t3) {
      n2 = t3;
    }, this.cb = s.Z.bind(this.cbp, this), x.modules.geoloci.lociCoCoA(d2, p2, _2, f2, C2, r3, E2, T2, O2, S2, this.cb, true), this.clearSymbolicCoordinates(t2), Z2)
      Z2.hasOwnProperty(l2) && (t2.objects[l2].radius = Z2[l2]);
    return n2;
  } };
  const S = o.Z.Symbolic;
  o.Z.Clip = { _isSeparator: function(t2) {
    return isNaN(t2.coords.usrCoords[1]) && isNaN(t2.coords.usrCoords[2]);
  }, makeDoublyLinkedList: function(t2) {
    var e2, i3 = null, s2 = [], r3 = t2.length;
    if (r3 > 0)
      for (e2 = 0; e2 < r3; e2++)
        this._isSeparator(t2[e2]) ? (t2[e2]._next = t2[(e2 + 1) % r3], t2[e2]._prev = t2[(r3 + e2 - 1) % r3]) : (null === i3 && (i3 = e2, s2.push(i3)), this._isSeparator(t2[(e2 + 1) % r3]) || e2 === r3 - 1 ? (t2[e2]._next = t2[i3], t2[i3]._prev = t2[e2], t2[e2]._end = true, i3 = null) : (t2[e2]._next = t2[(e2 + 1) % r3], t2[i3]._prev = t2[e2]), this._isSeparator(t2[(r3 + e2 - 1) % r3]) || (t2[e2]._prev = t2[(r3 + e2 - 1) % r3]));
    return s2;
  }, Vertex: function(t2, e2, s2, r3, o2, n2) {
    this.pos = e2, this.intersection = true, this.coords = t2, this.elementClass = i2.Z.OBJECT_CLASS_POINT, this.data = { alpha: s2, path: r3, pathname: o2, done: false, type: n2, idx: 0 }, this.neighbour = null, this.entry_exit = false;
  }, _addToList: function(t2, e2, s2) {
    var r3 = t2.length, n2 = o.Z.eps * o.Z.eps;
    r3 > 0 && Math.abs(t2[r3 - 1].coords.usrCoords[0] - e2.usrCoords[0]) < n2 && Math.abs(t2[r3 - 1].coords.usrCoords[1] - e2.usrCoords[1]) < n2 && Math.abs(t2[r3 - 1].coords.usrCoords[2] - e2.usrCoords[2]) < n2 || t2.push({ pos: s2, intersection: false, coords: e2, elementClass: i2.Z.OBJECT_CLASS_POINT });
  }, sortIntersections: function(t2) {
    var e2, i3, s2, r3, o2, n2, a2 = [], h2 = t2.length;
    for (e2 = 0; e2 < h2; e2++)
      if (t2[e2].sort(function(t3, e3) {
        return t3.data.alpha > e3.data.alpha ? 1 : -1;
      }), t2[e2].length > 0) {
        for (o2 = t2[e2].length - 1, n2 = (r3 = (s2 = t2[e2][0]).data.path[s2.pos])._next, e2 === h2 - 1 && (r3._end = false), 0 === s2.data.alpha && "T" === s2.data.type ? (r3.intersection = true, r3.data = s2.data, r3.neighbour = s2.neighbour, r3.neighbour.neighbour = r3, r3.entry_exit = false, t2[e2][0] = r3) : (s2._prev = r3, s2._prev._next = s2), i3 = 1; i3 <= o2; i3++)
          (s2 = t2[e2][i3])._prev = t2[e2][i3 - 1], s2._prev._next = s2;
        (s2 = t2[e2][o2])._next = n2, s2._next._prev = s2, e2 === h2 - 1 && (s2._end = true), a2 = a2.concat(t2[e2]);
      }
    return a2;
  }, _inbetween: function(t2, e2, i3) {
    var s2, r3 = o.Z.eps * o.Z.eps, n2 = i3[1] - e2[1], a2 = i3[2] - e2[2], h2 = t2[1] - e2[1], l2 = t2[2] - e2[2];
    return 0 === n2 && 0 === a2 && 0 === h2 && 0 === l2 || (s2 = Math.abs(h2) < r3 && Math.abs(n2) < r3 ? l2 / a2 : h2 / n2, Math.abs(s2) < r3 && (s2 = 0), s2);
  }, _print_array: function(t2) {
    var e2, i3;
    for (e2 = 0; e2 < t2.length; e2++)
      try {
        i3 = "", t2[e2]._end && (i3 = " end"), console.log(e2, t2[e2].coords.usrCoords, t2[e2].data.type, "	", "prev", t2[e2]._prev.coords.usrCoords, "next", t2[e2]._next.coords.usrCoords + i3);
      } catch (i4) {
        console.log(e2, t2[e2].coords.usrCoords);
      }
  }, _print_list: function(t2) {
    for (var e2, i3 = 0; i3 < 100 && (e2 = t2.data ? t2.data.alpha : "-", console.log("	", t2.coords.usrCoords, "\n		is:", t2.intersection, "end:", t2._end, e2, "\n		-:", t2._prev.coords.usrCoords, "\n		+:", t2._next.coords.usrCoords, "\n		n:", t2.intersection ? t2.neighbour.coords.usrCoords : "-"), !t2._end); )
      t2 = t2._next, i3++;
  }, _noOverlap: function(t2, e2, i3, s2) {
    var r3, n2, a2, h2, l2, c2 = Math.sqrt(o.Z.eps), d2 = false;
    for (r3 = 0; r3 < 3; r3++)
      if (n2 = Math.min(t2[r3], e2[r3]), a2 = Math.max(t2[r3], e2[r3]), h2 = Math.min(i3[r3], s2[r3]), l2 = Math.max(i3[r3], s2[r3]), a2 < h2 - c2 || n2 > l2 + c2) {
        d2 = true;
        break;
      }
    return d2;
  }, findIntersections: function(t2, e2, s2) {
    var r3, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2, m2, v2, Z2 = [], C2 = 100 * o.Z.eps, y2 = t2.length, P2 = e2.length, E2 = [], O2 = [], x2 = [], w2 = false, S2 = false;
    for (n2 = 0; n2 < P2; n2++)
      x2.push([]);
    for (r3 = 0; r3 < y2; r3++)
      if (O2.push([]), this._isSeparator(t2[r3]) || this._isSeparator(t2[(r3 + 1) % y2]))
        w2 = true;
      else {
        if (w2 && r3 === y2 - 1)
          break;
        for (h2 = t2[r3].coords.usrCoords, l2 = t2[(r3 + 1) % y2].coords.usrCoords, n2 = 0; n2 < P2; n2++)
          if (this._isSeparator(e2[n2]) || this._isSeparator(e2[(n2 + 1) % P2]))
            S2 = true;
          else {
            if (S2 && n2 === P2 - 1)
              break;
            if (d2 = e2[n2].coords.usrCoords, p2 = e2[(n2 + 1) % P2].coords.usrCoords, !this._noOverlap(h2, l2, d2, p2) && (Z2 = u.Z.meetSegmentSegment(h2, l2, d2, p2), _2 = u.Z.distance(h2, l2, 3), f2 = u.Z.distance(d2, p2, 3), Z2[1] * _2 > -C2 && Z2[1] < 1 - C2 / _2 && Z2[2] * f2 > -C2 && Z2[2] < 1 - C2 / f2 || Z2[1] === 1 / 0 && Z2[2] === 1 / 0 && o.Z.norm(Z2[0], 3) < C2)) {
              if (a2 = new c.Z(i2.Z.COORDS_BY_USER, Z2[0], s2), g2 = "X", Math.abs(Z2[1]) * _2 < C2 || Math.abs(Z2[2]) * f2 < C2)
                g2 = "T", Math.abs(Z2[1]) * _2 < C2 && (Z2[1] = 0), Math.abs(Z2[2]) * f2 < C2 && (Z2[2] = 0), a2 = 0 === Z2[1] ? new c.Z(i2.Z.COORDS_BY_USER, h2, s2) : new c.Z(i2.Z.COORDS_BY_USER, d2, s2);
              else if (Z2[1] === 1 / 0 && Z2[2] === 1 / 0 && o.Z.norm(Z2[0], 3) < C2) {
                (b2 = this._inbetween(h2, d2, p2)) >= 0 && b2 < 1 && (g2 = "T", a2 = new c.Z(i2.Z.COORDS_BY_USER, h2, s2), Z2[1] = 0, Z2[2] = b2, m2 = new this.Vertex(a2, r3, Z2[1], t2, "S", g2), v2 = new this.Vertex(a2, n2, Z2[2], e2, "C", g2), m2.neighbour = v2, v2.neighbour = m2, O2[r3].push(m2), x2[n2].push(v2)), b2 = this._inbetween(d2, h2, l2), u.Z.distance(h2, d2, 3) > C2 && b2 >= 0 && b2 < 1 && (g2 = "T", a2 = new c.Z(i2.Z.COORDS_BY_USER, d2, s2), Z2[1] = b2, Z2[2] = 0, m2 = new this.Vertex(a2, r3, Z2[1], t2, "S", g2), v2 = new this.Vertex(a2, n2, Z2[2], e2, "C", g2), m2.neighbour = v2, v2.neighbour = m2, O2[r3].push(m2), x2[n2].push(v2));
                continue;
              }
              m2 = new this.Vertex(a2, r3, Z2[1], t2, "S", g2), v2 = new this.Vertex(a2, n2, Z2[2], e2, "C", g2), m2.neighbour = v2, v2.neighbour = m2, O2[r3].push(m2), x2[n2].push(v2);
            }
          }
      }
    for (E2 = this.sortIntersections(O2), r3 = 0; r3 < E2.length; r3++)
      E2[r3].data.idx = r3, E2[r3].neighbour.data.idx = r3;
    return [E2, this.sortIntersections(x2)];
  }, _getPosition: function(t2, e2, i3, s2) {
    var r3 = u.Z.det3p(t2, e2, i3), o2 = u.Z.det3p(t2, i3, s2);
    return u.Z.det3p(e2, i3, s2) >= 0 ? r3 >= 0 && o2 >= 0 ? "left" : "right" : r3 >= 0 || o2 >= 0 ? "left" : "right";
  }, _classifyDegenerateIntersections: function(t2) {
    var e2, i3, r3, n2, a2, h2, l2, c2, d2, p2, _2, f2, b2, g2;
    for (d2 = u.Z.det3p, l2 = 0, t2._tours = 0; ; ) {
      if (t2.intersection && "T" === t2.data.type && (e2 = t2._next.coords.usrCoords, i3 = t2._prev.coords.usrCoords, u.Z.distance(t2.coords.usrCoords, e2, 3) < o.Z.eps && (e2 = t2._next._next.coords.usrCoords), u.Z.distance(t2.coords.usrCoords, i3, 3) < o.Z.eps && (i3 = t2._prev._prev.coords.usrCoords), n2 = (a2 = t2.neighbour)._prev.coords.usrCoords, r3 = a2._next.coords.usrCoords, u.Z.distance(a2.coords.usrCoords, r3, 3) < o.Z.eps && (r3 = a2._next._next.coords.usrCoords), u.Z.distance(a2.coords.usrCoords, n2, 3) < o.Z.eps && (n2 = a2._prev._prev.coords.usrCoords), _2 = d2(t2.coords.usrCoords, i3, n2), f2 = d2(t2.coords.usrCoords, e2, r3), b2 = d2(t2.coords.usrCoords, i3, r3), g2 = d2(t2.coords.usrCoords, e2, n2), 0 === _2 && 0 === f2 && 0 === b2 && 0 === g2 && (t2.coords.usrCoords[1] *= 1 + Math.random() * o.Z.eps, t2.coords.usrCoords[2] *= 1 + Math.random() * o.Z.eps, a2.coords.usrCoords[1] = t2.coords.usrCoords[1], a2.coords.usrCoords[2] = t2.coords.usrCoords[2], _2 = d2(t2.coords.usrCoords, i3, n2), f2 = d2(t2.coords.usrCoords, e2, r3), b2 = d2(t2.coords.usrCoords, i3, r3), g2 = d2(t2.coords.usrCoords, e2, n2)), p2 = false, 0 === _2 ? u.Z.affineRatio(t2.coords.usrCoords, i3, n2) < 0 && (p2 = true) : 0 === f2 ? u.Z.affineRatio(t2.coords.usrCoords, e2, r3) < 0 && (p2 = true) : 0 === b2 ? u.Z.affineRatio(t2.coords.usrCoords, i3, r3) > 0 && (p2 = true) : 0 === g2 && u.Z.affineRatio(t2.coords.usrCoords, e2, n2) > 0 && (p2 = true), p2 && (c2 = n2, n2 = r3, r3 = c2, c2 = _2, _2 = b2, b2 = c2, c2 = f2, f2 = g2, g2 = c2), s.Z.exists(t2.delayedStatus) || (t2.delayedStatus = []), 0 === _2 && 0 === f2 ? t2.delayedStatus = ["on", "on"] : 0 === _2 ? (h2 = this._getPosition(e2, n2, a2.coords.usrCoords, r3), t2.delayedStatus = ["on", h2]) : 0 === f2 ? (h2 = this._getPosition(i3, n2, a2.coords.usrCoords, r3), t2.delayedStatus = [h2, "on"]) : 0 === t2.delayedStatus.length && (this._getPosition(i3, n2, a2.coords.usrCoords, r3) !== this._getPosition(e2, n2, a2.coords.usrCoords, r3) ? t2.data.type = "X" : t2.data.type = "B")), s.Z.exists(t2._tours) && t2._tours++, t2._tours > 3 || t2._end || l2 > 1e3) {
        l2 > 1e3 && console.log("Clipping: _classifyDegenerateIntersections exit"), s.Z.exists(t2._tours) && delete t2._tours;
        break;
      }
      t2.intersection && l2++, t2 = t2._next;
    }
  }, _handleIntersectionChains: function(t2) {
    var e2, i3 = 0, s2 = "Null", r3 = false, o2 = false, n2 = false;
    for (n2; true === t2.intersection && ("T" === t2.data.type && ("on" !== t2.delayedStatus[0] && "on" === t2.delayedStatus[1] ? (r3 = true, e2 = t2, s2 = t2.delayedStatus[0]) : r3 && "on" === t2.delayedStatus[0] && "on" === t2.delayedStatus[1] ? t2.data.type = "B" : r3 && "on" === t2.delayedStatus[0] && "on" !== t2.delayedStatus[1] && (r3 = false, s2 === t2.delayedStatus[1] ? (e2.data.type = "DB", t2.data.type = "DB") : (e2.data.type = "DX", t2.data.type = "DX"))), i3++), t2._end && (o2 = true), !o2 || r3; ) {
      if (i3 > 1e3) {
        console.log("Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations");
        break;
      }
      t2 = t2._next;
    }
  }, _handleFullyDegenerateCase: function(t2, e2, s2) {
    var r3, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2, m2, v2, Z2, C2 = [t2, e2];
    for (a2 = 0; a2 < 2; a2++) {
      for (b2 = (r3 = C2[a2]).length, _2 = 0, Z2 = true; _2 < b2; _2++)
        if (!r3[_2].intersection) {
          Z2 = false;
          break;
        }
      if (Z2)
        for (g2 = (n2 = C2[(a2 + 1) % 2]).length, _2 = 0; _2 < b2; _2++) {
          for (l2 = r3[_2].coords.usrCoords, d2 = r3[_2]._next.coords.usrCoords, h2 = [0.5 * (l2[0] + d2[0]), 0.5 * (l2[1] + d2[1]), 0.5 * (l2[2] + d2[2])], f2 = 0, m2 = false; f2 < g2; f2++)
            if (Math.abs(u.Z.det3p(n2[f2].coords.usrCoords, n2[(f2 + 1) % g2].coords.usrCoords, h2)) < o.Z.eps) {
              m2 = true;
              break;
            }
          if (!m2) {
            p2 = { pos: _2, intersection: false, coords: new c.Z(i2.Z.COORDS_BY_USER, h2, s2), elementClass: i2.Z.OBJECT_CLASS_POINT }, v2 = r3[_2]._next, r3[_2]._next = p2, p2._prev = r3[_2], p2._next = v2, v2._prev = p2, r3[_2]._end && (r3[_2]._end = false, p2._end = true);
            break;
          }
        }
    }
  }, _getStatus: function(t2, e2) {
    for (; t2.intersection && !t2._end; )
      t2 = t2._next;
    return [t2, 0 === u.Z.windingNumber(t2.coords.usrCoords, e2) ? "entry" : "exit"];
  }, markEntryExit: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2 = null, u2 = 0;
    for (l2 = i3.length, h2 = 0; h2 < l2; h2++)
      for (c2 = i3[h2], this._classifyDegenerateIntersections(t2[c2]), this._handleIntersectionChains(t2[c2]), o2 = (a2 = this._getStatus(t2[c2], e2))[0], r3 = a2[1], o2._starter = true, n2 = 0, d2 = null, u2 = 0; true === o2.intersection && ("X" === o2.data.type && 1 === u2 && (d2.entry_exit = r3, "exit" === r3 && (d2.data.type = "X"), u2 = 2), "X" !== o2.data.type && "DB" !== o2.data.type || (o2.entry_exit = r3, r3 = "entry" === r3 ? "exit" : "entry"), "DX" === o2.data.type && (0 === u2 ? (d2 = o2, u2 = 1) : 1 === u2 ? (o2.entry_exit = r3, d2.entry_exit = r3, "exit" === r3 ? d2.data.type = "X" : o2.data.type = "X", r3 = "entry" === r3 ? "exit" : "entry", d2 = null, u2 = 0) : 2 === u2 && (o2.entry_exit = r3, o2.data.type = "X", r3 = "entry" === r3 ? "exit" : "entry", d2 = null, u2 = 0))), o2 = o2._next, !(s.Z.exists(o2._starter) || n2 > 1e4); )
        n2++;
  }, _stayOnPath: function(t2, e2) {
    var i3 = true;
    return t2.intersection && "B" !== t2.data.type && (i3 = e2 === t2.entry_exit), i3;
  }, _addVertex: function(t2, e2, i3) {
    return isNaN(e2.coords.usrCoords[1]) || isNaN(e2.coords.usrCoords[2]) || t2.push(e2), e2.intersection && e2.data.done ? (i3 && console.log("Add last intersection point", e2.coords.usrCoords, "on", e2.data.pathname, e2.entry_exit, e2.data.type), true) : (e2.intersection && (e2.data.done = true, i3 && console.log("Add intersection point", e2.coords.usrCoords, "on", e2.data.pathname, e2.entry_exit, e2.data.type)), false);
  }, tracing: function(t2, e2, i3) {
    var s2, r3, o2, n2, a2 = 0, h2 = 1e4, l2 = 0, c2 = [], d2 = false, u2 = false;
    for (u2; l2 < e2.length && a2 < h2; )
      if ((o2 = e2[l2]).data.done || "X" !== o2.data.type)
        l2++;
      else {
        c2.length > 0 && c2.push([NaN, NaN]), n2 = o2.data.idx, s2 = t2, d2 = this._addVertex(c2, o2, u2), r3 = o2.entry_exit;
        do {
          if (d2)
            break;
          if ("intersection" === i3 && "entry" === o2.entry_exit || "union" === i3 && "exit" === o2.entry_exit || "difference" === i3 && s2 === t2 == ("exit" === o2.entry_exit)) {
            do {
              if (o2 = o2._next, d2 = this._addVertex(c2, o2, u2))
                break;
            } while (this._stayOnPath(o2, r3));
            a2++;
          } else {
            do {
              if (o2 = o2._prev, d2 = this._addVertex(c2, o2, u2))
                break;
            } while (this._stayOnPath(o2, r3));
            a2++;
          }
          if (d2)
            break;
          if (!o2.neighbour)
            return console.log("Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!", a2), [[0], [0]];
          if ((o2 = o2.neighbour).data.done)
            break;
          o2.data.done = true, r3 = o2.entry_exit, s2 = o2.data.path;
        } while (o2.data.idx !== n2 && a2 < h2);
        a2 >= h2 && console.log("Tracing: stopping an infinite loop!", a2), l2++;
      }
    return this._getCoordsArrays(c2, false);
  }, isEmptyCase: function(t2, e2, i3) {
    return "intersection" === i3 && (0 === t2.length || 0 === e2.length) || ("union" === i3 && 0 === t2.length && 0 === e2.length || "difference" === i3 && 0 === t2.length);
  }, _getCoordsArrays: function(t2, e2) {
    var i3, s2 = [], r3 = [], o2 = t2.length;
    for (i3 = 0; i3 < o2; i3++)
      t2[i3].coords ? (s2.push(t2[i3].coords.usrCoords[1]), r3.push(t2[i3].coords.usrCoords[2])) : (s2.push(t2[i3][0]), r3.push(t2[i3][1]));
    return e2 && o2 > 0 && (t2[0].coords ? (s2.push(t2[0].coords.usrCoords[1]), r3.push(t2[0].coords.usrCoords[2])) : (s2.push(t2[0][0]), r3.push(t2[0][1]))), [s2, r3];
  }, handleEmptyIntersection: function(t2, e2, i3) {
    var s2, r3, o2 = false, n2 = [];
    if (0 === t2.length)
      return n2 = "union" === i3 ? e2 : [], this._getCoordsArrays(n2, true);
    if (0 === e2.length)
      return n2 = "intersection" === i3 ? [] : t2, this._getCoordsArrays(n2, true);
    if (t2.length > 0)
      for (s2 = t2[0]; s2.intersection && !(s2 = s2._next)._end; )
        ;
    if (e2.length > 0)
      for (r3 = e2[0]; r3.intersection && !(r3 = r3._next)._end; )
        ;
    return 0 === u.Z.windingNumber(s2.coords.usrCoords, e2) ? 0 !== u.Z.windingNumber(r3.coords.usrCoords, t2) ? ("union" === i3 ? (n2 = n2.concat(t2)).push(t2[0]) : "difference" === i3 && ((n2 = n2.concat(t2)).push(t2[0]), u.Z.signedPolygon(t2) * u.Z.signedPolygon(e2) > 0 && n2.reverse(), n2.push([NaN, NaN])), "difference" !== i3 && "intersection" !== i3 || ((n2 = n2.concat(e2)).push(e2[0]), o2 = false)) : "difference" === i3 ? (n2 = n2.concat(t2), o2 = true) : "union" === i3 && ((n2 = n2.concat(t2)).push(t2[0]), n2.push([NaN, NaN]), (n2 = n2.concat(e2)).push(e2[0])) : "intersection" === i3 ? (n2 = n2.concat(t2), o2 = true) : "union" === i3 && (n2 = n2.concat(e2)).push(e2[0]), this._getCoordsArrays(n2, o2);
  }, _countCrossingIntersections: function(t2) {
    var e2, i3 = t2.length, s2 = 0;
    for (e2 = 0; e2 < i3; e2++)
      "X" === t2[e2].data.type && s2++;
    return s2;
  }, _getPath: function(t2, e2) {
    var r3, o2, n2, a2, h2, l2, d2, p2 = [];
    if (t2.elementClass !== i2.Z.OBJECT_CLASS_CURVE || t2.type !== i2.Z.OBJECT_TYPE_ARC && t2.type !== i2.Z.OBJECT_TYPE_SECTOR) {
      if (t2.elementClass === i2.Z.OBJECT_CLASS_CURVE && s.Z.exists(t2.points))
        for (o2 = t2.numberPoints, r3 = 0; r3 < o2; r3++)
          this._addToList(p2, t2.points[r3], r3);
      else if (t2.type === i2.Z.OBJECT_TYPE_POLYGON)
        for (r3 = 0; r3 < t2.vertices.length; r3++)
          this._addToList(p2, t2.vertices[r3].coords, r3);
      else if (t2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE)
        for (d2 = 359, n2 = t2.Radius(), a2 = 2 * Math.PI / d2, r3 = 0; r3 <= d2; r3++)
          this._addToList(p2, new c.Z(i2.Z.COORDS_BY_USER, [t2.center.coords.usrCoords[0], t2.center.coords.usrCoords[1] + Math.cos(r3 * a2) * n2, t2.center.coords.usrCoords[2] + Math.sin(r3 * a2) * n2], e2), r3);
      else if (s.Z.isArray(t2))
        for (o2 = t2.length, r3 = 0; r3 < o2; r3++)
          s.Z.exists(t2[r3].coords) ? this._addToList(p2, t2[r3].coords, r3) : s.Z.isArray(t2[r3]) ? this._addToList(p2, new c.Z(i2.Z.COORDS_BY_USER, t2[r3], e2), r3) : s.Z.exists(t2[r3].usrCoords) && this._addToList(p2, t2[r3], r3);
    } else {
      for (h2 = u.Z.rad(t2.radiuspoint, t2.center, t2.anglepoint), d2 = Math.floor(180 * h2 / Math.PI), n2 = t2.Radius(), a2 = h2 / d2, l2 = Math.atan2(t2.radiuspoint.coords.usrCoords[2] - t2.center.coords.usrCoords[2], t2.radiuspoint.coords.usrCoords[1] - t2.center.coords.usrCoords[1]), t2.type === i2.Z.OBJECT_TYPE_SECTOR && this._addToList(p2, t2.center.coords, 0), r3 = 0; r3 <= d2; r3++)
        this._addToList(p2, new c.Z(i2.Z.COORDS_BY_USER, [t2.center.coords.usrCoords[0], t2.center.coords.usrCoords[1] + Math.cos(r3 * a2 + l2) * n2, t2.center.coords.usrCoords[2] + Math.sin(r3 * a2 + l2) * n2], e2), r3 + 1);
      t2.type === i2.Z.OBJECT_TYPE_SECTOR && this._addToList(p2, t2.center.coords, d2 + 2);
    }
    return p2;
  }, greinerHormann: function(t2, e2, i3, s2) {
    var r3, n2, a2, h2, l2 = [], c2 = [];
    return (r3 = (l2 = this._getPath(t2, s2)).length) > 0 && u.Z.distance(l2[0].coords.usrCoords, l2[r3 - 1].coords.usrCoords, 3) < o.Z.eps && l2.pop(), (r3 = (c2 = this._getPath(e2, s2)).length) > 0 && u.Z.distance(c2[0].coords.usrCoords, c2[r3 - 1].coords.usrCoords, 3) < o.Z.eps * o.Z.eps && c2.pop(), this.isEmptyCase(l2, c2, i3) ? [[], []] : (a2 = this.makeDoublyLinkedList(l2), h2 = this.makeDoublyLinkedList(c2), n2 = this.findIntersections(l2, c2, s2)[0], this._handleFullyDegenerateCase(l2, c2, s2), this.markEntryExit(l2, c2, a2), this.markEntryExit(c2, l2, h2), 0 === this._countCrossingIntersections(n2) ? this.handleEmptyIntersection(l2, c2, i3) : this.tracing(l2, n2, i3));
  }, union: function(t2, e2, i3) {
    return this.greinerHormann(t2, e2, "union", i3);
  }, intersection: function(t2, e2, i3) {
    return this.greinerHormann(t2, e2, "intersection", i3);
  }, difference: function(t2, e2, i3) {
    return this.greinerHormann(t2, e2, "difference", i3);
  } }, t.Z.extend(o.Z.Clip, {});
  o.Z.Clip;
  o.Z.Poly = {}, o.Z.Poly.Ring = function(t2) {
    this.vars = t2;
  }, t.Z.extend(o.Z.Poly.Ring.prototype, {}), o.Z.Poly.Monomial = function(t2, e2, i3) {
    var r3;
    if (!s.Z.exists(t2))
      throw new Error("JSXGraph error: In JXG.Math.Poly.monomial missing parameter 'ring'.");
    for (s.Z.isArray(i3) || (i3 = []), r3 = (i3 = i3.slice(0, t2.vars.length)).length; r3 < t2.vars.length; r3++)
      i3.push(0);
    this.ring = t2, this.coefficient = e2 || 0, this.exponents = s.Z.deepCopy(i3);
  }, t.Z.extend(o.Z.Poly.Monomial.prototype, { copy: function() {
    return new o.Z.Poly.Monomial(this.ring, this.coefficient, this.exponents);
  }, print: function() {
    var t2, e2 = [];
    for (t2 = 0; t2 < this.ring.vars.length; t2++)
      e2.push(this.ring.vars[t2] + "^" + this.exponents[t2]);
    return this.coefficient + "*" + e2.join("*");
  } }), o.Z.Poly.Polynomial = function(t2, e2) {
    var i3;
    if (!s.Z.exists(t2))
      throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial missing parameter 'ring'.");
    i3 = s.Z.exists(e2) && s.Z.isString(e2) ? void 0 : [], this.ring = t2, this.monomials = i3;
  }, t.Z.extend(o.Z.Poly.Polynomial.prototype, { findSignature: function(t2) {
    var e2;
    for (e2 = 0; e2 < this.monomials.length; e2++)
      if (s.Z.cmpArrays(this.monomials[e2].exponents, t2))
        return e2;
    return -1;
  }, addSubMonomial: function(t2, e2) {
    var i3;
    (i3 = this.findSignature(t2.exponents)) > -1 ? this.monomials[i3].coefficient += e2 * t2.coefficient : (t2.coefficient *= e2, this.monomials.push(t2));
  }, add: function(t2) {
    var e2;
    if (!s.Z.exists(t2) || t2.ring !== this.ring)
      throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.add either summand is undefined or rings don't match.");
    if (s.Z.isArray(t2.exponents))
      this.addSubMonomial(t2, 1);
    else
      for (e2 = 0; e2 < t2.monomials.length; e2++)
        this.addSubMonomial(t2.monomials[e2], 1);
  }, sub: function(t2) {
    var e2;
    if (!s.Z.exists(t2) || t2.ring !== this.ring)
      throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.sub either summand is undefined or rings don't match.");
    if (s.Z.isArray(t2.exponents))
      this.addSubMonomial(t2, -1);
    else
      for (e2 = 0; e2 < t2.monomials.length; e2++)
        this.addSubMonomial(t2.monomials[e2], -1);
  }, copy: function() {
    var t2, e2;
    for (e2 = new o.Z.Poly.Polynomial(this.ring), t2 = 0; t2 < this.monomials.length; t2++)
      e2.monomials.push(this.monomials[t2].copy());
    return e2;
  }, print: function() {
    var t2, e2 = [];
    for (t2 = 0; t2 < this.monomials.length; t2++)
      e2.push("(" + this.monomials[t2].print() + ")");
    return e2.join("+");
  } });
  o.Z.Poly;
  t.Z.Complex = function(t2, e2) {
    this.isComplex = true, t2 && t2.isComplex && (e2 = t2.imaginary, t2 = t2.real), this.real = t2 || 0, this.imaginary = e2 || 0, this.absval = 0, this.angle = 0;
  }, t.Z.extend(t.Z.Complex.prototype, { toString: function() {
    return this.real + " + " + this.imaginary + "i";
  }, add: function(t2) {
    return s.Z.isNumber(t2) ? this.real += t2 : (this.real += t2.real, this.imaginary += t2.imaginary), this;
  }, sub: function(t2) {
    return s.Z.isNumber(t2) ? this.real -= t2 : (this.real -= t2.real, this.imaginary -= t2.imaginary), this;
  }, mult: function(t2) {
    var e2, i3;
    return s.Z.isNumber(t2) ? (this.real *= t2, this.imaginary *= t2) : (e2 = this.real, i3 = this.imaginary, this.real = e2 * t2.real - i3 * t2.imaginary, this.imaginary = e2 * t2.imaginary + i3 * t2.real), this;
  }, div: function(t2) {
    var e2, i3, r3;
    if (s.Z.isNumber(t2)) {
      if (Math.abs(t2) < Math.eps)
        return this.real = 1 / 0, this.imaginary = 1 / 0, this;
      this.real /= t2, this.imaginary /= t2;
    } else {
      if (Math.abs(t2.real) < Math.eps && Math.abs(t2.imaginary) < Math.eps)
        return this.real = 1 / 0, this.imaginary = 1 / 0, this;
      e2 = t2.real * t2.real + t2.imaginary * t2.imaginary, r3 = this.real, i3 = this.imaginary, this.real = (r3 * t2.real + i3 * t2.imaginary) / e2, this.imaginary = (i3 * t2.real - r3 * t2.imaginary) / e2;
    }
    return this;
  }, conj: function() {
    return this.imaginary *= -1, this;
  } }), t.Z.C = {}, t.Z.C.add = function(e2, i3) {
    var s2 = new t.Z.Complex(e2);
    return s2.add(i3), s2;
  }, t.Z.C.sub = function(e2, i3) {
    var s2 = new t.Z.Complex(e2);
    return s2.sub(i3), s2;
  }, t.Z.C.mult = function(e2, i3) {
    var s2 = new t.Z.Complex(e2);
    return s2.mult(i3), s2;
  }, t.Z.C.div = function(e2, i3) {
    var s2 = new t.Z.Complex(e2);
    return s2.div(i3), s2;
  }, t.Z.C.conj = function(e2) {
    var i3 = new t.Z.Complex(e2);
    return i3.conj(), i3;
  }, t.Z.C.abs = function(e2) {
    var i3 = new t.Z.Complex(e2);
    return i3.conj(), i3.mult(e2), Math.sqrt(i3.real);
  }, t.Z.Complex.C = t.Z.C;
  const T = t.Z.Complex;
  var M = __webpack_require__(766);
  t.Z.AbstractRenderer = function() {
    this.vOffsetText = 0, this.enhancedRendering = true, this.container = null, this.type = "", this.supportsForeignObject = false;
  }, t.Z.extend(t.Z.AbstractRenderer.prototype, { _updateVisual: function(t2, e2, i3) {
    (i3 || this.enhancedRendering) && (e2 = e2 || {}, this.setObjectTransition(t2), s.Z.evaluate(t2.visProp.draft) ? this.setDraft(t2) : (e2.stroke || (t2.highlighted ? (this.setObjectStrokeColor(t2, t2.visProp.highlightstrokecolor, t2.visProp.highlightstrokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.highlightstrokewidth)) : (this.setObjectStrokeColor(t2, t2.visProp.strokecolor, t2.visProp.strokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.strokewidth))), e2.fill || (t2.highlighted ? this.setObjectFillColor(t2, t2.visProp.highlightfillcolor, t2.visProp.highlightfillopacity) : this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity)), e2.dash || this.setDashStyle(t2, t2.visProp), e2.shadow || this.setShadow(t2), e2.gradient || this.setShadow(t2), e2.tabindex || this.setTabindex(t2)));
  }, _getHighlighted: function(t2) {
    var e2 = false;
    return s.Z.exists(t2.board) && s.Z.exists(t2.board.highlightedObjects) || (e2 = true), !e2 && s.Z.exists(t2.board.highlightedObjects[t2.id]) ? "highlight" : "";
  }, drawPoint: function(t2) {
    var e2, i3 = M.Z.normalizePointFace(s.Z.evaluate(t2.visProp.face));
    e2 = "o" === i3 ? "ellipse" : "[]" === i3 ? "rect" : "path", t2.rendNode = this.appendChildPrim(this.createPrim(e2, t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, e2), this._updateVisual(t2, { dash: true, shadow: true }, true), this.updatePoint(t2);
  }, updatePoint: function(t2) {
    var e2, i3 = s.Z.evaluate(t2.visProp.size), r3 = M.Z.normalizePointFace(s.Z.evaluate(t2.visProp.face)), o2 = s.Z.evaluate(t2.visProp.sizeunit), n2 = s.Z.evaluate(t2.visProp.zoom);
    isNaN(t2.coords.scrCoords[2] + t2.coords.scrCoords[1]) || ("user" === o2 && (i3 *= Math.sqrt(t2.board.unitX * t2.board.unitY)), e2 = 0 === (i3 *= t2.board && n2 ? Math.sqrt(t2.board.zoomX * t2.board.zoomY) : 1) ? 0 : i3 + 1, "o" === r3 ? this.updateEllipsePrim(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2], e2, e2) : "[]" === r3 ? this.updateRectPrim(t2.rendNode, t2.coords.scrCoords[1] - i3, t2.coords.scrCoords[2] - i3, 2 * i3, 2 * i3) : this.updatePathPrim(t2.rendNode, this.updatePathStringPoint(t2, i3, r3), t2.board), this._updateVisual(t2, { dash: false, shadow: false }), this.setShadow(t2));
  }, changePointStyle: function(t2) {
    var e2 = this.getElementById(t2.id);
    s.Z.exists(e2) && this.remove(e2), this.drawPoint(t2), s.Z.clearVisPropOld(t2), t2.visPropCalc.visible || this.display(t2, false), s.Z.evaluate(t2.visProp.draft) && this.setDraft(t2);
  }, drawLine: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("line", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "lines"), this.updateLine(t2);
  }, updateLine: function(t2) {
    this._updateVisual(t2), this.updatePathWithArrowHeads(t2), this.setLineCap(t2);
  }, drawCurve: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("path", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "path"), this.updateCurve(t2);
  }, updateCurve: function(t2) {
    this._updateVisual(t2), this.updatePathWithArrowHeads(t2), this.setLineCap(t2);
  }, updatePathWithArrowHeads: function(t2, e2) {
    var r3, o2, n2 = t2.visProp, a2 = e2 ? "highlight" : "";
    r3 = e2 && n2.highlightstrokewidth ? Math.max(s.Z.evaluate(n2.highlightstrokewidth), s.Z.evaluate(n2.strokewidth)) : s.Z.evaluate(n2.strokewidth), o2 = this.getArrowHeadData(t2, r3, a2), this.makeArrows(t2, o2), t2.elementClass === i2.Z.OBJECT_CLASS_LINE ? this.updateLineWithEndings(t2, o2) : t2.elementClass === i2.Z.OBJECT_CLASS_CURVE && this.updatePath(t2), this.setArrowSize(t2, o2);
  }, getArrowHeadData: function(t2, e2, r3) {
    var n2, a2, h2, l2, c2 = o.Z.eps, d2 = 0, u2 = 0, p2 = 0, _2 = 0, f2 = s.Z.evaluate(t2.visProp.firstarrow), b2 = s.Z.evaluate(t2.visProp.lastarrow);
    return (f2 || b2) && (n2 = s.Z.exists(f2.type) ? s.Z.evaluate(f2.type) : t2.elementClass === i2.Z.OBJECT_CLASS_LINE ? 1 : 7, a2 = s.Z.exists(b2.type) ? s.Z.evaluate(b2.type) : t2.elementClass === i2.Z.OBJECT_CLASS_LINE ? 1 : 7, f2 && (l2 = 6, s.Z.exists(f2.size) && (l2 = s.Z.evaluate(f2.size)), "" !== r3 && s.Z.exists(f2[r3 + "size"]) && (l2 = s.Z.evaluate(f2[r3 + "size"])), h2 = e2 * l2, 2 === n2 ? (h2 *= 0.5, c2 += e2 * l2) : 3 === n2 ? (h2 = e2 * l2 / 3, c2 += e2) : 4 === n2 || 5 === n2 || 6 === n2 ? (h2 = e2 * l2 / 1.5, c2 += e2 * l2) : 7 === n2 ? (h2 = 0, l2 = 10, c2 += e2) : c2 += e2 * l2, d2 += h2, p2 = l2), b2 && (l2 = 6, s.Z.exists(b2.size) && (l2 = s.Z.evaluate(b2.size)), "" !== r3 && s.Z.exists(b2[r3 + "size"]) && (l2 = s.Z.evaluate(b2[r3 + "size"])), h2 = e2 * l2, 2 === a2 ? (h2 *= 0.5, c2 += e2 * l2) : 3 === a2 ? (h2 = e2 * l2 / 3, c2 += e2) : 4 === a2 || 5 === a2 || 6 === a2 ? (h2 = e2 * l2 / 1.5, c2 += e2 * l2) : 7 === a2 ? (h2 = 0, l2 = 10, c2 += e2) : c2 += e2 * l2, u2 += h2, _2 = l2)), t2.visPropCalc.typeFirst = n2, t2.visPropCalc.typeLast = a2, { evFirst: f2, evLast: b2, typeFirst: n2, typeLast: a2, offFirst: d2, offLast: u2, sizeFirst: p2, sizeLast: _2, showFirst: 1, showLast: 1, minLen: c2, strokeWidth: e2 };
  }, updateLineWithEndings: function(t2, e2) {
    var r3, o2, n2;
    return r3 = new c.Z(i2.Z.COORDS_BY_USER, t2.point1.coords.usrCoords, t2.board), o2 = new c.Z(i2.Z.COORDS_BY_USER, t2.point2.coords.usrCoords, t2.board), n2 = s.Z.evaluate(t2.visProp.margin), u.Z.calcStraight(t2, r3, o2, n2), this.handleTouchpoints(t2, r3, o2, e2), this.getPositionArrowHead(t2, r3, o2, e2), this.updateLinePrim(t2.rendNode, r3.scrCoords[1], r3.scrCoords[2], o2.scrCoords[1], o2.scrCoords[2], t2.board), this;
  }, updatePath: function(t2) {
    return s.Z.evaluate(t2.visProp.handdrawing) ? this.updatePathPrim(t2.rendNode, this.updatePathStringBezierPrim(t2), t2.board) : this.updatePathPrim(t2.rendNode, this.updatePathStringPrim(t2), t2.board), this;
  }, getPositionArrowHead: function(t2, e2, s2, r3) {
    var o2, n2, a2, h2, l2;
    return (r3.evFirst || r3.evLast) && (n2 = a2 = h2 = l2 = 0, o2 = e2.distance(i2.Z.COORDS_BY_SCREEN, s2), r3.evFirst && "vml" !== t2.board.renderer.type && (o2 >= r3.minLen ? (n2 = (s2.scrCoords[1] - e2.scrCoords[1]) * r3.offFirst / o2, a2 = (s2.scrCoords[2] - e2.scrCoords[2]) * r3.offFirst / o2) : r3.showFirst = 0), r3.evLast && "vml" !== t2.board.renderer.type && (o2 >= r3.minLen ? (h2 = (s2.scrCoords[1] - e2.scrCoords[1]) * r3.offLast / o2, l2 = (s2.scrCoords[2] - e2.scrCoords[2]) * r3.offLast / o2) : r3.showLast = 0), e2.setCoordinates(i2.Z.COORDS_BY_SCREEN, [e2.scrCoords[1] + n2, e2.scrCoords[2] + a2], false, true), s2.setCoordinates(i2.Z.COORDS_BY_SCREEN, [s2.scrCoords[1] - h2, s2.scrCoords[2] - l2], false, true)), this;
  }, handleTouchpoints: function(t2, e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2;
    return (o2.evFirst || o2.evLast) && (h2 = l2 = c2 = d2 = u2 = 0, n2 = s.Z.evaluate(t2.point1.visProp.size) + s.Z.evaluate(t2.point1.visProp.strokewidth), a2 = s.Z.evaluate(t2.point2.visProp.size) + s.Z.evaluate(t2.point2.visProp.strokewidth), o2.evFirst && s.Z.evaluate(t2.visProp.touchfirstpoint) && (h2 = e2.distance(i2.Z.COORDS_BY_SCREEN, r3), l2 = (r3.scrCoords[1] - e2.scrCoords[1]) * n2 / h2, c2 = (r3.scrCoords[2] - e2.scrCoords[2]) * n2 / h2), o2.evLast && s.Z.evaluate(t2.visProp.touchlastpoint) && (h2 = e2.distance(i2.Z.COORDS_BY_SCREEN, r3), d2 = (r3.scrCoords[1] - e2.scrCoords[1]) * a2 / h2, u2 = (r3.scrCoords[2] - e2.scrCoords[2]) * a2 / h2), e2.setCoordinates(i2.Z.COORDS_BY_SCREEN, [e2.scrCoords[1] + l2, e2.scrCoords[2] + c2], false, true), r3.setCoordinates(i2.Z.COORDS_BY_SCREEN, [r3.scrCoords[1] - d2, r3.scrCoords[2] - u2], false, true)), this;
  }, setArrowSize: function(t2, e2) {
    return e2.evFirst && this._setArrowWidth(t2.rendNodeTriangleStart, e2.showFirst * e2.strokeWidth, t2.rendNode, e2.sizeFirst), e2.evLast && this._setArrowWidth(t2.rendNodeTriangleEnd, e2.showLast * e2.strokeWidth, t2.rendNode, e2.sizeLast), this;
  }, setLineCap: function(t2) {
  }, drawTicks: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("path", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "path");
  }, updateTicks: function(t2) {
  }, drawEllipse: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("ellipse", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "ellipse"), this.updateEllipse(t2);
  }, updateEllipse: function(t2) {
    this._updateVisual(t2);
    var e2 = t2.Radius();
    Math.abs(t2.center.coords.usrCoords[0]) > o.Z.eps && !isNaN(e2 + t2.center.coords.scrCoords[1] + t2.center.coords.scrCoords[2]) && e2 * t2.board.unitX < 2e6 && this.updateEllipsePrim(t2.rendNode, t2.center.coords.scrCoords[1], t2.center.coords.scrCoords[2], e2 * t2.board.unitX, e2 * t2.board.unitY);
  }, drawPolygon: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("polygon", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "polygon"), this.updatePolygon(t2);
  }, updatePolygon: function(t2) {
    this._updateVisual(t2, { stroke: true, dash: true }), this.updatePolygonPrim(t2.rendNode, t2);
  }, displayCopyright: function(t2, e2) {
  }, drawInternalText: function(t2) {
  }, updateInternalText: function(t2) {
  }, drawText: function(t2) {
    var i3, r3, o2, n2;
    "html" === s.Z.evaluate(t2.visProp.display) && e.Z.isBrowser && "no" !== this.type ? ((i3 = this.container.ownerDocument.createElement("div")).style.position = "absolute", i3.className = s.Z.evaluate(t2.visProp.cssclass), o2 = s.Z.evaluate(t2.visProp.layer), s.Z.exists(o2) || (o2 = 0), r3 = "" === this.container.style.zIndex ? 0 : parseInt(this.container.style.zIndex, 10), i3.style.zIndex = r3 + o2, this.container.appendChild(i3), i3.setAttribute("id", this.container.id + "_" + t2.id)) : i3 = this.drawInternalText(t2), t2.rendNode = i3, t2.htmlStr = "", t2.visProp.islabel && s.Z.exists(t2.visProp.anchor) ? (n2 = s.Z.evaluate(t2.visProp.anchor.visProp.visible), t2.prepareUpdate().updateVisibility(n2)) : t2.prepareUpdate().updateVisibility(), this.updateText(t2);
  }, updateText: function(i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2 = i3.plaintext;
    if (i3.visPropCalc.visible)
      if (this.updateTextStyle(i3, false), "html" === s.Z.evaluate(i3.visProp.display) && "no" !== this.type) {
        if (isNaN(i3.coords.scrCoords[1] + i3.coords.scrCoords[2]) || (o2 = i3.coords.scrCoords[1], o2 = Math.abs(o2) < 1e6 ? o2 : 1e6, r3 = "right" === (d2 = i3.getAnchorX()) ? i3.board.canvasWidth - o2 : "middle" === d2 ? o2 - 0.5 * i3.size[0] : o2, i3.visPropOld.left !== d2 + r3 && ("right" === d2 ? (i3.rendNode.style.right = r3 + "px", i3.rendNode.style.left = "auto") : (i3.rendNode.style.left = r3 + "px", i3.rendNode.style.right = "auto"), i3.visPropOld.left = d2 + r3), o2 = i3.coords.scrCoords[2] + this.vOffsetText, o2 = Math.abs(o2) < 1e6 ? o2 : 1e6, r3 = "bottom" === (u2 = i3.getAnchorY()) ? i3.board.canvasHeight - o2 : "middle" === u2 ? o2 - 0.5 * i3.size[1] : o2, i3.visPropOld.top !== u2 + r3 && ("bottom" === u2 ? (i3.rendNode.style.top = "auto", i3.rendNode.style.bottom = r3 + "px") : (i3.rendNode.style.bottom = "auto", i3.rendNode.style.top = r3 + "px"), i3.visPropOld.top = u2 + r3)), i3.htmlStr !== p2) {
          try {
            i3.type === s.Z.OBJECT_TYPE_BUTTON ? i3.rendNodeButton.innerHTML = p2 : i3.type === s.Z.OBJECT_TYPE_CHECKBOX || i3.type === s.Z.OBJECT_TYPE_INPUT ? i3.rendNodeLabel.innerHTML = p2 : i3.rendNode.innerHTML = p2;
          } catch (t2) {
            n2 = i3.rendNode.parentNode, i3.rendNode.parentNode.removeChild(i3.rendNode), i3.rendNode.innerHTML = p2, n2.appendChild(i3.rendNode);
          }
          if (i3.htmlStr = p2, s.Z.evaluate(i3.visProp.usemathjax))
            try {
              MathJax.typeset ? MathJax.typeset([i3.rendNode]) : MathJax.Hub.Queue(["Typeset", MathJax.Hub, i3.rendNode]), c2 = "fullscreenwrap_" + (l2 = i3.board.container), document.getElementById(c2) && (a2 = i3.board.containerObj._cssFullscreenStore.scale, h2 = i3.board.containerObj._cssFullscreenStore.vshift, e.Z.scaleJSXGraphDiv("#" + c2, "#" + l2, a2, h2));
            } catch (e2) {
              t.Z.debug("MathJax (not yet) loaded");
            }
          else if (s.Z.evaluate(i3.visProp.usekatex))
            try {
              katex.render(p2, i3.rendNode, { macros: s.Z.evaluate(i3.visProp.katexmacros), throwOnError: false });
            } catch (e2) {
              t.Z.debug("KaTeX not loaded (yet)");
            }
          else if (s.Z.evaluate(i3.visProp.useasciimathml))
            try {
              AMprocessNode(i3.rendNode, false);
            } catch (e2) {
              t.Z.debug("AsciiMathML not loaded (yet)");
            }
        }
        this.transformImage(i3, i3.transformations);
      } else
        this.updateInternalText(i3);
  }, _css2js: function(t2) {
    var e2, i3, r3, o2, n2, a2 = [], h2 = s.Z.trim(t2).replace(/;$/, "").split(";");
    for (i3 = h2.length, e2 = 0; e2 < i3; ++e2)
      "" !== s.Z.trim(h2[e2]) && (n2 = h2[e2].split(":"), r3 = s.Z.trim(n2[0].replace(/-([a-z])/gi, function(t3, e3) {
        return e3.toUpperCase();
      })), o2 = s.Z.trim(n2[1]), a2.push({ key: r3, val: o2 }));
    return a2;
  }, updateTextStyle: function(t2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2 = t2.visProp, _2 = e.Z.isBrowser ? p2.display : "internal", f2 = ["rendNode", "rendNodeTag", "rendNodeLabel"], b2 = f2.length, g2 = s.Z.evaluate(p2.fontunit), m2 = ["cssdefaultstyle", "cssstyle"], v2 = m2.length;
    if (i3 ? (n2 = p2.highlightstrokecolor, o2 = p2.highlightstrokeopacity, a2 = p2.highlightcssclass) : (n2 = p2.strokecolor, o2 = p2.strokeopacity, a2 = p2.cssclass), "no" !== this.type && ("html" === _2 || "canvas" !== this.type)) {
      for (d2 = 0; d2 < v2; d2++)
        if ("" !== (u2 = s.Z.evaluate(p2[(i3 ? "highlight" : "") + m2[d2]])) && t2.visPropOld[m2[d2]] !== u2) {
          for (l2 = this._css2js(u2), h2 = 0; h2 < b2; h2++)
            if (s.Z.exists(t2[f2[h2]]))
              for (c2 in l2)
                l2.hasOwnProperty(c2) && (t2[f2[h2]].style[l2[c2].key] = l2[c2].val);
          t2.visPropOld[m2[d2]] = u2;
        }
      if (r3 = s.Z.evaluate(p2.fontsize), t2.visPropOld.fontsize !== r3) {
        t2.needsSizeUpdate = true;
        try {
          for (h2 = 0; h2 < b2; h2++)
            s.Z.exists(t2[f2[h2]]) && (t2[f2[h2]].style.fontSize = r3 + g2);
        } catch (e2) {
          for (h2 = 0; h2 < b2; h2++)
            s.Z.exists(t2[f2[h2]]) && (t2[f2[h2]].style.fontSize = r3);
        }
        t2.visPropOld.fontsize = r3;
      }
    }
    return this.setTabindex(t2), this.setObjectTransition(t2), "html" === _2 && "no" !== this.type ? (t2.visPropOld.cssclass !== a2 && (t2.rendNode.className = a2, t2.visPropOld.cssclass = a2, t2.needsSizeUpdate = true), this.setObjectStrokeColor(t2, n2, o2)) : this.updateInternalTextStyle(t2, n2, o2), this;
  }, updateInternalTextStyle: function(t2, e2, i3) {
    this.setObjectStrokeColor(t2, e2, i3);
  }, drawImage: function(t2) {
  }, updateImage: function(t2) {
    this.updateRectPrim(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1], t2.size[0], t2.size[1]), this.updateImageURL(t2), this.transformImage(t2, t2.transformations), this._updateVisual(t2, { stroke: true, dash: true }, true);
  }, joinTransforms: function(t2, e2) {
    var i3, s2 = t2.board.origin.scrCoords[1], r3 = t2.board.origin.scrCoords[2], n2 = t2.board.unitX, a2 = t2.board.unitY, h2 = e2.length, l2 = [[1, 0, 0], [-s2 / n2, 1 / n2, 0], [r3 / a2, 0, -1 / a2]];
    for (i3 = 0; i3 < h2; i3++)
      l2 = o.Z.matMatMult(e2[i3].matrix, l2);
    return l2 = o.Z.matMatMult([[1, 0, 0], [s2, n2, 0], [r3, 0, -a2]], l2);
  }, transformImage: function(t2, e2) {
  }, updateImageURL: function(t2) {
  }, updateImageStyle: function(t2, e2) {
    t2.rendNode.className = s.Z.evaluate(e2 ? t2.visProp.highlightcssclass : t2.visProp.cssclass);
  }, drawForeignObject: function(t2) {
  }, updateForeignObject: function(t2) {
  }, appendChildPrim: function(t2, e2) {
  }, appendNodesToElement: function(t2, e2) {
  }, createPrim: function(t2, e2) {
    return null;
  }, remove: function(t2) {
  }, makeArrows: function(t2, e2) {
  }, _setArrowWidth: function(t2, e2, i3) {
  }, updateEllipsePrim: function(t2, e2, i3, s2, r3) {
  }, updateLinePrim: function(t2, e2, i3, s2, r3, o2) {
  }, updatePathPrim: function(t2, e2, i3) {
  }, updatePathStringPoint: function(t2, e2, i3) {
  }, updatePathStringPrim: function(t2) {
  }, updatePathStringBezierPrim: function(t2) {
  }, updatePolygonPrim: function(t2, e2) {
  }, updateRectPrim: function(t2, e2, i3, s2, r3) {
  }, setPropertyPrim: function(t2, e2, i3) {
  }, setTabindex: function(t2) {
    var e2;
    t2.board.attr.keyboard.enabled && s.Z.exists(t2.rendNode) && (e2 = s.Z.evaluate(t2.visProp.tabindex), t2.visPropCalc.visible && !s.Z.evaluate(t2.visProp.fixed) || (e2 = null), e2 !== t2.visPropOld.tabindex && (t2.rendNode.setAttribute("tabindex", e2), t2.visPropOld.tabindex = e2));
  }, display: function(t2, e2) {
    t2 && (t2.visPropOld.visible = e2);
  }, show: function(t2) {
  }, hide: function(t2) {
  }, setBuffering: function(t2, e2) {
  }, setDashStyle: function(t2) {
  }, setDraft: function(t2) {
    if (s.Z.evaluate(t2.visProp.draft)) {
      var e2 = t2.board.options.elements.draft.color, r3 = t2.board.options.elements.draft.opacity;
      this.setObjectTransition(t2), t2.type === i2.Z.OBJECT_TYPE_POLYGON ? this.setObjectFillColor(t2, e2, r3) : (t2.elementClass === i2.Z.OBJECT_CLASS_POINT ? this.setObjectFillColor(t2, e2, r3) : this.setObjectFillColor(t2, "none", 0), this.setObjectStrokeColor(t2, e2, r3), this.setObjectStrokeWidth(t2, t2.board.options.elements.draft.strokeWidth));
    }
  }, removeDraft: function(t2) {
    this.setObjectTransition(t2), t2.type === i2.Z.OBJECT_TYPE_POLYGON ? this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity) : (t2.type === i2.Z.OBJECT_CLASS_POINT && this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity), this.setObjectStrokeColor(t2, t2.visProp.strokecolor, t2.visProp.strokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.strokewidth));
  }, setGradient: function(t2) {
  }, updateGradient: function(t2) {
  }, setObjectTransition: function(t2, e2) {
  }, setObjectFillColor: function(t2, e2, i3) {
  }, setObjectStrokeColor: function(t2, e2, i3) {
  }, setObjectStrokeWidth: function(t2, e2) {
  }, setShadow: function(t2) {
  }, highlight: function(t2) {
    var e2, r3, o2 = t2.visProp;
    if (this.setObjectTransition(t2), !o2.draft) {
      if (t2.type === i2.Z.OBJECT_TYPE_POLYGON)
        for (this.setObjectFillColor(t2, o2.highlightfillcolor, o2.highlightfillopacity), e2 = 0; e2 < t2.borders.length; e2++)
          this.setObjectStrokeColor(t2.borders[e2], t2.borders[e2].visProp.highlightstrokecolor, t2.borders[e2].visProp.highlightstrokeopacity);
      else
        t2.elementClass === i2.Z.OBJECT_CLASS_TEXT ? this.updateTextStyle(t2, true) : t2.type === i2.Z.OBJECT_TYPE_IMAGE ? (this.updateImageStyle(t2, true), this.setObjectFillColor(t2, o2.highlightfillcolor, o2.highlightfillopacity)) : (this.setObjectStrokeColor(t2, o2.highlightstrokecolor, o2.highlightstrokeopacity), this.setObjectFillColor(t2, o2.highlightfillcolor, o2.highlightfillopacity));
      o2.highlightstrokewidth && (r3 = Math.max(s.Z.evaluate(o2.highlightstrokewidth), s.Z.evaluate(o2.strokewidth)), this.setObjectStrokeWidth(t2, r3), t2.elementClass !== i2.Z.OBJECT_CLASS_LINE && t2.elementClass !== i2.Z.OBJECT_CLASS_CURVE || this.updatePathWithArrowHeads(t2, true));
    }
    return this;
  }, noHighlight: function(t2) {
    var e2, r3, o2 = t2.visProp;
    if (this.setObjectTransition(t2), !s.Z.evaluate(t2.visProp.draft)) {
      if (t2.type === i2.Z.OBJECT_TYPE_POLYGON)
        for (this.setObjectFillColor(t2, o2.fillcolor, o2.fillopacity), e2 = 0; e2 < t2.borders.length; e2++)
          this.setObjectStrokeColor(t2.borders[e2], t2.borders[e2].visProp.strokecolor, t2.borders[e2].visProp.strokeopacity);
      else
        t2.elementClass === i2.Z.OBJECT_CLASS_TEXT ? this.updateTextStyle(t2, false) : t2.type === i2.Z.OBJECT_TYPE_IMAGE ? (this.updateImageStyle(t2, false), this.setObjectFillColor(t2, o2.fillcolor, o2.fillopacity)) : (this.setObjectStrokeColor(t2, o2.strokecolor, o2.strokeopacity), this.setObjectFillColor(t2, o2.fillcolor, o2.fillopacity));
      r3 = s.Z.evaluate(o2.strokewidth), this.setObjectStrokeWidth(t2, r3), t2.elementClass !== i2.Z.OBJECT_CLASS_LINE && t2.elementClass !== i2.Z.OBJECT_CLASS_CURVE || this.updatePathWithArrowHeads(t2, false);
    }
    return this;
  }, suspendRedraw: function() {
  }, unsuspendRedraw: function() {
  }, drawZoomBar: function(t2, i3) {
    var r3, o2, n2 = function(t3) {
      t3 || (t3 = window.event), t3.stopPropagation ? t3.stopPropagation() : t3.cancelBubble = true;
    }, a2 = function(i4, a3, h2) {
      var l2;
      h2 = h2 || "", (l2 = r3.createElement("span")).innerHTML = i4, l2.style.paddingLeft = "7px", l2.style.paddingRight = "7px", void 0 !== l2.classList && l2.classList.add("JXG_navigation_button"), l2.setAttribute("id", h2), o2.appendChild(l2), e.Z.addEvent(l2, "click", function(e2) {
        return s.Z.bind(a3, t2)(), false;
      }, t2), e.Z.addEvent(l2, "mouseup", n2, t2), e.Z.addEvent(l2, "mousedown", n2, t2), e.Z.addEvent(l2, "touchend", n2, t2), e.Z.addEvent(l2, "touchstart", n2, t2);
    };
    e.Z.isBrowser && "no" !== this.type && (r3 = t2.containerObj.ownerDocument, (o2 = r3.createElement("div")).setAttribute("id", t2.container + "_navigationbar"), o2.style.color = i3.strokecolor, o2.style.backgroundColor = i3.fillcolor, o2.style.padding = i3.padding, o2.style.position = i3.position, o2.style.fontSize = i3.fontsize, o2.style.cursor = i3.cursor, o2.style.zIndex = i3.zindex, t2.containerObj.appendChild(o2), o2.style.right = i3.right, o2.style.bottom = i3.bottom, void 0 !== o2.classList && o2.classList.add("JXG_navigation"), t2.attr.showfullscreen && a2(t2.attr.fullscreen.symbol, function() {
      t2.toFullscreen(t2.attr.fullscreen.id);
    }, t2.container + "_navigation_fullscreen"), t2.attr.showscreenshot && a2(t2.attr.screenshot.symbol, function() {
      window.setTimeout(function() {
        t2.renderer.screenshot(t2, "", false);
      }, 330);
    }, t2.container + "_navigation_screenshot"), t2.attr.showreload && a2("", function() {
      t2.reload();
    }, t2.container + "_navigation_reload"), t2.attr.showcleartraces && a2("", function() {
      t2.clearTraces();
    }, t2.container + "_navigation_cleartraces"), t2.attr.shownavigation && (t2.attr.showzoom && (a2("", t2.zoomOut, t2.container + "_navigation_out"), a2("o", t2.zoom100, t2.container + "_navigation_100"), a2("+", t2.zoomIn, t2.container + "_navigation_in")), a2("", t2.clickLeftArrow, t2.container + "_navigation_left"), a2("", t2.clickUpArrow, t2.container + "_navigation_down"), a2("", t2.clickDownArrow, t2.container + "_navigation_up"), a2("", t2.clickRightArrow, t2.container + "_navigation_right")));
  }, getElementById: function(t2) {
    var e2;
    return s.Z.exists(this.container) ? (e2 = this.container.id + "_" + t2, s.Z.exists(CSS) && s.Z.exists(CSS.escape) && (e2 = CSS.escape(e2)), this.container.querySelector("#" + e2)) : "";
  }, removeToInsertLater: function(t2) {
    var e2 = t2.parentNode, i3 = t2.nextSibling;
    if (null !== e2)
      return e2.removeChild(t2), function() {
        i3 ? e2.insertBefore(t2, i3) : e2.appendChild(t2);
      };
  }, resize: function(t2, e2) {
  }, createTouchpoints: function(t2) {
  }, showTouchpoint: function(t2) {
  }, hideTouchpoint: function(t2) {
  }, updateTouchpoint: function(t2, e2) {
  }, dumpToDataURI: function(t2) {
  }, dumpToCanvas: function(t2, e2, i3, s2) {
  }, screenshot: function(t2) {
  }, setLayer: function(t2, e2) {
  } });
  const N = t.Z.AbstractRenderer;
  t.Z.FileReader = { handleRemoteFile: function(e2, i3, r3, o2, n2, a2) {
    var h2 = false;
    try {
      h2 = new XMLHttpRequest(), "raw" === r3.toLowerCase() ? h2.overrideMimeType("text/plain; charset=" + n2) : h2.overrideMimeType("text/xml; charset=" + n2);
    } catch (t2) {
      try {
        h2 = new ActiveXObject("Msxml2.XMLHTTP");
      } catch (t3) {
        try {
          h2 = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (t4) {
          h2 = false;
        }
      }
    }
    if (h2) {
      h2.open("GET", e2, o2), "raw" === r3.toLowerCase() ? this.cbp = function() {
        var t2 = h2;
        4 === t2.readyState && i3(t2.responseText);
      } : this.cbp = function() {
        var t2 = h2, e3 = "";
        4 === t2.readyState && (e3 = !s.Z.exists(t2.responseStream) || "PK" !== t2.responseText.slice(0, 2) && 31 !== y.asciiCharCodeAt(t2.responseText.slice(0, 1), 0) ? t2.responseText : O.decode(jxgBinFileReader(t2)), this.parseString(e3, i3, r3, a2));
      }, this.cb = s.Z.bind(this.cbp, this), h2.onreadystatechange = this.cb;
      try {
        h2.send(null);
      } catch (t2) {
        throw new Error("JSXGraph: A problem occurred while trying to read remote file '" + e2 + "'.");
      }
    } else
      t.Z.debug("AJAX not activated!");
  }, handleLocalFile: function(t2, e2, i3, r3, o2, n2) {
    s.Z.exists(r3) || (r3 = true), "raw" === i3.toLowerCase() ? this.cbp = function(t3) {
      e2(t3.target.result);
    } : this.cbp = function(t3) {
      var s2 = t3.target.result;
      this.parseString(s2, e2, i3, n2);
    }, this.cb = s.Z.bind(this.cbp, this);
    var a2 = new FileReader();
    a2.onload = this.cb, "raw" === i3.toLowerCase() ? a2.readAsText(t2) : a2.readAsText(t2, o2);
  }, parseFileContent: function(t2, e2, i3, r3, o2, n2) {
    s.Z.isString(t2) || void 0 === FileReader ? this.handleRemoteFile(t2, e2, i3, r3, o2, n2) : this.handleLocalFile(t2, e2, i3, r3, o2, n2);
  }, parseString: function(e2, i3, r3, o2) {
    var n2;
    if (r3 = r3.toLowerCase(), n2 = t.Z.readers[r3], s.Z.exists(n2))
      new n2(i3, e2).read();
    else if ("jessiecode" !== r3)
      throw new Error("JSXGraph: There is no reader available for '" + r3 + "'.");
    s.Z.isFunction(o2) && o2(i3);
  } }, !e.Z.isMetroApp() && e.Z.isBrowser && "object" == typeof navigator && /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && document && document.write && document.write(`<script type="text/vbscript">
Function Base64Encode(inData)
  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  Dim cOut, sOut, I
  For I = 1 To LenB(inData) Step 3
    Dim nGroup, pOut, sGroup
    nGroup = &H10000 * AscB(MidB(inData, I, 1)) + _
      &H100 * MyASC(MidB(inData, I + 1, 1)) + MyASC(MidB(inData, I + 2, 1))
    nGroup = Oct(nGroup)
    nGroup = String(8 - Len(nGroup), "0") & nGroup
    pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
    sOut = sOut + pOut
  Next
  Select Case LenB(inData) Mod 3
    Case 1: '8 bit final
      sOut = Left(sOut, Len(sOut) - 2) + "=="
    Case 2: '16 bit final
      sOut = Left(sOut, Len(sOut) - 1) + "="
  End Select
  Base64Encode = sOut
End Function

Function MyASC(OneChar)
  If OneChar = "" Then MyASC = 0 Else MyASC = AscB(OneChar)
End Function

Function jxgBinFileReader(xhr)
    Dim byteString
    Dim b64String
    Dim i
    byteString = xhr.responseBody
    ReDim byteArray(LenB(byteString))
    For i = 1 To LenB(byteString)
        byteArray(i-1) = AscB(MidB(byteString, i, 1))
    Next
    b64String = Base64Encode(byteString)
    jxgBinFileReader = b64String
End Function
<\/script>
`);
  const A = t.Z.FileReader;
  var k = __webpack_require__(632), R = __webpack_require__(254), D = __webpack_require__(327);
  t.Z.Composition = function(t2) {
    var e2, i3 = this, r3 = ["setAttribute", "setParents", "prepareUpdate", "updateRenderer", "update", "fullUpdate", "highlight", "noHighlight"], o2 = function(t3) {
      return function() {
        var e3;
        for (e3 in i3.elements)
          i3.elements.hasOwnProperty(e3) && s.Z.exists(i3.elements[e3][t3]) && i3.elements[e3][t3].apply(i3.elements[e3], arguments);
        return i3;
      };
    };
    for (e2 = 0; e2 < r3.length; e2++)
      this[r3[e2]] = o2(r3[e2]);
    for (e2 in this.elements = {}, this.objects = this.elements, this.elementsByName = {}, this.objectsList = [], this.groups = {}, this.methodMap = { setAttribute: "setAttribute", setProperty: "setAttribute", setParents: "setParents", add: "add", remove: "remove", select: "select" }, t2)
      t2.hasOwnProperty(e2) && this.add(e2, t2[e2]);
    this.dump = true, this.subs = {};
  }, t.Z.extend(t.Z.Composition.prototype, { add: function(t2, e2) {
    return !(s.Z.exists(this[t2]) || !s.Z.exists(e2)) && (s.Z.exists(e2.id) ? this.elements[e2.id] = e2 : this.elements[t2] = e2, s.Z.exists(e2.name) && (this.elementsByName[e2.name] = e2), e2.on("attribute:name", this.nameListener, this), this.objectsList.push(e2), this[t2] = e2, this.methodMap[t2] = e2, true);
  }, remove: function(t2) {
    var e2, i3 = false;
    for (e2 in this.elements)
      if (this.elements.hasOwnProperty(e2) && this.elements[e2].id === this[t2].id) {
        i3 = true;
        break;
      }
    return i3 && (delete this.elements[this[t2].id], delete this[t2]), i3;
  }, nameListener: function(t2, e2, i3) {
    delete this.elementsByName[t2], this.elementsByName[e2] = i3;
  }, select: function(e2) {
    return s.Z.exists(t.Z.Board) ? t.Z.Board.prototype.select.call(this, e2) : new t.Z.Composition();
  }, getParents: function() {
    return this.parents;
  }, getType: function() {
    return this.elType;
  }, getAttributes: function() {
    var t2;
    for (t2 in this.subs)
      this.subs.hasOwnProperty(t2) && this.subs[t2].visProp;
    return this.attr;
  } });
  const L = t.Z.Composition;
  t.Z.Board = function(o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2) {
    if (this.BOARD_MODE_NONE = 0, this.BOARD_MODE_DRAG = 1, this.BOARD_MODE_MOVE_ORIGIN = 2, this.BOARD_MODE_ZOOM = 17, this.BOARD_QUALITY_LOW = 1, this.BOARD_QUALITY_HIGH = 2, s.Z.exists(f2.document) && false !== f2.document ? this.document = f2.document : e.Z.isBrowser && (this.document = document), this.container = o2, this.containerObj = e.Z.isBrowser ? this.document.getElementById(this.container) : null, e.Z.isBrowser && "no" !== n2.type && null === this.containerObj)
      throw new Error("\nJSXGraph: HTML container element '" + o2 + "' not found.");
    this.renderer = n2, this.grids = [], this.options = s.Z.deepCopy(M.Z), this.attr = f2, this.dimension = 2, this.jc = new R.Z(), this.jc.use(this), this.origin = {}, this.origin.usrCoords = [1, 0, 0], this.origin.scrCoords = [1, h2[0], h2[1]], this.zoomX = l2, this.zoomY = c2, this.unitX = d2 * this.zoomX, this.unitY = u2 * this.zoomY, this.keepaspectratio = false, this.canvasWidth = p2, this.canvasHeight = _2, s.Z.exists(a2) && "" !== a2 && e.Z.isBrowser && !s.Z.exists(this.document.getElementById(a2)) ? this.id = a2 : this.id = this.generateId(), r2.Z.eventify(this), this.hooks = [], this.dependentBoards = [], this.inUpdate = false, this.objects = {}, this.objectsList = [], this.groups = {}, this.animationObjects = {}, this.highlightedObjects = {}, this.numObjects = 0, this.elementsByName = {}, this.mode = this.BOARD_MODE_NONE, this.updateQuality = this.BOARD_QUALITY_HIGH, this.isSuspendedRedraw = false, this.calculateSnapSizes(), this.drag_dx = 0, this.drag_dy = 0, this.drag_position = [0, 0], this.mouse = {}, this.touches = [], this.xmlString = "", this.cPos = [], this.touchMoveLast = 0, this.touchMoveLastId = 1 / 0, this.positionAccessLast = 0, this.downObjects = [], this.focusObjects = [], this.attr.showcopyright && this.renderer.displayCopyright(i2.Z.licenseText, parseInt(this.options.text.fontSize, 10)), this.needsFullUpdate = false, this.reducedUpdate = false, this.currentCBDef = "none", this.geonextCompatibilityMode = false, this.options.text.useASCIIMathML && translateASCIIMath ? init() : this.options.text.useASCIIMathML = false, this.hasMouseHandlers = false, this.hasTouchHandlers = false, this.hasPointerHandlers = false, this.hasMouseUp = false, this.hasTouchEnd = false, this.hasPointerUp = false, this._drag_offset = [0, 0], this._inputDevice = "mouse", this._board_touches = [], this.selectingMode = false, this.isSelecting = false, this._isScrolling = false, this._isResizing = false, this.selectingBox = [[0, 0], [0, 0]], this.userLog = [], this.mathLib = Math, this.mathLibJXG = t.Z.Math, this.attr.registerevents && this.addEventHandlers(), this.attr.registerresizeevent && this.addResizeEventHandlers(), this.attr.registerfullscreenevent && this.addFullscreenEventHandlers(), this.methodMap = { update: "update", fullUpdate: "fullUpdate", on: "on", off: "off", trigger: "trigger", setView: "setBoundingBox", setBoundingBox: "setBoundingBox", migratePoint: "migratePoint", colorblind: "emulateColorblindness", suspendUpdate: "suspendUpdate", unsuspendUpdate: "unsuspendUpdate", clearTraces: "clearTraces", left: "clickLeftArrow", right: "clickRightArrow", up: "clickUpArrow", down: "clickDownArrow", zoomIn: "zoomIn", zoomOut: "zoomOut", zoom100: "zoom100", zoomElements: "zoomElements", remove: "removeObject", removeObject: "removeObject" };
  }, t.Z.extend(t.Z.Board.prototype, { generateName: function(t2) {
    var e2, r3, o2 = this.attr.maxnamelength, n2 = "", a2 = "", h2 = [], l2 = "";
    if (t2.type === i2.Z.OBJECT_TYPE_TICKS)
      return "";
    for (e2 = s.Z.isPoint(t2) || s.Z.isPoint3D(t2) ? ["", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"] : t2.type === i2.Z.OBJECT_TYPE_ANGLE ? ["", "&alpha;", "&beta;", "&gamma;", "&delta;", "&epsilon;", "&zeta;", "&eta;", "&theta;", "&iota;", "&kappa;", "&lambda;", "&mu;", "&nu;", "&xi;", "&omicron;", "&pi;", "&rho;", "&sigma;", "&tau;", "&upsilon;", "&phi;", "&chi;", "&psi;", "&omega;"] : ["", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], s.Z.isPoint(t2) || t2.elementClass === i2.Z.OBJECT_CLASS_LINE || t2.type === i2.Z.OBJECT_TYPE_ANGLE || (n2 = t2.type === i2.Z.OBJECT_TYPE_POLYGON ? "P_{" : t2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE ? "k_{" : t2.elementClass === i2.Z.OBJECT_CLASS_TEXT ? "t_{" : "s_{", a2 = "}"), r3 = 0; r3 < o2; r3++)
      h2[r3] = 0;
    for (; h2[o2 - 1] < e2.length; ) {
      for (h2[0] = 1; h2[0] < e2.length; h2[0]++) {
        for (l2 = n2, r3 = o2; r3 > 0; r3--)
          l2 += e2[h2[r3 - 1]];
        if (!s.Z.exists(this.elementsByName[l2 + a2]))
          return l2 + a2;
      }
      for (h2[0] = e2.length, r3 = 1; r3 < o2; r3++)
        h2[r3 - 1] === e2.length && (h2[r3 - 1] = 1, h2[r3] += 1);
    }
    return "";
  }, generateId: function() {
    for (var e2 = 1; s.Z.exists(t.Z.boards["jxgBoard" + e2]); )
      e2 = Math.round(65535 * Math.random());
    return "jxgBoard" + e2;
  }, setId: function(t2, e2) {
    var i3, r3 = this.numObjects, o2 = t2.id;
    if (this.numObjects += 1, "" === o2 || !s.Z.exists(o2))
      for (o2 = this.id + e2 + r3; s.Z.exists(this.objects[o2]); )
        i3 = Math.round(65535 * Math.random()), o2 = this.id + e2 + r3 + "-" + i3;
    return t2.id = o2, this.objects[o2] = t2, t2._pos = this.objectsList.length, this.objectsList[this.objectsList.length] = t2, o2;
  }, finalizeAdding: function(t2) {
    false === s.Z.evaluate(t2.visProp.visible) && this.renderer.display(t2, false);
  }, finalizeLabel: function(t2) {
    t2.hasLabel && !s.Z.evaluate(t2.label.visProp.islabel) && false === s.Z.evaluate(t2.label.visProp.visible) && this.renderer.display(t2.label, false);
  }, checkFrameRate: function(t2) {
    var e2 = false, i3 = (/* @__PURE__ */ new Date()).getTime();
    return s.Z.exists(t2.pointerId) && this.touchMoveLastId !== t2.pointerId && (e2 = true, this.touchMoveLastId = t2.pointerId), !e2 && (i3 - this.touchMoveLast) * this.attr.maxframerate >= 1e3 && (e2 = true), e2 && (this.touchMoveLast = i3), e2;
  }, getCoordsTopLeftCorner: function() {
    var t2, i3, r3, o2, n2, a2 = this.document.ownerDocument || this.document, h2 = a2.documentElement || this.document.body.parentNode, l2 = a2.body, c2 = this.containerObj;
    if (this.cPos.length > 0 && (this.mode === this.BOARD_MODE_DRAG || this.mode === this.BOARD_MODE_MOVE_ORIGIN || (/* @__PURE__ */ new Date()).getTime() - this.positionAccessLast < 1e3))
      return this.cPos;
    if (this.positionAccessLast = (/* @__PURE__ */ new Date()).getTime(), c2.getBoundingClientRect) {
      for (r3 = c2.getBoundingClientRect(), o2 = 1, n2 = c2; n2 && s.Z.exists(n2.parentNode); )
        s.Z.exists(n2.style) && s.Z.exists(n2.style.zoom) && "" !== n2.style.zoom && (o2 *= parseFloat(n2.style.zoom)), n2 = n2.parentNode;
      return (t2 = [r3.left * o2, r3.top * o2])[0] += e.Z.getProp(c2, "border-left-width"), t2[1] += e.Z.getProp(c2, "border-top-width"), "vml" !== this.renderer.type && (t2[0] += e.Z.getProp(c2, "padding-left"), t2[1] += e.Z.getProp(c2, "padding-top")), this.cPos = t2.slice(), this.cPos;
    }
    return t2 = e.Z.getOffset(c2), i3 = this.document.documentElement.ownerDocument, !this.containerObj.currentStyle && i3.defaultView && (t2[0] += e.Z.getProp(h2, "margin-left"), t2[1] += e.Z.getProp(h2, "margin-top"), t2[0] += e.Z.getProp(h2, "border-left-width"), t2[1] += e.Z.getProp(h2, "border-top-width"), t2[0] += e.Z.getProp(h2, "padding-left"), t2[1] += e.Z.getProp(h2, "padding-top")), l2 && (t2[0] += e.Z.getProp(l2, "left"), t2[1] += e.Z.getProp(l2, "top")), "object" == typeof google && google.translate && (t2[0] += 10, t2[1] += 25), t2[0] += e.Z.getProp(c2, "border-left-width"), t2[1] += e.Z.getProp(c2, "border-top-width"), "vml" !== this.renderer.type && (t2[0] += e.Z.getProp(c2, "padding-left"), t2[1] += e.Z.getProp(c2, "padding-top")), t2[0] += this.attr.offsetx, t2[1] += this.attr.offsety, this.cPos = t2.slice(), this.cPos;
  }, getMousePosition: function(t2, i3) {
    var r3, n2, a2 = this.getCoordsTopLeftCorner();
    return r3 = e.Z.getPosition(t2, i3, this.document), s.Z.exists(this.cssTransMat) || this.updateCSSTransforms(), n2 = [1, r3[0] - a2[0], r3[1] - a2[1]], (n2 = o.Z.matVecMult(this.cssTransMat, n2))[1] /= n2[0], n2[2] /= n2[0], [n2[1], n2[2]];
  }, initMoveOrigin: function(t2, e2) {
    this.drag_dx = t2 - this.origin.scrCoords[1], this.drag_dy = e2 - this.origin.scrCoords[2], this.mode = this.BOARD_MODE_MOVE_ORIGIN, this.updateQuality = this.BOARD_QUALITY_LOW;
  }, initMoveObject: function(t2, e2, r3, o2) {
    var n2, a2, h2, l2 = [], c2 = [], u2 = this.objectsList.length, p2 = { visProp: { layer: -1e4 } };
    for (a2 = 0; a2 < u2; a2++)
      h2 = (n2 = this.objectsList[a2]).hasPoint && n2.hasPoint(t2, e2), n2.visPropCalc.visible && h2 && (n2.triggerEventHandlers([o2 + "down", "down"], [r3]), this.downObjects.push(n2)), h2 && n2.isDraggable && n2.visPropCalc.visible && (this.geonextCompatibilityMode && (s.Z.isPoint(n2) || n2.elementClass === i2.Z.OBJECT_CLASS_TEXT) || !this.geonextCompatibilityMode) && !s.Z.evaluate(n2.visProp.fixed) && (n2.visProp.layer > p2.visProp.layer || n2.visProp.layer === p2.visProp.layer && n2.lastDragTime.getTime() >= p2.lastDragTime.getTime()) && (this.attr.ignorelabels && s.Z.exists(p2.label) && n2 === p2.label || (p2 = n2, l2.push(p2), s.Z.exists(p2.coords) ? c2.push(d.Z.subtract(p2.coords.scrCoords.slice(1), [t2, e2])) : c2.push([0, 0])));
    return this.attr.drag.enabled && l2.length > 0 && (this.mode = this.BOARD_MODE_DRAG), this.attr.takefirst ? (l2.length = 1, this._drag_offset = c2[0]) : (l2 = l2.slice(-1), this._drag_offset = c2[c2.length - 1]), this._drag_offset || (this._drag_offset = [0, 0]), "svg" === this.renderer.type && s.Z.exists(l2[0]) && s.Z.evaluate(l2[0].visProp.dragtotopoflayer) && 1 === l2.length && s.Z.exists(l2[0].rendNode) && l2[0].rendNode.parentNode.appendChild(l2[0].rendNode), this.previousRotation = 0, this.previousScale = 1, l2.length >= 1 && (l2[0].highlight(true), this.triggerEventHandlers(["mousehit", "hit"], [r3, l2[0]])), l2;
  }, moveObject: function(t2, e2, r3, o2, n2) {
    var a2, h2, l2, u2 = new c.Z(i2.Z.COORDS_BY_SCREEN, this.getScrCoordsOfMouse(t2, e2), this);
    r3 && r3.obj && ((a2 = r3.obj).coords && (h2 = a2.coords.scrCoords.slice()), this.addLogEntry("drag", a2, u2.usrCoords.slice(1)), this.drag_position = [u2.scrCoords[1], u2.scrCoords[2]], this.drag_position = d.Z.add(this.drag_position, this._drag_offset), s.Z.exists(a2.coords) ? a2.setPositionDirectly(i2.Z.COORDS_BY_SCREEN, this.drag_position) : (this.displayInfobox(false), isNaN(r3.targets[0].Xprev + r3.targets[0].Yprev) || a2.setPositionDirectly(i2.Z.COORDS_BY_SCREEN, [u2.scrCoords[1], u2.scrCoords[2]], [r3.targets[0].Xprev, r3.targets[0].Yprev]), r3.targets[0].Xprev = u2.scrCoords[1], r3.targets[0].Yprev = u2.scrCoords[2]), s.Z.exists(a2.coords) && (a2.prepareUpdate().update(false).updateRenderer(), this.updateInfobox(a2), a2.prepareUpdate().update(true).updateRenderer()), a2.coords && (l2 = a2.coords.scrCoords), a2.coords && h2[1] === l2[1] && h2[2] === l2[2] || (a2.triggerEventHandlers([n2 + "drag", "drag"], [o2]), this.update()), a2.highlight(true), this.triggerEventHandlers(["mousehit", "hit"], [o2, a2]), a2.lastDragTime = /* @__PURE__ */ new Date());
  }, twoFingerMove: function(t2, e2, r3) {
    var o2;
    s.Z.exists(t2) && s.Z.exists(t2.obj) && ((o2 = t2.obj).elementClass === i2.Z.OBJECT_CLASS_LINE || o2.type === i2.Z.OBJECT_TYPE_POLYGON ? this.twoFingerTouchObject(t2.targets, o2, e2) : o2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE && this.twoFingerTouchCircle(t2.targets, o2, e2), r3 && o2.triggerEventHandlers(["touchdrag", "drag"], [r3]));
  }, twoFingerTouchObject: function(t2, e2, r3) {
    var n2, a2, h2, l2, d2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2 = 0;
    if (s.Z.exists(t2[0]) && s.Z.exists(t2[1]) && !isNaN(t2[0].Xprev + t2[0].Yprev + t2[1].Xprev + t2[1].Yprev)) {
      if (r3 === t2[0].num ? (C2 = t2[1], y2 = t2[0]) : (C2 = t2[0], y2 = t2[1]), P2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [C2.Xprev, C2.Yprev], this).usrCoords, a2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [y2.Xprev, y2.Yprev], this).usrCoords, n2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [y2.X, y2.Y], this).usrCoords, l2 = o.Z.crossProduct(P2, a2), h2 = o.Z.crossProduct(P2, n2), p2 = o.Z.crossProduct(l2, h2), Math.abs(p2[0]) < o.Z.eps)
        return;
      if (s.Z.evaluate(e2.visProp.rotatable) && (E2 = u.Z.rad(a2.slice(1), P2.slice(1), n2.slice(1))), (_2 = this.create("transform", [E2, [P2[1], P2[2]]], { type: "rotate" })).update(), s.Z.evaluate(e2.visProp.scalable) && (d2 = u.Z.distance(n2, P2) / u.Z.distance(a2, P2), f2 = this.create("transform", [-P2[1], -P2[2]], { type: "translate" }), b2 = this.create("transform", [d2, d2], { type: "scale" }), g2 = this.create("transform", [P2[1], P2[2]], { type: "translate" }), _2.melt(f2).melt(b2).melt(g2)), e2.elementClass === i2.Z.OBJECT_CLASS_LINE)
        m2 = [], e2.point1.draggable() && m2.push(e2.point1), e2.point2.draggable() && m2.push(e2.point2), _2.applyOnce(m2);
      else if (e2.type === i2.Z.OBJECT_TYPE_POLYGON) {
        for (m2 = [], Z2 = e2.vertices.length - 1, v2 = 0; v2 < Z2; ++v2)
          e2.vertices[v2].draggable() && m2.push(e2.vertices[v2]);
        _2.applyOnce(m2);
      }
      this.update(), e2.highlight(true);
    }
  }, twoFingerTouchCircle: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2;
    "pointCircle" !== e2.method && "pointLine" !== e2.method && s.Z.exists(t2[0]) && s.Z.exists(t2[1]) && !isNaN(t2[0].Xprev + t2[0].Yprev + t2[1].Xprev + t2[1].Yprev) && (r3 === t2[0].num ? (o2 = t2[1], n2 = t2[0]) : (o2 = t2[0], n2 = t2[1]), l2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [o2.Xprev, o2.Yprev], this).usrCoords, h2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [n2.Xprev, n2.Yprev], this).usrCoords, a2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [n2.X, n2.Y], this).usrCoords, p2 = u.Z.rad(h2.slice(1), l2.slice(1), a2.slice(1)), _2 = this.create("transform", [-l2[1], -l2[2]], { type: "translate" }), f2 = this.create("transform", [p2], { type: "rotate" }), _2.melt(f2), s.Z.evaluate(e2.visProp.scalable) && (d2 = u.Z.distance(l2, a2) / u.Z.distance(l2, h2), b2 = this.create("transform", [d2, d2], { type: "scale" }), _2.melt(b2)), g2 = this.create("transform", [l2[1], l2[2]], { type: "translate" }), _2.melt(g2), e2.center.draggable() && _2.applyOnce([e2.center]), "twoPoints" === e2.method ? e2.point2.draggable() && _2.applyOnce([e2.point2]) : "pointRadius" === e2.method && s.Z.isNumber(e2.updateRadius.origin) && e2.setRadius(e2.radius * d2), this.update(e2.center), e2.highlight(true));
  }, highlightElements: function(t2, e2, i3, r3) {
    var o2, n2, a2, h2 = {}, l2 = this.objectsList.length;
    for (o2 = 0; o2 < l2; o2++)
      a2 = (n2 = this.objectsList[o2]).id, s.Z.exists(n2.hasPoint) && n2.visPropCalc.visible && n2.hasPoint(t2, e2) && (this.updateInfobox(n2), s.Z.exists(this.highlightedObjects[a2]) || (h2[a2] = n2, n2.highlight(), this.triggerEventHandlers(["mousehit", "hit"], [i3, n2, r3])), n2.mouseover ? n2.triggerEventHandlers(["mousemove", "move"], [i3]) : (n2.triggerEventHandlers(["mouseover", "over"], [i3]), n2.mouseover = true));
    for (o2 = 0; o2 < l2; o2++)
      a2 = (n2 = this.objectsList[o2]).id, n2.mouseover && (h2[a2] || (n2.triggerEventHandlers(["mouseout", "out"], [i3]), n2.mouseover = false));
  }, saveStartPos: function(e2, r3) {
    var o2, n2, a2 = [];
    if (e2.type === i2.Z.OBJECT_TYPE_TICKS)
      a2.push([1, NaN, NaN]);
    else if (e2.elementClass === i2.Z.OBJECT_CLASS_LINE)
      a2.push(e2.point1.coords.usrCoords), a2.push(e2.point2.coords.usrCoords);
    else if (e2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE)
      a2.push(e2.center.coords.usrCoords), "twoPoints" === e2.method && a2.push(e2.point2.coords.usrCoords);
    else if (e2.type === i2.Z.OBJECT_TYPE_POLYGON)
      for (n2 = e2.vertices.length - 1, o2 = 0; o2 < n2; o2++)
        a2.push(e2.vertices[o2].coords.usrCoords);
    else if (e2.type === i2.Z.OBJECT_TYPE_SECTOR)
      a2.push(e2.point1.coords.usrCoords), a2.push(e2.point2.coords.usrCoords), a2.push(e2.point3.coords.usrCoords);
    else if (s.Z.isPoint(e2) || e2.type === i2.Z.OBJECT_TYPE_GLIDER)
      a2.push(e2.coords.usrCoords);
    else if (e2.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      e2.points.length > 0 && a2.push(e2.points[0].usrCoords);
    else
      try {
        a2.push(e2.coords.usrCoords);
      } catch (e3) {
        t.Z.debug("JSXGraph+ saveStartPos: obj.coords.usrCoords not available: " + e3);
      }
    for (n2 = a2.length, o2 = 0; o2 < n2; o2++)
      r3.Zstart.push(a2[o2][0]), r3.Xstart.push(a2[o2][1]), r3.Ystart.push(a2[o2][2]);
  }, mouseOriginMoveStart: function(t2) {
    var e2, i3;
    return (e2 = this._isRequiredKeyPressed(t2, "pan")) && (i3 = this.getMousePosition(t2), this.initMoveOrigin(i3[0], i3[1])), e2;
  }, mouseOriginMove: function(t2) {
    var e2, i3 = this.mode === this.BOARD_MODE_MOVE_ORIGIN;
    return i3 && (e2 = this.getMousePosition(t2), this.moveOrigin(e2[0], e2[1], true)), i3;
  }, touchStartMoveOriginOneFinger: function(e2) {
    var i3, s2, r3 = e2[t.Z.touchProperty];
    return (i3 = this.attr.pan.enabled && !this.attr.pan.needtwofingers && 1 === r3.length) && (s2 = this.getMousePosition(e2, 0), this.initMoveOrigin(s2[0], s2[1])), i3;
  }, touchOriginMove: function(t2) {
    var e2, i3 = this.mode === this.BOARD_MODE_MOVE_ORIGIN;
    return i3 && (e2 = this.getMousePosition(t2, 0), this.moveOrigin(e2[0], e2[1], true)), i3;
  }, originMoveEnd: function() {
    this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode = this.BOARD_MODE_NONE;
  }, addEventHandlers: function() {
    e.Z.supportsPointerEvents() ? this.addPointerEventHandlers() : (this.addMouseEventHandlers(), this.addTouchEventHandlers()), null !== this.containerObj && (this.containerObj.oncontextmenu = function(t2) {
      return s.Z.exists(t2) && t2.preventDefault(), false;
    }), this.addKeyboardEventHandlers();
  }, addResizeEventHandlers: function() {
    if (e.Z.isBrowser) {
      try {
        this.startResizeObserver();
      } catch (t2) {
        e.Z.addEvent(window, "resize", this.resizeListener, this), this.startIntersectionObserver();
      }
      e.Z.addEvent(window, "scroll", this.scrollListener, this);
    }
  }, removeEventHandlers: function() {
    this.removeMouseEventHandlers(), this.removeTouchEventHandlers(), this.removePointerEventHandlers(), this.removeFullscreenEventHandlers(), this.removeKeyboardEventHandlers(), e.Z.isBrowser && (s.Z.exists(this.resizeObserver) ? this.stopResizeObserver() : (e.Z.removeEvent(window, "resize", this.resizeListener, this), this.stopIntersectionObserver()), e.Z.removeEvent(window, "scroll", this.scrollListener, this));
  }, addPointerEventHandlers: function() {
    if (!this.hasPointerHandlers && e.Z.isBrowser) {
      var t2 = this.attr.movetarget || this.containerObj;
      window.navigator.msPointerEnabled ? (e.Z.addEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this), e.Z.addEvent(t2, "MSPointerMove", this.pointerMoveListener, this)) : (e.Z.addEvent(this.containerObj, "pointerdown", this.pointerDownListener, this), e.Z.addEvent(t2, "pointermove", this.pointerMoveListener, this)), e.Z.addEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), e.Z.addEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), null !== this.containerObj && (this.containerObj.style.touchAction = "none"), this.hasPointerHandlers = true;
    }
  }, addMouseEventHandlers: function() {
    if (!this.hasMouseHandlers && e.Z.isBrowser) {
      var t2 = this.attr.movetarget || this.containerObj;
      e.Z.addEvent(this.containerObj, "mousedown", this.mouseDownListener, this), e.Z.addEvent(t2, "mousemove", this.mouseMoveListener, this), e.Z.addEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), e.Z.addEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasMouseHandlers = true;
    }
  }, addTouchEventHandlers: function(t2) {
    if (!this.hasTouchHandlers && e.Z.isBrowser) {
      var i3 = this.attr.movetarget || this.containerObj;
      e.Z.addEvent(this.containerObj, "touchstart", this.touchStartListener, this), e.Z.addEvent(i3, "touchmove", this.touchMoveListener, this), this.hasTouchHandlers = true;
    }
  }, addFullscreenEventHandlers: function() {
    var t2, i3 = ["fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "msfullscreenchange"], s2 = i3.length;
    if (!this.hasFullscreenEventHandlers && e.Z.isBrowser) {
      for (t2 = 0; t2 < s2; t2++)
        e.Z.addEvent(this.document, i3[t2], this.fullscreenListener, this);
      this.hasFullscreenEventHandlers = true;
    }
  }, addKeyboardEventHandlers: function() {
    this.attr.keyboard.enabled && !this.hasKeyboardHandlers && e.Z.isBrowser && (e.Z.addEvent(this.containerObj, "keydown", this.keyDownListener, this), e.Z.addEvent(this.containerObj, "focusin", this.keyFocusInListener, this), e.Z.addEvent(this.containerObj, "focusout", this.keyFocusOutListener, this), this.hasKeyboardHandlers = true);
  }, removeKeyboardEventHandlers: function() {
    this.hasKeyboardHandlers && e.Z.isBrowser && (e.Z.removeEvent(this.containerObj, "keydown", this.keyDownListener, this), e.Z.removeEvent(this.containerObj, "focusin", this.keyFocusInListener, this), e.Z.removeEvent(this.containerObj, "focusout", this.keyFocusOutListener, this), this.hasKeyboardHandlers = false);
  }, removeFullscreenEventHandlers: function() {
    var t2, i3 = ["fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "msfullscreenchange"], s2 = i3.length;
    if (this.hasFullscreenEventHandlers && e.Z.isBrowser) {
      for (t2 = 0; t2 < s2; t2++)
        e.Z.removeEvent(this.document, i3[t2], this.fullscreenListener, this);
      this.hasFullscreenEventHandlers = false;
    }
  }, removePointerEventHandlers: function() {
    if (this.hasPointerHandlers && e.Z.isBrowser) {
      var t2 = this.attr.movetarget || this.containerObj;
      window.navigator.msPointerEnabled ? (e.Z.removeEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this), e.Z.removeEvent(t2, "MSPointerMove", this.pointerMoveListener, this)) : (e.Z.removeEvent(this.containerObj, "pointerdown", this.pointerDownListener, this), e.Z.removeEvent(t2, "pointermove", this.pointerMoveListener, this)), e.Z.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), e.Z.removeEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasPointerUp && (window.navigator.msPointerEnabled ? e.Z.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : (e.Z.removeEvent(this.document, "pointerup", this.pointerUpListener, this), e.Z.removeEvent(this.document, "pointercancel", this.pointerUpListener, this)), this.hasPointerUp = false), this.hasPointerHandlers = false;
    }
  }, removeMouseEventHandlers: function() {
    if (this.hasMouseHandlers && e.Z.isBrowser) {
      var t2 = this.attr.movetarget || this.containerObj;
      e.Z.removeEvent(this.containerObj, "mousedown", this.mouseDownListener, this), e.Z.removeEvent(t2, "mousemove", this.mouseMoveListener, this), this.hasMouseUp && (e.Z.removeEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = false), e.Z.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), e.Z.removeEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasMouseHandlers = false;
    }
  }, removeTouchEventHandlers: function() {
    if (this.hasTouchHandlers && e.Z.isBrowser) {
      var t2 = this.attr.movetarget || this.containerObj;
      e.Z.removeEvent(this.containerObj, "touchstart", this.touchStartListener, this), e.Z.removeEvent(t2, "touchmove", this.touchMoveListener, this), this.hasTouchEnd && (e.Z.removeEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = false), this.hasTouchHandlers = false;
    }
  }, clickLeftArrow: function() {
    return this.moveOrigin(this.origin.scrCoords[1] + 0.1 * this.canvasWidth, this.origin.scrCoords[2]), this;
  }, clickRightArrow: function() {
    return this.moveOrigin(this.origin.scrCoords[1] - 0.1 * this.canvasWidth, this.origin.scrCoords[2]), this;
  }, clickUpArrow: function() {
    return this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] - 0.1 * this.canvasHeight), this;
  }, clickDownArrow: function() {
    return this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] + 0.1 * this.canvasHeight), this;
  }, gestureChangeListener: function(t2) {
    var e2, r3, o2, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2 = false, m2 = this.attr.zoom.factorx, v2 = this.attr.zoom.factory;
    return this.mode !== this.BOARD_MODE_ZOOM || (t2.preventDefault(), h2 = u.Z.distance([t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY], 2), void 0 === t2.scale && (t2.scale = h2 / this.prevDist), !!s.Z.exists(this.prevCoords) && (r3 = [t2.touches[0].clientX - this.prevCoords[0][0], t2.touches[0].clientY - this.prevCoords[0][1]], o2 = [t2.touches[1].clientX - this.prevCoords[1][0], t2.touches[1].clientY - this.prevCoords[1][1]], r3[0] * r3[0] + r3[1] * r3[1] < 100 && o2[0] * o2[0] + o2[1] * o2[1] < 100 || (n2 = u.Z.rad(r3, [0, 0], o2), "pan" !== this.isPreviousGesture && Math.abs(n2) > 0.2 * Math.PI && Math.abs(n2) < 1.8 * Math.PI && (g2 = true), "pan" === this.isPreviousGesture || g2 || (Math.abs(t2.scale) < 0.77 || Math.abs(t2.scale) > 1.3) && (g2 = true), a2 = t2.scale / this.prevScale, this.prevScale = t2.scale, this.prevCoords = [[t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY]], e2 = new c.Z(i2.Z.COORDS_BY_SCREEN, this.getMousePosition(t2, 0), this), this.attr.pan.enabled && this.attr.pan.needtwofingers && !g2 ? (this.isPreviousGesture = "pan", this.moveOrigin(e2.scrCoords[1], e2.scrCoords[2], true)) : this.attr.zoom.enabled && Math.abs(a2 - 1) < 0.5 && ((this.attr.zoom.pinchhorizontal || this.attr.zoom.pinchvertical) && (l2 = Math.abs(t2.touches[0].clientX - t2.touches[1].clientX), d2 = Math.abs(t2.touches[0].clientY - t2.touches[1].clientY), p2 = Math.abs(Math.atan2(d2, l2)), b2 = Math.PI * this.attr.zoom.pinchsensitivity / 90), this.attr.zoom.pinchhorizontal && p2 < b2 ? (this.attr.zoom.factorx = a2, this.attr.zoom.factory = 1, _2 = 0, f2 = 0) : this.attr.zoom.pinchvertical && Math.abs(p2 - 0.5 * Math.PI) < b2 ? (this.attr.zoom.factorx = 1, this.attr.zoom.factory = a2, _2 = 0, f2 = 0) : (this.attr.zoom.factorx = a2, this.attr.zoom.factory = a2, _2 = e2.usrCoords[1], f2 = e2.usrCoords[2]), this.zoomIn(_2, f2), this.attr.zoom.factorx = m2, this.attr.zoom.factory = v2)), false));
  }, gestureStartListener: function(t2) {
    var e2;
    return t2.preventDefault(), this.prevScale = 1, this.prevDist = u.Z.distance([t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY], 2), this.prevCoords = [[t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY]], this.isPreviousGesture = "none", e2 = this.getMousePosition(t2, 0), this.initMoveOrigin(e2[0], e2[1]), this.mode = this.BOARD_MODE_ZOOM, false;
  }, _isRequiredKeyPressed: function(t2, e2) {
    var i3 = this.attr[e2];
    return !!i3.enabled && !(!(i3.needshift && t2.shiftKey || !i3.needshift && !t2.shiftKey) || !(i3.needctrl && t2.ctrlKey || !i3.needctrl && !t2.ctrlKey));
  }, _isPointerRegistered: function(t2) {
    var e2, i3 = this._board_touches.length;
    for (e2 = 0; e2 < i3; e2++)
      if (this._board_touches[e2].pointerId === t2.pointerId)
        return true;
    return false;
  }, _pointerStorePosition: function(t2) {
    var e2, i3;
    for (e2 = 0, i3 = false; e2 < this._board_touches.length; e2++)
      if (this._board_touches[e2].pointerId === t2.pointerId) {
        this._board_touches[e2].clientX = t2.clientX, this._board_touches[e2].clientY = t2.clientY, i3 = true;
        break;
      }
    return !i3 && this._board_touches.length < 2 && this._board_touches.push({ pointerId: t2.pointerId, clientX: t2.clientX, clientY: t2.clientY }), this;
  }, _pointerRemoveTouches: function(t2) {
    var e2;
    for (e2 = 0; e2 < this._board_touches.length; e2++)
      if (this._board_touches[e2].pointerId === t2.pointerId) {
        this._board_touches.splice(e2, 1);
        break;
      }
    return this;
  }, _pointerClearTouches: function() {
    this._board_touches.length > 0 && this.dehighlightAll(), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode = this.BOARD_MODE_NONE, this._board_touches = [], this.touches = [];
  }, _getPointerInputDevice: function(t2) {
    if (e.Z.isBrowser) {
      if ("touch" === t2.pointerType || window.navigator.msMaxTouchPoints && window.navigator.msMaxTouchPoints > 1)
        return "touch";
      if ("mouse" === t2.pointerType)
        return "mouse";
      if ("pen" === t2.pointerType)
        return "pen";
    }
    return "mouse";
  }, pointerDownListener: function(t2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2;
    if (!i3 && this._isPointerRegistered(t2))
      return false;
    if (!i3 && t2.isPrimary && this._pointerClearTouches(), this.hasPointerUp || (window.navigator.msPointerEnabled ? e.Z.addEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : (e.Z.addEvent(this.document, "pointerup", this.pointerUpListener, this), e.Z.addEvent(this.document, "pointercancel", this.pointerUpListener, this)), this.hasPointerUp = true), this.hasMouseHandlers && this.removeMouseEventHandlers(), this.hasTouchHandlers && this.removeTouchEventHandlers(), this.document.selection && s.Z.isFunction(this.document.selection.empty))
      this.document.selection.empty();
    else if (window.getSelection && (l2 = window.getSelection()).removeAllRanges)
      try {
        l2.removeAllRanges();
      } catch (t3) {
      }
    if (this._inputDevice = this._getPointerInputDevice(t2), d2 = this._inputDevice, this.options.precision.hasPoint = this.options.precision[d2], a2 = this.getMousePosition(t2), this._testForSelection(t2), this.selectingMode)
      return this._startSelecting(a2), void this.triggerEventHandlers(["touchstartselecting", "pointerstartselecting", "startselecting"], [t2]);
    if (this.attr.drag.enabled && i3 ? (h2 = [i3], this.mode = this.BOARD_MODE_DRAG) : h2 = this.initMoveObject(a2[0], a2[1], t2, d2), c2 = { num: t2.pointerId, X: a2[0], Y: a2[1], Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: [] }, h2.length > 0) {
      for (p2 = h2[h2.length - 1], u2 = false, r3 = 0; r3 < this.touches.length; r3++)
        if (this.touches[r3].obj === p2) {
          o2 = r3, n2 = this.touches[r3].targets.push(c2) - 1, u2 = true;
          break;
        }
      u2 || (n2 = 0, o2 = this.touches.push({ obj: p2, targets: [c2] }) - 1), this.dehighlightAll(), p2.highlight(true), this.saveStartPos(p2, this.touches[o2].targets[n2]), t2 && t2.preventDefault ? t2.preventDefault() : window.event && (window.event.returnValue = false);
    }
    return this.touches.length > 0 && (t2.preventDefault(), t2.stopPropagation()), !!e.Z.isBrowser && ("touch" !== this._getPointerInputDevice(t2) ? this.mode === this.BOARD_MODE_NONE && this.mouseOriginMoveStart(t2) : (this._pointerStorePosition(t2), t2.touches = this._board_touches, 1 === t2.touches.length && this.mode === this.BOARD_MODE_NONE && this.touchStartMoveOriginOneFinger(t2) || 2 !== t2.touches.length || this.mode !== this.BOARD_MODE_NONE && this.mode !== this.BOARD_MODE_MOVE_ORIGIN || (this.mode === this.BOARD_MODE_MOVE_ORIGIN && this.originMoveEnd(), this.gestureStartListener(t2))), _2 = "none", this.mode !== this.BOARD_MODE_NONE || !s.Z.evaluate(this.attr.browserpan) || s.Z.evaluate(this.attr.pan.enabled) && !s.Z.evaluate(this.attr.pan.needtwofingers) || (_2 = "pan-x pan-y"), this.containerObj.style.touchAction = _2, this.triggerEventHandlers(["touchstart", "down", "pointerdown", "MSPointerDown"], [t2]), true);
  }, pointerMoveListener: function(t2) {
    var e2, i3, s2, r3, o2;
    if ("touch" === this._getPointerInputDevice(t2) && !this._isPointerRegistered(t2))
      return this.BOARD_MODE_NONE;
    if (!this.checkFrameRate(t2))
      return false;
    if (this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this.mode !== this.BOARD_MODE_NONE && (t2.preventDefault(), t2.stopPropagation()), this.updateQuality = this.BOARD_QUALITY_LOW, this._inputDevice = this._getPointerInputDevice(t2), o2 = this._inputDevice, this.options.precision.hasPoint = this.options.precision[o2], this.selectingMode)
      s2 = this.getMousePosition(t2), this._moveSelecting(s2), this.triggerEventHandlers(["touchmoveselecting", "moveselecting", "pointermoveselecting"], [t2, this.mode]);
    else if (!this.mouseOriginMove(t2))
      if (this.mode === this.BOARD_MODE_DRAG) {
        for (e2 = 0; e2 < this.touches.length; e2++)
          for (r3 = this.touches[e2].targets, i3 = 0; i3 < r3.length; i3++)
            if (r3[i3].num === t2.pointerId) {
              s2 = this.getMousePosition(t2), r3[i3].X = s2[0], r3[i3].Y = s2[1], 1 === r3.length ? this.moveObject(s2[0], s2[1], this.touches[e2], t2, o2) : 2 === r3.length && (this.twoFingerMove(this.touches[e2], t2.pointerId, t2), r3[i3].Xprev = s2[0], r3[i3].Yprev = s2[1]);
              break;
            }
      } else
        "touch" === this._getPointerInputDevice(t2) && (this._pointerStorePosition(t2), 2 === this._board_touches.length && (t2.touches = this._board_touches, this.gestureChangeListener(t2))), s2 = this.getMousePosition(t2), this.highlightElements(s2[0], s2[1], t2, -1);
    return this.triggerEventHandlers(["pointermove", "MSPointerMove", "move"], [t2, this.mode]), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode === this.BOARD_MODE_NONE;
  }, pointerUpListener: function(t2) {
    var i3, r3, o2, n2, a2 = false;
    if (this.triggerEventHandlers(["touchend", "up", "pointerup", "MSPointerUp"], [t2]), this.displayInfobox(false), t2) {
      for (i3 = 0; i3 < this.touches.length; i3++)
        for (n2 = this.touches[i3].targets, r3 = 0; r3 < n2.length; r3++)
          if (n2[r3].num === t2.pointerId) {
            n2.splice(r3, 1), 0 === n2.length && this.touches.splice(i3, 1);
            break;
          }
    }
    if (this.originMoveEnd(), this.update(), this.selectingMode)
      this._stopSelecting(t2), this.triggerEventHandlers(["touchstopselecting", "pointerstopselecting", "stopselecting"], [t2]), this.stopSelectionMode();
    else
      for (i3 = this.downObjects.length - 1; i3 > -1; i3--) {
        for (o2 = false, r3 = 0; r3 < this.touches.length; r3++)
          this.touches[r3].obj.id === this.downObjects[i3].id && (o2 = true);
        o2 || (this.downObjects[i3].triggerEventHandlers(["touchend", "up", "pointerup", "MSPointerUp"], [t2]), s.Z.exists(this.downObjects[i3].coords) || (this.downObjects[i3].snapToGrid(), this.downObjects[i3].snapToPoints(), a2 = true), this.downObjects.splice(i3, 1));
      }
    return this.hasPointerUp && (window.navigator.msPointerEnabled ? e.Z.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : (e.Z.removeEvent(this.document, "pointerup", this.pointerUpListener, this), e.Z.removeEvent(this.document, "pointercancel", this.pointerUpListener, this)), this.hasPointerUp = false), a2 && this.update(), this._pointerClearTouches(), true;
  }, touchStartListener: function(r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2 = this.options.precision.touch, b2 = r3[t.Z.touchProperty];
    for (this.hasTouchEnd || (e.Z.addEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = true), this.document.selection && s.Z.isFunction(this.document.selection.empty) ? this.document.selection.empty() : window.getSelection && window.getSelection().removeAllRanges(), this._inputDevice = "touch", this.options.precision.hasPoint = this.options.precision.touch, o2 = 0; o2 < b2.length; o2++)
      b2[o2].jxg_isused = false;
    for (o2 = 0; o2 < this.touches.length; o2++)
      for (_2 = this.touches[o2].targets, h2 = 0; h2 < _2.length; h2++) {
        _2[h2].num = -1, f2 = this.options.precision.touch;
        do {
          for (l2 = 0; l2 < b2.length; l2++)
            if (Math.abs(Math.pow(b2[l2].screenX - _2[h2].X, 2) + Math.pow(b2[l2].screenY - _2[h2].Y, 2)) < f2 * f2) {
              _2[h2].num = l2, _2[h2].X = b2[l2].screenX, _2[h2].Y = b2[l2].screenY, b2[l2].jxg_isused = true;
              break;
            }
          f2 *= 2;
        } while (-1 === _2[h2].num && f2 < this.options.precision.touchMax);
        -1 === _2[h2].num && (t.Z.debug("i couldn't find a targettouches for target no " + h2 + " on " + this.touches[o2].obj.name + " (" + this.touches[o2].obj.id + "). Removed the target."), t.Z.debug("eps = " + f2 + ", touchMax = " + M.Z.precision.touchMax), _2.splice(o2, 1));
      }
    for (o2 = 0; o2 < b2.length; o2++)
      if (!b2[o2].jxg_isused) {
        if (n2 = this.getMousePosition(r3, o2), this.selectingMode)
          return this._startSelecting(n2), this.triggerEventHandlers(["touchstartselecting", "startselecting"], [r3]), r3.preventDefault(), r3.stopPropagation(), this.options.precision.hasPoint = this.options.precision.mouse, this.touches.length > 0;
        if (0 !== (a2 = this.initMoveObject(n2[0], n2[1], r3, "touch")).length) {
          if (c2 = a2[a2.length - 1], p2 = { num: o2, X: b2[o2].screenX, Y: b2[o2].screenY, Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: [] }, s.Z.isPoint(c2) || c2.elementClass === i2.Z.OBJECT_CLASS_TEXT || c2.type === i2.Z.OBJECT_TYPE_TICKS || c2.type === i2.Z.OBJECT_TYPE_IMAGE)
            u2 = [p2], this.saveStartPos(c2, u2[0]), this.touches.push({ obj: c2, targets: u2 }), c2.highlight(true);
          else if (c2.elementClass === i2.Z.OBJECT_CLASS_LINE || c2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE || c2.elementClass === i2.Z.OBJECT_CLASS_CURVE || c2.type === i2.Z.OBJECT_TYPE_POLYGON) {
            for (d2 = false, h2 = 0; h2 < this.touches.length; h2++)
              c2.id === this.touches[h2].obj.id && (d2 = true, 1 === this.touches[h2].targets.length && (this.saveStartPos(c2, p2), this.touches[h2].targets.push(p2)), b2[o2].jxg_isused = true);
            d2 || (u2 = [p2], this.saveStartPos(c2, u2[0]), this.touches.push({ obj: c2, targets: u2 }), c2.highlight(true));
          }
        }
        b2[o2].jxg_isused = true;
      }
    return this.touches.length > 0 && (r3.preventDefault(), r3.stopPropagation()), 1 === b2.length && this.mode === this.BOARD_MODE_NONE && this.touchStartMoveOriginOneFinger(r3) || 2 !== b2.length || this.mode !== this.BOARD_MODE_NONE && this.mode !== this.BOARD_MODE_MOVE_ORIGIN || (this.mode === this.BOARD_MODE_MOVE_ORIGIN && this.originMoveEnd(), this.gestureStartListener(r3)), this.options.precision.hasPoint = this.options.precision.mouse, this.triggerEventHandlers(["touchstart", "down"], [r3]), false;
  }, touchMoveListener: function(e2) {
    var i3, s2, r3, o2, n2 = e2[t.Z.touchProperty];
    if (!this.checkFrameRate(e2))
      return false;
    if (this.mode !== this.BOARD_MODE_NONE && (e2.preventDefault(), e2.stopPropagation()), this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this._inputDevice = "touch", this.options.precision.hasPoint = this.options.precision.touch, this.updateQuality = this.BOARD_QUALITY_LOW, this.selectingMode) {
      for (i3 = 0; i3 < n2.length; i3++)
        if (!n2[i3].jxg_isused) {
          s2 = this.getMousePosition(e2, i3), this._moveSelecting(s2), this.triggerEventHandlers(["touchmoves", "moveselecting"], [e2, this.mode]);
          break;
        }
    } else if (!this.touchOriginMove(e2))
      if (this.mode === this.BOARD_MODE_DRAG) {
        for (i3 = 0; i3 < this.touches.length; i3++)
          if (1 === (o2 = this.touches[i3].targets).length) {
            if (n2[o2[0].num]) {
              if ((s2 = this.getMousePosition(e2, o2[0].num))[0] < 0 || s2[0] > this.canvasWidth || s2[1] < 0 || s2[1] > this.canvasHeight)
                return;
              o2[0].X = s2[0], o2[0].Y = s2[1], this.moveObject(s2[0], s2[1], this.touches[i3], e2, "touch");
            }
          } else if (2 === o2.length && o2[0].num > -1 && o2[1].num > -1 && n2[o2[0].num] && n2[o2[1].num]) {
            if (s2 = this.getMousePosition(e2, o2[0].num), r3 = this.getMousePosition(e2, o2[1].num), s2[0] < 0 || s2[0] > this.canvasWidth || s2[1] < 0 || s2[1] > this.canvasHeight || r3[0] < 0 || r3[0] > this.canvasWidth || r3[1] < 0 || r3[1] > this.canvasHeight)
              return;
            o2[0].X = s2[0], o2[0].Y = s2[1], o2[1].X = r3[0], o2[1].Y = r3[1], this.twoFingerMove(this.touches[i3], o2[0].num, e2), this.twoFingerMove(this.touches[i3], o2[1].num), o2[0].Xprev = s2[0], o2[0].Yprev = s2[1], o2[1].Xprev = r3[0], o2[1].Yprev = r3[1];
          }
      } else
        2 === n2.length && this.gestureChangeListener(e2), s2 = this.getMousePosition(e2, 0), this.highlightElements(s2[0], s2[1], e2, -1);
    return this.mode !== this.BOARD_MODE_DRAG && this.displayInfobox(false), this.triggerEventHandlers(["touchmove", "move"], [e2, this.mode]), this.options.precision.hasPoint = this.options.precision.mouse, this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode === this.BOARD_MODE_NONE;
  }, touchEndListener: function(r3) {
    var o2, n2, a2, h2, l2, c2, d2 = this.options.precision.touch, u2 = [], p2 = r3 && r3[t.Z.touchProperty], _2 = false;
    if (this.triggerEventHandlers(["touchend", "up"], [r3]), this.displayInfobox(false), this.selectingMode)
      this._stopSelecting(r3), this.triggerEventHandlers(["touchstopselecting", "stopselecting"], [r3]), this.stopSelectionMode();
    else if (p2 && p2.length > 0) {
      for (o2 = 0; o2 < this.touches.length; o2++)
        u2[o2] = this.touches[o2];
      for (this.touches.length = 0, o2 = 0; o2 < p2.length; o2++)
        p2[o2].jxg_isused = false;
      for (o2 = 0; o2 < u2.length; o2++) {
        for (h2 = false, l2 = 0, c2 = u2[o2].targets, n2 = 0; n2 < c2.length; n2++)
          for (c2[n2].found = false, a2 = 0; a2 < p2.length; a2++)
            if (Math.abs(Math.pow(p2[a2].screenX - c2[n2].X, 2) + Math.pow(p2[a2].screenY - c2[n2].Y, 2)) < d2 * d2) {
              c2[n2].found = true, c2[n2].num = a2, c2[n2].X = p2[a2].screenX, c2[n2].Y = p2[a2].screenY, l2 += 1;
              break;
            }
        if (s.Z.isPoint(u2[o2].obj) ? h2 = c2[0] && c2[0].found : u2[o2].obj.elementClass === i2.Z.OBJECT_CLASS_LINE ? h2 = c2[0] && c2[0].found || c2[1] && c2[1].found : u2[o2].obj.elementClass === i2.Z.OBJECT_CLASS_CIRCLE && (h2 = 1 === l2 || 3 === l2), h2)
          for (this.touches.push({ obj: u2[o2].obj, targets: [] }), n2 = 0; n2 < c2.length; n2++)
            c2[n2].found && this.touches[this.touches.length - 1].targets.push({ num: c2[n2].num, X: c2[n2].screenX, Y: c2[n2].screenY, Xprev: NaN, Yprev: NaN, Xstart: c2[n2].Xstart, Ystart: c2[n2].Ystart, Zstart: c2[n2].Zstart });
        else
          u2[o2].obj.noHighlight();
      }
    } else
      this.touches.length = 0;
    for (o2 = this.downObjects.length - 1; o2 > -1; o2--) {
      for (h2 = false, n2 = 0; n2 < this.touches.length; n2++)
        this.touches[n2].obj.id === this.downObjects[o2].id && (h2 = true);
      h2 || (this.downObjects[o2].triggerEventHandlers(["touchup", "up"], [r3]), s.Z.exists(this.downObjects[o2].coords) || (this.downObjects[o2].snapToGrid(), this.downObjects[o2].snapToPoints(), _2 = true), this.downObjects.splice(o2, 1));
    }
    return p2 && 0 !== p2.length || (this.hasTouchEnd && (e.Z.removeEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = false), this.dehighlightAll(), this.updateQuality = this.BOARD_QUALITY_HIGH, this.originMoveEnd(), _2 && this.update()), true;
  }, mouseDownListener: function(t2) {
    var i3, r3, o2;
    if (this.document.selection && s.Z.isFunction(this.document.selection.empty) ? this.document.selection.empty() : window.getSelection && window.getSelection().removeAllRanges(), !this.hasMouseUp)
      return e.Z.addEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = true, this._inputDevice = "mouse", this.options.precision.hasPoint = this.options.precision.mouse, i3 = this.getMousePosition(t2), this._testForSelection(t2), this.selectingMode ? (this._startSelecting(i3), void this.triggerEventHandlers(["mousestartselecting", "startselecting"], [t2])) : (0 === (r3 = this.initMoveObject(i3[0], i3[1], t2, "mouse")).length ? (this.mode = this.BOARD_MODE_NONE, o2 = true) : (this.mouse = { obj: null, targets: [{ X: i3[0], Y: i3[1], Xprev: NaN, Yprev: NaN }] }, this.mouse.obj = r3[r3.length - 1], this.dehighlightAll(), this.mouse.obj.highlight(true), this.mouse.targets[0].Xstart = [], this.mouse.targets[0].Ystart = [], this.mouse.targets[0].Zstart = [], this.saveStartPos(this.mouse.obj, this.mouse.targets[0]), t2 && t2.preventDefault ? t2.preventDefault() : window.event && (window.event.returnValue = false)), this.mode === this.BOARD_MODE_NONE && (o2 = this.mouseOriginMoveStart(t2)), this.triggerEventHandlers(["mousedown", "down"], [t2]), o2);
  }, mouseMoveListener: function(t2) {
    var e2;
    if (!this.checkFrameRate(t2))
      return false;
    e2 = this.getMousePosition(t2), this.updateQuality = this.BOARD_QUALITY_LOW, this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this.selectingMode ? (this._moveSelecting(e2), this.triggerEventHandlers(["mousemoveselecting", "moveselecting"], [t2, this.mode])) : this.mouseOriginMove(t2) || (this.mode === this.BOARD_MODE_DRAG ? this.moveObject(e2[0], e2[1], this.mouse, t2, "mouse") : this.highlightElements(e2[0], e2[1], t2, -1), this.triggerEventHandlers(["mousemove", "move"], [t2, this.mode])), this.updateQuality = this.BOARD_QUALITY_HIGH;
  }, mouseUpListener: function(t2) {
    var i3;
    if (false === this.selectingMode && this.triggerEventHandlers(["mouseup", "up"], [t2]), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mouse && this.mouse.obj && (s.Z.exists(this.mouse.obj.coords) || (this.mouse.obj.snapToGrid(this.mouse.targets[0]), this.mouse.obj.snapToPoints())), this.originMoveEnd(), this.dehighlightAll(), this.update(), this.selectingMode)
      this._stopSelecting(t2), this.triggerEventHandlers(["mousestopselecting", "stopselecting"], [t2]), this.stopSelectionMode();
    else
      for (i3 = 0; i3 < this.downObjects.length; i3++)
        this.downObjects[i3].triggerEventHandlers(["mouseup", "up"], [t2]);
    this.downObjects.length = 0, this.hasMouseUp && (e.Z.removeEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = false), this.mouse = null;
  }, mouseWheelListener: function(t2) {
    if (!this.attr.zoom.wheel || !this._isRequiredKeyPressed(t2, "zoom"))
      return true;
    var e2 = (t2 = t2 || window.event).detail ? -t2.detail : t2.wheelDelta / 40, s2 = new c.Z(i2.Z.COORDS_BY_SCREEN, this.getMousePosition(t2), this);
    return e2 > 0 ? this.zoomIn(s2.usrCoords[1], s2.usrCoords[2]) : this.zoomOut(s2.usrCoords[1], s2.usrCoords[2]), this.triggerEventHandlers(["mousewheel"], [t2]), t2.preventDefault(), false;
  }, keyDownListener: function(e2) {
    var r3, o2, n2, a2, h2, l2, c2 = e2.target.id, d2 = 0, u2 = 0, p2 = s.Z.evaluate(this.attr.keyboard.dx) / this.unitX, _2 = s.Z.evaluate(this.attr.keyboard.dy) / this.unitY, f2 = false, b2 = true;
    return !(!this.attr.keyboard.enabled || "" === c2) && ((!(a2 = this.containerObj.shadowRoot || document).activeElement || "INPUT" !== (o2 = a2.activeElement).tagName && "textarea" !== o2.tagName) && (r3 = c2.replace(this.containerObj.id + "_", ""), o2 = this.select(r3), s.Z.exists(o2.coords) && (l2 = o2.coords.usrCoords.slice(1)), s.Z.evaluate(this.attr.keyboard.panshift) && e2.shiftKey || s.Z.evaluate(this.attr.keyboard.panctrl) && e2.ctrlKey ? (true === s.Z.evaluate(this.attr.zoom.enabled) && (f2 = true), 38 === e2.keyCode ? this.clickUpArrow() : 40 === e2.keyCode ? this.clickDownArrow() : 37 === e2.keyCode ? this.clickLeftArrow() : 39 === e2.keyCode ? this.clickRightArrow() : f2 && 171 === e2.keyCode ? this.zoomIn() : f2 && 173 === e2.keyCode ? this.zoomOut() : f2 && 79 === e2.keyCode ? this.zoom100() : b2 = false) : (s.Z.exists(o2.visProp) && (s.Z.exists(o2.visProp.snaptogrid) && o2.visProp.snaptogrid && s.Z.evaluate(o2.visProp.snapsizex) && s.Z.evaluate(o2.visProp.snapsizey) ? (d2 = (n2 = o2.getSnapSizes())[0], u2 = n2[1], p2 = Math.max(d2, p2), _2 = Math.max(u2, _2)) : s.Z.exists(o2.visProp.attracttogrid) && o2.visProp.attracttogrid && s.Z.evaluate(o2.visProp.attractordistance) && s.Z.evaluate(o2.visProp.attractorunit) && (u2 = d2 = 1.1 * s.Z.evaluate(o2.visProp.attractordistance), "screen" === s.Z.evaluate(o2.visProp.attractorunit) && (d2 /= this.unitX, u2 /= this.unitX), p2 = Math.max(d2, p2), _2 = Math.max(u2, _2))), 38 === e2.keyCode ? h2 = [0, _2] : 40 === e2.keyCode ? h2 = [0, -_2] : 37 === e2.keyCode ? h2 = [-p2, 0] : 39 === e2.keyCode ? h2 = [p2, 0] : b2 = false, h2 && o2.isDraggable && o2.visPropCalc.visible && (this.geonextCompatibilityMode && (s.Z.isPoint(o2) || o2.elementClass === i2.Z.OBJECT_CLASS_TEXT) || !this.geonextCompatibilityMode) && !s.Z.evaluate(o2.visProp.fixed) && (this.mode = this.BOARD_MODE_DRAG, s.Z.exists(o2.coords) && (h2[0] += l2[0], h2[1] += l2[1]), s.Z.exists(o2.coords) ? (o2.setPosition(t.Z.COORDS_BY_USER, h2), this.updateInfobox(o2)) : (this.displayInfobox(false), o2.setPositionDirectly(i2.Z.COORDS_BY_USER, h2, [0, 0])), this.triggerEventHandlers(["keymove", "move"], [e2, this.mode]), o2.triggerEventHandlers(["keydrag", "drag"], [e2]), this.mode = this.BOARD_MODE_NONE)), this.update(), b2 && s.Z.exists(e2.preventDefault) && e2.preventDefault(), b2));
  }, keyFocusInListener: function(t2) {
    var e2, i3, r3 = t2.target.id;
    if (!this.attr.keyboard.enabled || "" === r3)
      return false;
    e2 = r3.replace(this.containerObj.id + "_", ""), i3 = this.select(e2), s.Z.exists(i3.highlight) && (i3.highlight(true), this.focusObjects = [e2], i3.triggerEventHandlers(["hit"], [t2])), s.Z.exists(i3.coords) && this.updateInfobox(i3);
  }, keyFocusOutListener: function(t2) {
    if (!this.attr.keyboard.enabled)
      return false;
    this.focusObjects = [], this.dehighlightAll(), this.displayInfobox(false);
  }, updateContainerDims: function() {
    var t2, e2, i3, r3, o2, n2;
    t2 = (i3 = this.containerObj.getBoundingClientRect()).width, e2 = i3.height, window && window.getComputedStyle && (r3 = window.getComputedStyle(this.containerObj, null), o2 = parseFloat(r3.getPropertyValue("border-left-width")) + parseFloat(r3.getPropertyValue("border-right-width")), isNaN(o2) || (t2 -= o2), n2 = parseFloat(r3.getPropertyValue("border-top-width")) + parseFloat(r3.getPropertyValue("border-bottom-width")), isNaN(n2) || (e2 -= n2)), t2 <= 0 || e2 <= 0 || isNaN(t2) || isNaN(e2) || (isNaN(this.getBoundingBox()[0]) && this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, "keep"), s.Z.exists(this._prevDim) && this._prevDim.w === t2 && this._prevDim.h === e2 || (this.resizeContainer(t2, e2, true), this._prevDim = { w: t2, h: e2 }));
  }, startResizeObserver: function() {
    var t2 = this;
    e.Z.isBrowser && this.attr.resize && this.attr.resize.enabled && (this.resizeObserver = new ResizeObserver(function(e2) {
      t2._isResizing || (t2._isResizing = true, window.setTimeout(function() {
        try {
          t2.updateContainerDims();
        } catch (e3) {
          t2.stopResizeObserver();
        } finally {
          t2._isResizing = false;
        }
      }, t2.attr.resize.throttle));
    }), this.resizeObserver.observe(this.containerObj));
  }, stopResizeObserver: function() {
    e.Z.isBrowser && this.attr.resize && this.attr.resize.enabled && s.Z.exists(this.resizeObserver) && this.resizeObserver.unobserve(this.containerObj);
  }, resizeListener: function() {
    var t2 = this;
    e.Z.isBrowser && this.attr.resize && this.attr.resize.enabled && (this._isScrolling || this._isResizing || (this._isResizing = true, window.setTimeout(function() {
      t2.updateContainerDims(), t2._isResizing = false;
    }, this.attr.resize.throttle)));
  }, scrollListener: function(t2) {
    var i3 = this;
    e.Z.isBrowser && (this._isScrolling || (this._isScrolling = true, window.setTimeout(function() {
      i3._isScrolling = false;
    }, 66)));
  }, startIntersectionObserver: function() {
    var t2 = this;
    try {
      this.intersectionObserver = new IntersectionObserver(function(e2) {
        isNaN(t2.getBoundingBox()[0]) && t2.updateContainerDims();
      }, { root: null, rootMargin: "0px", threshold: 0.8 }), this.intersectionObserver.observe(t2.containerObj);
    } catch (t3) {
      console.log("JSXGraph: IntersectionObserver not available in this browser.");
    }
  }, stopIntersectionObserver: function() {
    s.Z.exists(this.intersectionObserver) && this.intersectionObserver.unobserve(this.containerObj);
  }, initInfobox: function() {
    var t2 = s.Z.copyAttributes({}, this.options, "infobox");
    return t2.id = this.id + "_infobox", this.infobox = this.create("text", [0, 0, "0,0"], t2), this.infobox.dump = false, this.displayInfobox(false), this;
  }, updateInfobox: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2, l2 = s.Z.evaluate(t2.visProp.showinfobox);
    return !s.Z.evaluate(this.attr.showinfobox) && "inherit" === l2 || !l2 || s.Z.isPoint(t2) && (r3 = t2.coords.usrCoords[1], o2 = t2.coords.usrCoords[2], a2 = s.Z.evaluate(this.infobox.visProp.distancex), h2 = s.Z.evaluate(this.infobox.visProp.distancey), n2 = s.Z.evaluate(t2.visProp.infoboxdigits), this.infobox.setCoords(r3 + a2 / this.unitX, o2 + h2 / this.unitY), "string" != typeof t2.infoboxText ? ("auto" === n2 ? (e2 = s.Z.autoDigits(r3), i3 = s.Z.autoDigits(o2)) : s.Z.isNumber(n2) ? (e2 = s.Z.toFixed(r3, n2), i3 = s.Z.toFixed(o2, n2)) : (e2 = r3, i3 = o2), this.highlightInfobox(e2, i3, t2)) : this.highlightCustomInfobox(t2.infoboxText, t2), this.displayInfobox(true)), this;
  }, displayInfobox: function(t2) {
    return !t2 && this.focusObjects.length > 0 && this.select(this.focusObjects[0]).elementClass === i2.Z.OBJECT_CLASS_POINT || this.infobox.hiddenByParent === t2 && (this.infobox.hiddenByParent = !t2, this.infobox.prepareUpdate().updateVisibility(t2).updateRenderer()), this;
  }, showInfobox: function(t2) {
    return this.displayInfobox(t2);
  }, highlightInfobox: function(t2, e2, i3) {
    return this.highlightCustomInfobox("(" + t2 + ", " + e2 + ")", i3), this;
  }, highlightCustomInfobox: function(t2, e2) {
    return this.infobox.setText(t2), this;
  }, dehighlightAll: function() {
    var t2, e2, i3 = {}, s2 = false;
    for (t2 in this.highlightedObjects)
      this.highlightedObjects.hasOwnProperty(t2) && (e2 = this.highlightedObjects[t2], this.focusObjects.indexOf(t2) < 0 ? ((this.hasMouseHandlers || this.hasPointerHandlers) && e2.noHighlight(), s2 = true) : i3[t2] = e2);
    return this.highlightedObjects = i3, "canvas" === this.renderer.type && s2 && (this.prepareUpdate(), this.renderer.suspendRedraw(this), this.updateRenderer(), this.renderer.unsuspendRedraw()), this;
  }, getScrCoordsOfMouse: function(t2, e2) {
    return [t2, e2];
  }, getUsrCoordsOfMouse: function(t2) {
    var s2 = this.getCoordsTopLeftCorner(), r3 = e.Z.getPosition(t2, null, this.document), o2 = r3[0] - s2[0], n2 = r3[1] - s2[1];
    return new c.Z(i2.Z.COORDS_BY_SCREEN, [o2, n2], this).usrCoords.slice(1);
  }, getAllUnderMouse: function(t2) {
    var e2 = this.getAllObjectsUnderMouse(t2);
    return e2.push(this.getUsrCoordsOfMouse(t2)), e2;
  }, getAllObjectsUnderMouse: function(t2) {
    var i3, s2, r3 = this.getCoordsTopLeftCorner(), o2 = e.Z.getPosition(t2, null, this.document), n2 = o2[0] - r3[0], a2 = o2[1] - r3[1], h2 = [], l2 = this.objectsList.length;
    for (i3 = 0; i3 < l2; i3++)
      (s2 = this.objectsList[i3]).visPropCalc.visible && s2.hasPoint && s2.hasPoint(n2, a2) && (h2[h2.length] = s2);
    return h2;
  }, updateCoords: function() {
    var t2, e2, i3 = this.objectsList.length;
    for (e2 = 0; e2 < i3; e2++)
      t2 = this.objectsList[e2], s.Z.exists(t2.coords) && (s.Z.evaluate(t2.visProp.frozen) ? t2.coords.screen2usr() : t2.coords.usr2screen());
    return this;
  }, moveOrigin: function(t2, e2, r3) {
    var o2, n2, a2, h2;
    return s.Z.exists(t2) && s.Z.exists(e2) && (o2 = this.origin.scrCoords[1], n2 = this.origin.scrCoords[2], this.origin.scrCoords[1] = t2, this.origin.scrCoords[2] = e2, r3 && (this.origin.scrCoords[1] -= this.drag_dx, this.origin.scrCoords[2] -= this.drag_dy), a2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [0, 0], this).usrCoords, h2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords, (a2[1] < this.maxboundingbox[0] || a2[2] > this.maxboundingbox[1] || h2[1] > this.maxboundingbox[2] || h2[2] < this.maxboundingbox[3]) && (this.origin.scrCoords[1] = o2, this.origin.scrCoords[2] = n2)), this.updateCoords().clearTraces().fullUpdate(), this.triggerEventHandlers(["boundingbox"]), this;
  }, addConditions: function(e2) {
    var r3, o2, n2, a2, h2, l2, c2, d2 = [], u2 = e2.indexOf("<data>"), p2 = e2.indexOf("</data>"), _2 = function(t2, e3, s2, r4) {
      return function() {
        var o3, n3;
        n3 = (o3 = t2.select(e3.id)).coords.usrCoords[r4], 2 === r4 ? o3.setPositionDirectly(i2.Z.COORDS_BY_USER, [s2(), n3]) : o3.setPositionDirectly(i2.Z.COORDS_BY_USER, [n3, s2()]), o3.prepareUpdate().update();
      };
    }, f2 = function(t2, e3, i3) {
      return function() {
        var s2, r4;
        s2 = t2.select(e3.id), r4 = i3(), s2.setAttribute({ visible: r4 });
      };
    }, b2 = function(t2, e3, i3, s2) {
      return function() {
        var r4, o3;
        r4 = t2.select(e3.id), o3 = i3(), "strokewidth" === s2 ? r4.visProp.strokewidth = o3 : (o3 = D.Z.rgba2rgbo(o3), r4.visProp[s2 + "color"] = o3[0], r4.visProp[s2 + "opacity"] = o3[1]);
      };
    }, g2 = function(t2, e3, i3) {
      return function() {
        t2.select(e3.id).position = i3();
      };
    }, m2 = function(t2, e3, i3) {
      return function() {
        t2.select(e3.id).setStyle(i3());
      };
    };
    if (!(u2 < 0)) {
      for (; u2 >= 0; ) {
        if (o2 = (r3 = e2.slice(u2 + 6, p2)).indexOf("="), n2 = r3.slice(0, o2), a2 = r3.slice(o2 + 1), o2 = n2.indexOf("."), h2 = n2.slice(0, o2), l2 = this.elementsByName[s.Z.unescapeHTML(h2)], c2 = n2.slice(o2 + 1).replace(/\s+/g, "").toLowerCase(), a2 = s.Z.createFunction(a2, this, "", true), s.Z.exists(this.elementsByName[h2]))
          switch (c2) {
            case "x":
              d2.push(_2(this, l2, a2, 2));
              break;
            case "y":
              d2.push(_2(this, l2, a2, 1));
              break;
            case "visible":
              d2.push(f2(this, l2, a2));
              break;
            case "position":
              d2.push(g2(this, l2, a2));
              break;
            case "stroke":
              d2.push(b2(this, l2, a2, "stroke"));
              break;
            case "style":
              d2.push(m2(this, l2, a2));
              break;
            case "strokewidth":
              d2.push(b2(this, l2, a2, "strokewidth"));
              break;
            case "fill":
              d2.push(b2(this, l2, a2, "fill"));
              break;
            case "label":
              break;
            default:
              t.Z.debug("property '" + c2 + "' in conditions not yet implemented:" + a2);
          }
        else
          t.Z.debug("debug conditions: |" + h2 + "| undefined");
        u2 = (e2 = e2.slice(p2 + 7)).indexOf("<data>"), p2 = e2.indexOf("</data>");
      }
      this.updateConditions = function() {
        var t2;
        for (t2 = 0; t2 < d2.length; t2++)
          d2[t2]();
        return this.prepareUpdate().updateElements(), true;
      }, this.updateConditions();
    }
  }, updateConditions: function() {
    return false;
  }, calculateSnapSizes: function() {
    var t2 = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], this), e2 = new c.Z(i2.Z.COORDS_BY_USER, [this.options.grid.gridX, this.options.grid.gridY], this), s2 = t2.scrCoords[1] - e2.scrCoords[1], r3 = t2.scrCoords[2] - e2.scrCoords[2];
    for (this.options.grid.snapSizeX = this.options.grid.gridX; Math.abs(s2) > 25; )
      this.options.grid.snapSizeX *= 2, s2 /= 2;
    for (this.options.grid.snapSizeY = this.options.grid.gridY; Math.abs(r3) > 25; )
      this.options.grid.snapSizeY *= 2, r3 /= 2;
    return this;
  }, applyZoom: function() {
    return this.updateCoords().calculateSnapSizes().clearTraces().fullUpdate(), this;
  }, zoomIn: function(t2, e2) {
    var i3 = this.getBoundingBox(), r3 = this.attr.zoom.factorx, o2 = this.attr.zoom.factory, n2 = (i3[2] - i3[0]) * (1 - 1 / r3), a2 = (i3[1] - i3[3]) * (1 - 1 / o2), h2 = 0.5, l2 = 0.5, c2 = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
    return this.zoomX > this.attr.zoom.max && r3 > 1 || this.zoomY > this.attr.zoom.max && o2 > 1 || this.zoomX < c2 && r3 < 1 || this.zoomY < c2 && o2 < 1 ? this : (s.Z.isNumber(t2) && s.Z.isNumber(e2) && (h2 = (t2 - i3[0]) / (i3[2] - i3[0]), l2 = (i3[1] - e2) / (i3[1] - i3[3])), this.setBoundingBox([i3[0] + n2 * h2, i3[1] - a2 * l2, i3[2] - n2 * (1 - h2), i3[3] + a2 * (1 - l2)], this.keepaspectratio, "update"), this.applyZoom());
  }, zoomOut: function(t2, e2) {
    var i3 = this.getBoundingBox(), r3 = this.attr.zoom.factorx, o2 = this.attr.zoom.factory, n2 = (i3[2] - i3[0]) * (1 - r3), a2 = (i3[1] - i3[3]) * (1 - o2), h2 = 0.5, l2 = 0.5, c2 = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
    return this.zoomX < c2 || this.zoomY < c2 ? this : (s.Z.isNumber(t2) && s.Z.isNumber(e2) && (h2 = (t2 - i3[0]) / (i3[2] - i3[0]), l2 = (i3[1] - e2) / (i3[1] - i3[3])), this.setBoundingBox([i3[0] + n2 * h2, i3[1] - a2 * l2, i3[2] - n2 * (1 - h2), i3[3] + a2 * (1 - l2)], this.keepaspectratio, "update"), this.applyZoom());
  }, zoom100: function() {
    var t2, e2, i3;
    return s.Z.exists(this.attr.boundingbox) ? this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, "reset") : (e2 = ((t2 = this.getBoundingBox())[2] - t2[0]) * (1 - this.zoomX) * 0.5, i3 = (t2[1] - t2[3]) * (1 - this.zoomY) * 0.5, this.setBoundingBox([t2[0] + e2, t2[1] - i3, t2[2] - e2, t2[3] + i3], this.keepaspectratio, "reset")), this.applyZoom();
  }, zoomAllPoints: function() {
    var t2, e2, i3, r3, o2 = 0, n2 = 0, a2 = 0, h2 = 0, l2 = this.objectsList.length;
    for (t2 = 0; t2 < l2; t2++)
      r3 = this.objectsList[t2], s.Z.isPoint(r3) && r3.visPropCalc.visible && (r3.coords.usrCoords[1] < o2 ? o2 = r3.coords.usrCoords[1] : r3.coords.usrCoords[1] > n2 && (n2 = r3.coords.usrCoords[1]), r3.coords.usrCoords[2] > h2 ? h2 = r3.coords.usrCoords[2] : r3.coords.usrCoords[2] < a2 && (a2 = r3.coords.usrCoords[2]));
    return e2 = 50 / this.unitX, i3 = 50 / this.unitY, this.setBoundingBox([o2 - e2, h2 + i3, n2 + e2, a2 - i3], this.keepaspectratio, "update"), this.applyZoom();
  }, zoomElements: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2, l2 = [1 / 0, -1 / 0, -1 / 0, 1 / 0];
    if (!s.Z.isArray(t2) || 0 === t2.length)
      return this;
    for (e2 = 0; e2 < t2.length; e2++)
      i3 = this.select(t2[e2]).bounds(), s.Z.isArray(i3) && (i3[0] < l2[0] && (l2[0] = i3[0]), i3[1] > l2[1] && (l2[1] = i3[1]), i3[2] > l2[2] && (l2[2] = i3[2]), i3[3] < l2[3] && (l2[3] = i3[3]));
    return s.Z.isArray(l2) && (r3 = 0.5 * (l2[0] + l2[2]), o2 = 0.5 * (l2[1] + l2[3]), n2 = 1.5 * (l2[2] - l2[0]) * 0.5, a2 = 1.5 * (l2[1] - l2[3]) * 0.5, h2 = Math.max(n2, a2), this.setBoundingBox([r3 - h2, o2 + h2, r3 + h2, o2 - h2], this.keepaspectratio, "update")), this;
  }, setZoom: function(t2, e2) {
    var i3 = this.attr.zoom.factorx, s2 = this.attr.zoom.factory;
    return this.attr.zoom.factorx = t2 / this.zoomX, this.attr.zoom.factory = e2 / this.zoomY, this.zoomIn(), this.attr.zoom.factorx = i3, this.attr.zoom.factory = s2, this;
  }, removeObject: function(e2, r3) {
    var o2, n2;
    if (s.Z.isArray(e2)) {
      for (n2 = 0; n2 < e2.length; n2++)
        this.removeObject(e2[n2]);
      return this;
    }
    if (e2 = this.select(e2), !s.Z.exists(e2) || s.Z.isString(e2))
      return this;
    try {
      for (o2 in e2.childElements)
        e2.childElements.hasOwnProperty(o2) && e2.childElements[o2].board.removeObject(e2.childElements[o2]);
      for (o2 in e2.objects)
        e2.objects.hasOwnProperty(o2) && e2.objects[o2].board.removeObject(e2.objects[o2]);
      if (r3)
        for (o2 in this.objects)
          this.objects.hasOwnProperty(o2) && s.Z.exists(this.objects[o2].childElements) && s.Z.exists(this.objects[o2].childElements.hasOwnProperty(e2.id)) && (delete this.objects[o2].childElements[e2.id], delete this.objects[o2].descendants[e2.id]);
      else if (s.Z.exists(e2.ancestors))
        for (o2 in e2.ancestors)
          e2.ancestors.hasOwnProperty(o2) && s.Z.exists(e2.ancestors[o2].childElements) && s.Z.exists(e2.ancestors[o2].childElements.hasOwnProperty(e2.id)) && (delete e2.ancestors[o2].childElements[e2.id], delete e2.ancestors[o2].descendants[e2.id]);
      if (e2._pos > -1)
        for (this.objectsList.splice(e2._pos, 1), o2 = e2._pos; o2 < this.objectsList.length; o2++)
          this.objectsList[o2]._pos--;
      else
        e2.type !== i2.Z.OBJECT_TYPE_TURTLE && t.Z.debug("Board.removeObject: object " + e2.id + " not found in list.");
      delete this.objects[e2.id], delete this.elementsByName[e2.name], e2.visProp && s.Z.evaluate(e2.visProp.trace) && e2.clearTrace(), s.Z.exists(e2.remove) && e2.remove();
    } catch (i3) {
      t.Z.debug(e2.id + ": Could not be removed: " + i3);
    }
    return this.update(), this;
  }, removeAncestors: function(t2) {
    var e2;
    for (e2 in t2.ancestors)
      t2.ancestors.hasOwnProperty(e2) && this.removeAncestors(t2.ancestors[e2]);
    return this.removeObject(t2), this;
  }, initGeonextBoard: function() {
    var t2, e2, i3;
    return t2 = this.create("point", [0, 0], { id: this.id + "g00e0", name: "Ursprung", withLabel: false, visible: false, fixed: true }), e2 = this.create("point", [1, 0], { id: this.id + "gX0e0", name: "Punkt_1_0", withLabel: false, visible: false, fixed: true }), i3 = this.create("point", [0, 1], { id: this.id + "gY0e0", name: "Punkt_0_1", withLabel: false, visible: false, fixed: true }), this.create("line", [t2, e2], { id: this.id + "gXLe0", name: "X-Achse", withLabel: false, visible: false }), this.create("line", [t2, i3], { id: this.id + "gYLe0", name: "Y-Achse", withLabel: false, visible: false }), this;
  }, resizeContainer: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2, h2;
    return o2 = this.canvasWidth, n2 = this.canvasHeight, s2 || (r3 = this.getBoundingBox()), this.canvasWidth = parseFloat(t2), this.canvasHeight = parseFloat(e2), i3 || (this.containerObj.style.width = this.canvasWidth + "px", this.containerObj.style.height = this.canvasHeight + "px"), this.renderer.resize(this.canvasWidth, this.canvasHeight), s2 ? (a2 = (this.canvasWidth - o2) / 2, h2 = (this.canvasHeight - n2) / 2, this.moveOrigin(this.origin.scrCoords[1] + a2, this.origin.scrCoords[2] + h2)) : this.setBoundingBox(r3, this.keepaspectratio, "keep"), this;
  }, showDependencies: function() {
    var t2, e2, i3, s2, r3;
    for (t2 in e2 = "<p>\n", this.objects)
      if (this.objects.hasOwnProperty(t2)) {
        for (i3 in r3 = 0, this.objects[t2].childElements)
          this.objects[t2].childElements.hasOwnProperty(i3) && (r3 += 1);
        for (i3 in r3 >= 0 && (e2 += "<strong>" + this.objects[t2].id + ":</strong> "), this.objects[t2].childElements)
          this.objects[t2].childElements.hasOwnProperty(i3) && (e2 += this.objects[t2].childElements[i3].id + "(" + this.objects[t2].childElements[i3].name + "), ");
        e2 += "<p>\n";
      }
    return e2 += "</p>\n", (s2 = window.open()).document.open(), s2.document.write(e2), s2.document.close(), this;
  }, showXML: function() {
    var t2 = window.open("");
    return t2.document.open(), t2.document.write("<pre>" + s.Z.escapeHTML(this.xmlString) + "</pre>"), t2.document.close(), this;
  }, prepareUpdate: function() {
    var t2, e2, i3 = this.objectsList.length;
    for (t2 = 0; t2 < i3; t2++)
      (e2 = this.objectsList[t2]).needsUpdate = e2.needsRegularUpdate || this.needsFullUpdate;
    for (t2 in this.groups)
      this.groups.hasOwnProperty(t2) && ((e2 = this.groups[t2]).needsUpdate = e2.needsRegularUpdate || this.needsFullUpdate);
    return this;
  }, updateElements: function(t2) {
    var e2, r3;
    for (t2 = this.select(t2), e2 = 0; e2 < this.objectsList.length; e2++)
      r3 = this.objectsList[e2], this.needsFullUpdate && r3.elementClass === i2.Z.OBJECT_CLASS_TEXT && r3.updateSize(), r3.update(!s.Z.exists(t2) || r3.id !== t2.id).updateVisibility();
    for (e2 in this.groups)
      this.groups.hasOwnProperty(e2) && this.groups[e2].update(t2);
    return this;
  }, updateRenderer: function() {
    var t2, e2 = this.objectsList.length;
    if (this.renderer) {
      if ("canvas" === this.renderer.type)
        this.updateRendererCanvas();
      else
        for (t2 = 0; t2 < e2; t2++)
          this.objectsList[t2].updateRenderer();
      return this;
    }
  }, updateRendererCanvas: function() {
    var t2, e2, i3, s2, r3, o2 = this.objectsList.length, n2 = this.options.layer, a2 = this.options.layer.numlayers, h2 = Number.NEGATIVE_INFINITY;
    for (i3 = 0; i3 < a2; i3++) {
      for (r3 in s2 = Number.POSITIVE_INFINITY, n2)
        n2.hasOwnProperty(r3) && n2[r3] > h2 && n2[r3] < s2 && (s2 = n2[r3]);
      for (h2 = s2, t2 = 0; t2 < o2; t2++)
        (e2 = this.objectsList[t2]).visProp.layer === s2 && e2.prepareUpdate().updateRenderer();
    }
    return this;
  }, addHook: function(e2, i3, r3) {
    return t.Z.deprecated("Board.addHook()", "Board.on()"), i3 = s.Z.def(i3, "update"), r3 = s.Z.def(r3, this), this.hooks.push([i3, e2]), this.on(i3, e2, r3), this.hooks.length - 1;
  }, addEvent: t.Z.shortcut(t.Z.Board.prototype, "on"), removeHook: function(e2) {
    return t.Z.deprecated("Board.removeHook()", "Board.off()"), this.hooks[e2] && (this.off(this.hooks[e2][0], this.hooks[e2][1]), this.hooks[e2] = null), this;
  }, removeEvent: t.Z.shortcut(t.Z.Board.prototype, "off"), updateHooks: function(e2) {
    var i3 = Array.prototype.slice.call(arguments, 0);
    return t.Z.deprecated("Board.updateHooks()", "Board.triggerEventHandlers()"), i3[0] = s.Z.def(i3[0], "update"), this.triggerEventHandlers([i3[0]], arguments), this;
  }, addChild: function(t2) {
    return s.Z.exists(t2) && s.Z.exists(t2.containerObj) && (this.dependentBoards.push(t2), this.update()), this;
  }, removeChild: function(t2) {
    var e2;
    for (e2 = this.dependentBoards.length - 1; e2 >= 0; e2--)
      this.dependentBoards[e2] === t2 && this.dependentBoards.splice(e2, 1);
    return this;
  }, update: function(t2) {
    var e2, i3, r3, o2, n2;
    if (this.inUpdate || this.isSuspendedUpdate)
      return this;
    for (this.inUpdate = true, "all" === this.attr.minimizereflow && this.containerObj && "vml" !== this.renderer.type && (n2 = this.document.activeElement, o2 = this.renderer.removeToInsertLater(this.containerObj)), "svg" === this.attr.minimizereflow && "svg" === this.renderer.type && (n2 = this.document.activeElement, o2 = this.renderer.removeToInsertLater(this.renderer.svgRoot)), this.prepareUpdate().updateElements(t2).updateConditions(), this.renderer.suspendRedraw(this), this.updateRenderer(), this.renderer.unsuspendRedraw(), this.triggerEventHandlers(["update"], []), o2 && (o2(), n2.focus()), i3 = this.dependentBoards.length, e2 = 0; e2 < i3; e2++)
      r3 = this.dependentBoards[e2], s.Z.exists(r3) && r3 !== this && (r3.updateQuality = this.updateQuality, r3.prepareUpdate().updateElements().updateConditions(), r3.renderer.suspendRedraw(), r3.updateRenderer(), r3.renderer.unsuspendRedraw(), r3.triggerEventHandlers(["update"], []));
    return this.inUpdate = false, this;
  }, fullUpdate: function() {
    return this.needsFullUpdate = true, this.update(), this.needsFullUpdate = false, this;
  }, addGrid: function() {
    return this.create("grid", []), this;
  }, removeGrids: function() {
    var t2;
    for (t2 = 0; t2 < this.grids.length; t2++)
      this.removeObject(this.grids[t2]);
    return this.grids.length = 0, this.update(), this;
  }, create: function(e2, i3, r3) {
    var o2, n2;
    for (e2 = e2.toLowerCase(), s.Z.exists(i3) || (i3 = []), s.Z.exists(r3) || (r3 = {}), n2 = 0; n2 < i3.length; n2++)
      !s.Z.isString(i3[n2]) || "text" === e2 && 2 === n2 || "solidofrevolution3d" === e2 && 2 === n2 || !("input" !== e2 && "checkbox" !== e2 && "button" !== e2 || 2 !== n2 && 3 !== n2) || "curve" === e2 && n2 > 0 || (i3[n2] = this.select(i3[n2]));
    if (!s.Z.isFunction(t.Z.elements[e2]))
      throw new Error("JSXGraph: create: Unknown element type given: " + e2);
    return o2 = t.Z.elements[e2](this, i3, r3), s.Z.exists(o2) ? (o2.prepareUpdate && o2.update && o2.updateRenderer && o2.fullUpdate(), o2) : (t.Z.debug("JSXGraph: create: failure creating " + e2), o2);
  }, createElement: function() {
    return t.Z.deprecated("Board.createElement()", "Board.create()"), this.create.apply(this, arguments);
  }, clearTraces: function() {
    var t2;
    for (t2 = 0; t2 < this.objectsList.length; t2++)
      this.objectsList[t2].clearTrace();
    return this.numTraces = 0, this;
  }, suspendUpdate: function() {
    return this.inUpdate || (this.isSuspendedUpdate = true), this;
  }, unsuspendUpdate: function() {
    return this.isSuspendedUpdate && (this.isSuspendedUpdate = false, this.fullUpdate()), this;
  }, setBoundingBox: function(t2, i3, r3) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2 = 0, b2 = 0, g2 = 1, m2 = e.Z.getDimensions(this.container, this.document);
    return s.Z.isArray(t2) ? (t2[0] < this.maxboundingbox[0] || t2[1] > this.maxboundingbox[1] || t2[2] > this.maxboundingbox[2] || t2[3] < this.maxboundingbox[3] || (s.Z.exists(r3) || (r3 = "reset"), h2 = this.unitX, l2 = this.unitY, this.canvasWidth = parseFloat(m2.width), this.canvasHeight = parseFloat(m2.height), a2 = this.canvasWidth, n2 = this.canvasHeight, i3 ? (c2 = h2 / l2, "keep" === r3 && (g2 = this.zoomX / this.zoomY), p2 = h2 * (d2 = t2[2] - t2[0]), _2 = l2 * (u2 = t2[1] - t2[3]), a2 >= n2 ? p2 >= _2 ? (this.unitY = n2 / u2, this.unitX = this.unitY * c2) : (this.unitY = n2 / Math.abs(d2) * o.Z.sign(u2) / g2, this.unitX = this.unitY * c2) : _2 > p2 ? (this.unitX = a2 / d2, this.unitY = this.unitX / c2) : (this.unitX = a2 / Math.abs(u2) * o.Z.sign(d2) * g2, this.unitY = this.unitX / c2), f2 = 0.5 * (a2 / this.unitX - d2), b2 = 0.5 * (n2 / this.unitY - u2), this.keepaspectratio = true) : (this.unitX = a2 / (t2[2] - t2[0]), this.unitY = n2 / (t2[1] - t2[3]), this.keepaspectratio = false), this.moveOrigin(-this.unitX * (t2[0] - f2), this.unitY * (t2[1] + b2)), "update" === r3 ? (this.zoomX *= this.unitX / h2, this.zoomY *= this.unitY / l2) : "reset" === r3 && (this.zoomX = s.Z.exists(this.attr.zoomx) ? this.attr.zoomx : 1, this.zoomY = s.Z.exists(this.attr.zoomy) ? this.attr.zoomy : 1)), this) : this;
  }, getBoundingBox: function() {
    var t2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [0, 0], this).usrCoords, e2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords;
    return [t2[1], t2[2], e2[1], e2[2]];
  }, addAnimation: function(t2) {
    var e2 = this;
    return this.animationObjects[t2.id] = t2, this.animationIntervalCode || (this.animationIntervalCode = window.setInterval(function() {
      e2.animate();
    }, t2.board.attr.animationdelay)), this;
  }, stopAllAnimation: function() {
    var t2;
    for (t2 in this.animationObjects)
      this.animationObjects.hasOwnProperty(t2) && s.Z.exists(this.animationObjects[t2]) && (this.animationObjects[t2] = null, delete this.animationObjects[t2]);
    return window.clearInterval(this.animationIntervalCode), delete this.animationIntervalCode, this;
  }, animate: function() {
    var t2, e2, r3, o2, n2, a2, h2, l2, c2 = 0, d2 = null;
    for (e2 in this.animationObjects)
      if (this.animationObjects.hasOwnProperty(e2) && s.Z.exists(this.animationObjects[e2])) {
        if (c2 += 1, (r3 = this.animationObjects[e2]).animationPath && (o2 = s.Z.isFunction(r3.animationPath) ? r3.animationPath((/* @__PURE__ */ new Date()).getTime() - r3.animationStart) : r3.animationPath.pop(), !s.Z.exists(o2) || !s.Z.isArray(o2) && isNaN(o2) ? delete r3.animationPath : (r3.setPositionDirectly(i2.Z.COORDS_BY_USER, o2), r3.fullUpdate(), d2 = r3)), r3.animationData) {
          for (n2 in h2 = 0, r3.animationData)
            r3.animationData.hasOwnProperty(n2) && (a2 = r3.animationData[n2].pop(), s.Z.exists(a2) ? (h2 += 1, (t2 = {})[n2] = a2, r3.setAttribute(t2)) : delete r3.animationData[a2]);
          0 === h2 && delete r3.animationData;
        }
        s.Z.exists(r3.animationData) || s.Z.exists(r3.animationPath) || (this.animationObjects[e2] = null, delete this.animationObjects[e2], s.Z.exists(r3.animationCallback) && (l2 = r3.animationCallback, r3.animationCallback = null, l2()));
      }
    return 0 === c2 ? (window.clearInterval(this.animationIntervalCode), delete this.animationIntervalCode) : this.update(d2), this;
  }, migratePoint: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2 = false;
    for (o2 in t2 = this.select(t2), e2 = this.select(e2), s.Z.exists(t2.label) && (l2 = t2.label.id, c2 = true, this.removeObject(t2.label)), t2.childElements)
      if (t2.childElements.hasOwnProperty(o2)) {
        for (n2 in a2 = false, r3 = t2.childElements[o2])
          r3.hasOwnProperty(n2) && r3[n2] === t2 && (r3[n2] = e2, a2 = true);
        for (a2 && delete t2.childElements[o2], h2 = 0; h2 < r3.parents.length; h2++)
          r3.parents[h2] === t2.id && (r3.parents[h2] = e2.id);
        e2.addChild(r3);
      }
    return i3 && (c2 && (delete e2.childElements[l2], delete e2.descendants[l2]), e2.label && this.removeObject(e2.label), delete this.elementsByName[e2.name], e2.name = t2.name, c2 && e2.createLabel()), this.removeObject(t2), s.Z.exists(e2.name) && "" !== e2.name && (this.elementsByName[e2.name] = e2), this.fullUpdate(), this;
  }, emulateColorblindness: function(e2) {
    var i3, r3;
    if (s.Z.exists(e2) || (e2 = "none"), this.currentCBDef === e2)
      return this;
    for (i3 in this.objects)
      this.objects.hasOwnProperty(i3) && (r3 = this.objects[i3], "none" !== e2 ? ("none" === this.currentCBDef && (r3.visPropOriginal = { strokecolor: r3.visProp.strokecolor, fillcolor: r3.visProp.fillcolor, highlightstrokecolor: r3.visProp.highlightstrokecolor, highlightfillcolor: r3.visProp.highlightfillcolor }), r3.setAttribute({ strokecolor: D.Z.rgb2cb(s.Z.evaluate(r3.visPropOriginal.strokecolor), e2), fillcolor: D.Z.rgb2cb(s.Z.evaluate(r3.visPropOriginal.fillcolor), e2), highlightstrokecolor: D.Z.rgb2cb(s.Z.evaluate(r3.visPropOriginal.highlightstrokecolor), e2), highlightfillcolor: D.Z.rgb2cb(s.Z.evaluate(r3.visPropOriginal.highlightfillcolor), e2) })) : s.Z.exists(r3.visPropOriginal) && t.Z.extend(r3.visProp, r3.visPropOriginal));
    return this.currentCBDef = e2, this.update(), this;
  }, select: function(t2, e2) {
    var i3, r3, o2, n2, a2 = t2;
    if (null === a2)
      return a2;
    if (s.Z.isString(a2) && "" !== a2)
      s.Z.exists(this.objects[a2]) ? a2 = this.objects[a2] : s.Z.exists(this.elementsByName[a2]) ? a2 = this.elementsByName[a2] : s.Z.exists(this.groups[a2]) && (a2 = this.groups[a2]);
    else if (!e2 && (s.Z.isFunction(a2) || s.Z.isObject(a2) && !s.Z.isFunction(a2.setAttribute))) {
      for (r3 = {}, n2 = (i3 = s.Z.filterElements(this.objectsList, a2)).length, o2 = 0; o2 < n2; o2++)
        r3[i3[o2].id] = i3[o2];
      a2 = new L(r3);
    } else
      s.Z.isObject(a2) && s.Z.exists(a2.id) && !s.Z.exists(this.objects[a2.id]) && (a2 = null);
    return a2;
  }, hasPoint: function(t2, e2) {
    var i3 = t2, r3 = e2, o2 = this.getBoundingBox();
    return s.Z.exists(t2) && s.Z.isArray(t2.usrCoords) && (i3 = t2.usrCoords[1], r3 = t2.usrCoords[2]), !!(s.Z.isNumber(i3) && s.Z.isNumber(r3) && o2[0] < i3 && i3 < o2[2] && o2[1] > r3 && r3 > o2[3]);
  }, updateCSSTransforms: function() {
    var t2 = this.containerObj, i3 = t2, r3 = t2;
    if (this.cssTransMat = e.Z.getCSSTransformMatrix(i3), s.Z.exists(i3.getRootNode)) {
      for (i3 = i3.parentNode === i3.getRootNode() ? i3.parentNode.host : i3.parentNode; i3; )
        this.cssTransMat = o.Z.matMatMult(e.Z.getCSSTransformMatrix(i3), this.cssTransMat), i3 = i3.parentNode === i3.getRootNode() ? i3.parentNode.host : i3.parentNode;
      this.cssTransMat = o.Z.inverse(this.cssTransMat);
    } else {
      for (i3 = i3.offsetParent; i3; ) {
        for (this.cssTransMat = o.Z.matMatMult(e.Z.getCSSTransformMatrix(i3), this.cssTransMat), r3 = r3.parentNode; r3 !== i3; )
          this.cssTransMat = o.Z.matMatMult(e.Z.getCSSTransformMatrix(i3), this.cssTransMat), r3 = r3.parentNode;
        i3 = i3.offsetParent;
      }
      this.cssTransMat = o.Z.inverse(this.cssTransMat);
    }
    return this;
  }, startSelectionMode: function() {
    this.selectingMode = true, this.selectionPolygon.setAttribute({ visible: true }), this.selectingBox = [[0, 0], [0, 0]], this._setSelectionPolygonFromBox(), this.selectionPolygon.fullUpdate();
  }, stopSelectionMode: function() {
    return this.selectingMode = false, this.selectionPolygon.setAttribute({ visible: false }), [this.selectionPolygon.vertices[0].coords, this.selectionPolygon.vertices[2].coords];
  }, _startSelecting: function(t2) {
    this.isSelecting = true, this.selectingBox = [[t2[0], t2[1]], [t2[0], t2[1]]], this._setSelectionPolygonFromBox();
  }, _moveSelecting: function(t2) {
    this.isSelecting && (this.selectingBox[1] = [t2[0], t2[1]], this._setSelectionPolygonFromBox(), this.selectionPolygon.fullUpdate());
  }, _stopSelecting: function(t2) {
    var e2 = this.getMousePosition(t2);
    this.isSelecting = false, this.selectingBox[1] = [e2[0], e2[1]], this._setSelectionPolygonFromBox();
  }, _setSelectionPolygonFromBox: function() {
    var e2 = this.selectingBox[0], i3 = this.selectingBox[1];
    this.selectionPolygon.vertices[0].setPositionDirectly(t.Z.COORDS_BY_SCREEN, [e2[0], e2[1]]), this.selectionPolygon.vertices[1].setPositionDirectly(t.Z.COORDS_BY_SCREEN, [e2[0], i3[1]]), this.selectionPolygon.vertices[2].setPositionDirectly(t.Z.COORDS_BY_SCREEN, [i3[0], i3[1]]), this.selectionPolygon.vertices[3].setPositionDirectly(t.Z.COORDS_BY_SCREEN, [i3[0], e2[1]]);
  }, _testForSelection: function(t2) {
    this._isRequiredKeyPressed(t2, "selection") && (s.Z.exists(this.selectionPolygon) || this._createSelectionPolygon(this.attr), this.startSelectionMode());
  }, _createSelectionPolygon: function(t2) {
    var e2;
    return s.Z.exists(this.selectionPolygon) || true === (e2 = s.Z.copyAttributes(t2, M.Z, "board", "selection")).enabled && (this.selectionPolygon = this.create("polygon", [[0, 0], [0, 0], [0, 0], [0, 0]], e2)), this;
  }, __evt__down: function(t2) {
  }, __evt__mousedown: function(t2) {
  }, __evt__pendown: function(t2) {
  }, __evt__pointerdown: function(t2) {
  }, __evt__touchstart: function(t2) {
  }, __evt__up: function(t2) {
  }, __evt__mouseup: function(t2) {
  }, __evt__pointerup: function(t2) {
  }, __evt__touchend: function(t2) {
  }, __evt__move: function(t2, e2) {
  }, __evt__mousemove: function(t2, e2) {
  }, __evt__penmove: function(t2, e2) {
  }, __evt__pointermove: function(t2, e2) {
  }, __evt__touchmove: function(t2, e2) {
  }, __evt__keymove: function(t2, e2) {
  }, __evt__hit: function(t2, e2, i3) {
  }, __evt__mousehit: function(t2, e2, i3) {
  }, __evt__update: function() {
  }, __evt__boundingbox: function() {
  }, __evt__startselecting: function() {
  }, __evt__mousestartselecting: function() {
  }, __evt__pointerstartselecting: function() {
  }, __evt__touchstartselecting: function() {
  }, __evt__stopselecting: function() {
  }, __evt__mousestopselecting: function() {
  }, __evt__pointerstopselecting: function() {
  }, __evt__touchstopselecting: function() {
  }, __evt__moveselecting: function() {
  }, __evt__mousemoveselecting: function() {
  }, __evt__pointermoveselecting: function() {
  }, __evt__touchmoveselecting: function() {
  }, __evt: function() {
  }, toFullscreen: function(t2) {
    var e2, i3, r3, o2 = this.document;
    return t2 = t2 || this.container, this._fullscreen_inner_id = t2, r3 = o2.getElementById(t2), e2 = "fullscreenwrap_" + t2, o2.getElementById(e2) ? i3 = o2.getElementById(e2) : ((i3 = document.createElement("div")).classList.add("JXG_wrap_private"), i3.setAttribute("id", e2), r3.parentNode.insertBefore(i3, r3), i3.appendChild(r3)), i3.requestFullscreen = i3.requestFullscreen || i3.webkitRequestFullscreen || i3.mozRequestFullScreen || i3.msRequestFullscreen, null === (void 0 !== o2.fullscreenElement ? o2.fullscreenElement : void 0 !== o2.webkitFullscreenElement ? o2.webkitFullscreenElement : o2.msFullscreenElement) ? i3.requestFullscreen && i3.requestFullscreen() : s.Z.exists(document.exitFullscreen) ? document.exitFullscreen() : s.Z.exists(document.webkitExitFullscreen) && document.webkitExitFullscreen(), this;
  }, fullscreenListener: function(t2) {
    var i3, r3, o2, n2 = this.document;
    if (i3 = this._fullscreen_inner_id, s.Z.exists(i3)) {
      if (o2 = void 0 !== n2.fullscreenElement ? n2.fullscreenElement : void 0 !== n2.webkitFullscreenElement ? n2.webkitFullscreenElement : n2.msFullscreenElement, r3 = n2.getElementById(i3), o2)
        r3._cssFullscreenStore = { id: o2.id, isFullscreen: true, margin: r3.style.margin }, r3.style.margin = "", e.Z.scaleJSXGraphDiv(o2.id, i3, n2, s.Z.evaluate(this.attr.fullscreen.scale)), o2 = null;
      else if (s.Z.exists(r3._cssFullscreenStore)) {
        try {
          n2.styleSheets[n2.styleSheets.length - 1].deleteRule(0);
        } catch (t3) {
          console.log("JSXGraph: Could not remove CSS rules for full screen mode");
        }
        r3._cssFullscreenStore.isFullscreen = false, r3.style.margin = r3._cssFullscreenStore.margin;
      }
      this.updateCSSTransforms();
    }
  }, addLogEntry: function(t2, e2, i3) {
    var r3, o2, n2 = this.userLog.length - 1;
    return s.Z.exists(e2.elementClass) && (o2 = e2.id), s.Z.evaluate(this.attr.logging.enabled) && (r3 = (/* @__PURE__ */ new Date()).getTime(), n2 >= 0 && this.userLog[n2].type === t2 && this.userLog[n2].id === o2 && r3 - this.userLog[n2].end < 500 ? (this.userLog[n2].end = r3, this.userLog[n2].endpos = i3) : this.userLog.push({ type: t2, id: o2, start: r3, startpos: i3, end: r3, endpos: i3, bbox: this.getBoundingBox(), canvas: [this.canvasWidth, this.canvasHeight], zoom: [this.zoomX, this.zoomY] })), this;
  }, createRoulette: function(t2, e2, i3, s2, r3, o2, n2) {
    var a2 = this;
    return new function() {
      var h2, c2 = 0, d2 = 0, u2 = 0, p2 = i3, _2 = l.Z.root(function(i4) {
        var s3 = t2.X(p2), r4 = t2.Y(p2), o3 = e2.X(i4), n3 = e2.Y(i4);
        return (s3 - o3) * (s3 - o3) + (r4 - n3) * (r4 - n3);
      }, [0, 2 * Math.PI]), f2 = 0, b2 = 0, g2 = a2.create("transform", [function() {
        return c2;
      }], { type: "rotate" }), m2 = a2.create("transform", [function() {
        return c2;
      }, function() {
        return t2.X(p2);
      }, function() {
        return t2.Y(p2);
      }], { type: "rotate" }), v2 = a2.create("transform", [function() {
        return d2;
      }, function() {
        return u2;
      }], { type: "translate" }), Z2 = function(t3, e3, i4) {
        var s3 = l.Z.D(t3.X)(e3), r4 = l.Z.D(t3.Y)(e3), o3 = l.Z.D(t3.X)(i4), n3 = l.Z.D(t3.Y)(i4), a3 = l.Z.D(t3.X)(0.5 * (e3 + i4)), h3 = l.Z.D(t3.Y)(0.5 * (e3 + i4)), c3 = Math.sqrt(s3 * s3 + r4 * r4), d3 = Math.sqrt(o3 * o3 + n3 * n3);
        return (c3 + 4 * Math.sqrt(a3 * a3 + h3 * h3) + d3) * (i4 - e3) / 6;
      }, C2 = function(t3) {
        return h2 - Z2(e2, _2, t3);
      }, y2 = Math.PI / 18, P2 = 9 * y2, E2 = null;
      return this.rolling = function() {
        var i4, o3, E3, O2, x2;
        h2 = Z2(t2, p2, f2 = p2 + r3 * s2), b2 = l.Z.root(C2, _2), i4 = new T(t2.X(f2), t2.Y(f2)), o3 = new T(e2.X(b2), e2.Y(b2)), E3 = new T(l.Z.D(t2.X)(f2), l.Z.D(t2.Y)(f2)), O2 = new T(l.Z.D(e2.X)(b2), l.Z.D(e2.Y)(b2)), x2 = T.C.div(E3, O2), c2 = Math.atan2(x2.imaginary, x2.real), x2.div(T.C.abs(x2)), x2.mult(o3), d2 = i4.real - x2.real, u2 = i4.imaginary - x2.imaginary, c2 < -y2 && c2 > -P2 ? (c2 = -y2, m2.applyOnce(n2)) : c2 > y2 && c2 < P2 ? (c2 = y2, m2.applyOnce(n2)) : (g2.applyOnce(n2), v2.applyOnce(n2), p2 = f2, _2 = b2), a2.update();
      }, this.start = function() {
        return o2 > 0 && (E2 = window.setInterval(this.rolling, o2)), this;
      }, this.stop = function() {
        return window.clearInterval(E2), this;
      }, this;
    }();
  } });
  const B = t.Z.Board;
  t.Z.SVGRenderer = function(t2, e2) {
    var i3;
    for (this.type = "svg", this.isIE = -1 !== navigator.appVersion.indexOf("MSIE") || navigator.userAgent.match(/Trident\//), this.svgRoot = null, this.svgNamespace = "http://www.w3.org/2000/svg", this.xlinkNamespace = "http://www.w3.org/1999/xlink", this.container = t2, this.container.style.MozUserSelect = "none", this.container.style.userSelect = "none", this.container.style.overflow = "hidden", "" === this.container.style.position && (this.container.style.position = "relative"), this.svgRoot = this.container.ownerDocument.createElementNS(this.svgNamespace, "svg"), this.svgRoot.style.overflow = "hidden", this.svgRoot.style.display = "block", this.resize(e2.width, e2.height), this.container.appendChild(this.svgRoot), this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace, "defs"), this.svgRoot.appendChild(this.defs), this.createShadowFilter = function(t3, e3, i4, r3, o2, n2) {
      var a2, h2, l2, c2, d2, u2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "filter");
      return u2.setAttributeNS(null, "id", t3), u2.setAttributeNS(null, "width", "300%"), u2.setAttributeNS(null, "height", "300%"), u2.setAttributeNS(null, "filterUnits", "userSpaceOnUse"), (a2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "feOffset")).setAttributeNS(null, "in", "SourceGraphic"), a2.setAttributeNS(null, "result", "offOut"), a2.setAttributeNS(null, "dx", n2[0]), a2.setAttributeNS(null, "dy", n2[1]), u2.appendChild(a2), (h2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "feColorMatrix")).setAttributeNS(null, "in", "offOut"), h2.setAttributeNS(null, "result", "colorOut"), h2.setAttributeNS(null, "type", "matrix"), "none" === e3 || !s.Z.isArray(e3) || e3.length < 3 ? h2.setAttributeNS(null, "values", "0.1 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 " + i4 + " 0") : (e3[0] /= 255, e3[1] /= 255, e3[2] /= 255, d2 = r3 + " 0 0 0 " + e3[0] + "  0 " + r3 + " 0 0 " + e3[1] + "  0 0 " + r3 + " 0 " + e3[2] + "  0 0 0 " + i4 + " 0", h2.setAttributeNS(null, "values", d2)), u2.appendChild(h2), (l2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "feGaussianBlur")).setAttributeNS(null, "in", "colorOut"), l2.setAttributeNS(null, "result", "blurOut"), l2.setAttributeNS(null, "stdDeviation", o2), u2.appendChild(l2), (c2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "feBlend")).setAttributeNS(null, "in", "SourceGraphic"), c2.setAttributeNS(null, "in2", "blurOut"), c2.setAttributeNS(null, "mode", "normal"), u2.appendChild(c2), u2;
    }, this.defs.appendChild(this.createShadowFilter(this.container.id + "_f1", "none", 1, 0.1, 3, [5, 5])), this.toURL = function() {
      var t3 = Array.prototype.slice.call(arguments).join("");
      return s.Z.exists(CSS) && s.Z.exists(CSS.escape) && (t3 = CSS.escape(t3)), "url(#" + t3 + ")";
    }, this.layer = [], i3 = 0; i3 < M.Z.layer.numlayers; i3++)
      this.layer[i3] = this.container.ownerDocument.createElementNS(this.svgNamespace, "g"), this.svgRoot.appendChild(this.layer[i3]);
    try {
      this.foreignObjLayer = this.container.ownerDocument.createElementNS(this.svgNamespace, "foreignObject"), this.foreignObjLayer.setAttribute("display", "none"), this.foreignObjLayer.setAttribute("x", 0), this.foreignObjLayer.setAttribute("y", 0), this.foreignObjLayer.setAttribute("width", "100%"), this.foreignObjLayer.setAttribute("height", "100%"), this.foreignObjLayer.setAttribute("id", this.container.id + "_foreignObj"), this.svgRoot.appendChild(this.foreignObjLayer), this.supportsForeignObject = true;
    } catch (t3) {
      this.supportsForeignObject = false;
    }
    this.dashArray = ["2, 2", "5, 5", "10, 10", "20, 20", "20, 10, 10, 10", "20, 5, 10, 5"];
  }, t.Z.SVGRenderer.prototype = new N(), t.Z.extend(t.Z.SVGRenderer.prototype, { _createArrowHead: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = t2.id + "Triangle";
    return s.Z.exists(e2) && (l2 += e2), (o2 = this.createPrim("marker", l2)).setAttributeNS(null, "stroke", s.Z.evaluate(t2.visProp.strokecolor)), o2.setAttributeNS(null, "stroke-opacity", s.Z.evaluate(t2.visProp.strokeopacity)), o2.setAttributeNS(null, "fill", s.Z.evaluate(t2.visProp.strokecolor)), o2.setAttributeNS(null, "fill-opacity", s.Z.evaluate(t2.visProp.strokeopacity)), o2.setAttributeNS(null, "stroke-width", 0), o2.setAttributeNS(null, "orient", "auto"), o2.setAttributeNS(null, "markerUnits", "strokeWidth"), n2 = this.container.ownerDocument.createElementNS(this.svgNamespace, "path"), h2 = 5, "End" === e2 ? (a2 = 0, 2 === r3 ? n2.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 L 5,5 z") : 3 === r3 ? n2.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z") : 4 === r3 ? (h2 = 3.31, n2.setAttributeNS(null, "d", "M 0.00,3.31 C 3.53,3.84 7.13,4.50 10.00,6.63 C 9.33,5.52 8.67,4.42 8.00,3.31 C 8.67,2.21 9.33,1.10 10.00,0.00 C 7.13,2.13 3.53,2.79 0.00,3.31")) : 5 === r3 ? (h2 = 3.28, n2.setAttributeNS(null, "d", "M 0.00,3.28 C 3.39,4.19 6.81,5.07 10.00,6.55 C 9.38,5.56 9.00,4.44 9.00,3.28 C 9.00,2.11 9.38,0.99 10.00,0.00 C 6.81,1.49 3.39,2.37 0.00,3.28")) : 6 === r3 ? (h2 = 2.84, n2.setAttributeNS(null, "d", "M 0.00,2.84 C 3.39,3.59 6.79,4.35 10.00,5.68 C 9.67,4.73 9.33,3.78 9.00,2.84 C 9.33,1.89 9.67,0.95 10.00,0.00 C 6.79,1.33 3.39,2.09 0.00,2.84")) : 7 === r3 ? (h2 = 5.2, n2.setAttributeNS(null, "d", "M 0.00,5.20 C 4.04,5.20 7.99,6.92 10.00,10.39 M 10.00,0.00 C 7.99,3.47 4.04,5.20 0.00,5.20")) : n2.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 z"), t2.elementClass === i2.Z.OBJECT_CLASS_LINE && (a2 = 2 === r3 ? 4.9 : 3 === r3 ? 3.3 : 4 === r3 || 5 === r3 || 6 === r3 ? 6.66 : 7 === r3 ? 0 : 10)) : (a2 = 10, 2 === r3 ? n2.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 L 5,5 z") : 3 === r3 ? (a2 = 3.3, n2.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z")) : 4 === r3 ? (h2 = 3.31, n2.setAttributeNS(null, "d", "M 10.00,3.31 C 6.47,3.84 2.87,4.50 0.00,6.63 C 0.67,5.52 1.33,4.42 2.00,3.31 C 1.33,2.21 0.67,1.10 0.00,0.00 C 2.87,2.13 6.47,2.79 10.00,3.31")) : 5 === r3 ? (h2 = 3.28, n2.setAttributeNS(null, "d", "M 10.00,3.28 C 6.61,4.19 3.19,5.07 0.00,6.55 C 0.62,5.56 1.00,4.44 1.00,3.28 C 1.00,2.11 0.62,0.99 0.00,0.00 C 3.19,1.49 6.61,2.37 10.00,3.28")) : 6 === r3 ? (h2 = 2.84, n2.setAttributeNS(null, "d", "M 10.00,2.84 C 6.61,3.59 3.21,4.35 0.00,5.68 C 0.33,4.73 0.67,3.78 1.00,2.84 C 0.67,1.89 0.33,0.95 0.00,0.00 C 3.21,1.33 6.61,2.09 10.00,2.84")) : 7 === r3 ? (h2 = 5.2, n2.setAttributeNS(null, "d", "M 10.00,5.20 C 5.96,5.20 2.01,6.92 0.00,10.39 M 0.00,0.00 C 2.01,3.47 5.96,5.20 10.00,5.20")) : n2.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 z"), t2.elementClass === i2.Z.OBJECT_CLASS_LINE && (a2 = 2 === r3 ? 5.1 : 3 === r3 ? 0.02 : 4 === r3 || 5 === r3 || 6 === r3 ? 3.33 : 7 === r3 ? 10 : 0.05)), 7 === r3 && (o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "stroke-width", 1)), o2.setAttributeNS(null, "refY", h2), o2.setAttributeNS(null, "refX", a2), o2.appendChild(n2), o2;
  }, _setArrowColor: function(t2, e2, i3, r3, o2) {
    t2 && (s.Z.isString(e2) && (7 !== o2 ? this._setAttribute(function() {
      t2.setAttributeNS(null, "stroke", e2), t2.setAttributeNS(null, "fill", e2), t2.setAttributeNS(null, "stroke-opacity", i3), t2.setAttributeNS(null, "fill-opacity", i3);
    }, r3.visPropOld.fillcolor) : this._setAttribute(function() {
      t2.setAttributeNS(null, "fill", "none"), t2.setAttributeNS(null, "stroke", e2), t2.setAttributeNS(null, "stroke-opacity", i3);
    }, r3.visPropOld.fillcolor)), this.isIE && r3.rendNode.parentNode.insertBefore(r3.rendNode, r3.rendNode));
  }, _setArrowWidth: function(t2, e2, i3, s2) {
    var r3, o2;
    t2 && (o2 = (r3 = e2) * s2, t2.setAttributeNS(null, "viewBox", "0 0 " + 10 * r3 + " " + 10 * r3), t2.setAttributeNS(null, "markerHeight", o2), t2.setAttributeNS(null, "markerWidth", o2), t2.setAttributeNS(null, "display", "inherit"), this.isIE && i3.parentNode.insertBefore(i3, i3));
  }, updateTicks: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2, l2, c2 = "", d2 = t2.ticks.length, u2 = true;
    for (e2 = 0; e2 < d2; e2++) {
      for (n2 = (r3 = t2.ticks[e2])[0], a2 = r3[1], h2 = n2.length, l2 = " M " + n2[0] + " " + a2[0], s.Z.isNumber(n2[0]) || (u2 = false), i3 = 1; u2 && i3 < h2; ++i3)
        s.Z.isNumber(n2[i3]) ? l2 += " L " + n2[i3] + " " + a2[i3] : u2 = false;
      u2 && (c2 += l2);
    }
    o2 = t2.rendNode, s.Z.exists(o2) || (o2 = this.createPrim("path", t2.id), this.appendChildPrim(o2, s.Z.evaluate(t2.visProp.layer)), t2.rendNode = o2), o2.setAttributeNS(null, "stroke", s.Z.evaluate(t2.visProp.strokecolor)), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "stroke-opacity", s.Z.evaluate(t2.visProp.strokeopacity)), o2.setAttributeNS(null, "stroke-width", s.Z.evaluate(t2.visProp.strokewidth)), this.updatePathPrim(o2, c2, t2.board);
  }, displayCopyright: function(t2, e2) {
    var i3, s2 = this.createPrim("text", "licenseText");
    s2.setAttributeNS(null, "x", "20px"), s2.setAttributeNS(null, "y", 2 + e2 + "px"), s2.setAttributeNS(null, "style", "font-family:Arial,Helvetica,sans-serif; font-size:" + e2 + "px; fill:#356AA0;  opacity:0.3;"), i3 = this.container.ownerDocument.createTextNode(t2), s2.appendChild(i3), this.appendChildPrim(s2, 0);
  }, drawInternalText: function(t2) {
    var e2 = this.createPrim("text", t2.id);
    return e2.style.whiteSpace = "nowrap", t2.rendNodeText = this.container.ownerDocument.createTextNode(""), e2.appendChild(t2.rendNodeText), this.appendChildPrim(e2, s.Z.evaluate(t2.visProp.layer)), e2;
  }, updateInternalText: function(t2) {
    var e2, i3 = t2.plaintext, r3 = t2.getAnchorX(), o2 = t2.getAnchorY();
    t2.rendNode.getAttributeNS(null, "class") !== t2.visProp.cssclass && (t2.rendNode.setAttributeNS(null, "class", s.Z.evaluate(t2.visProp.cssclass)), t2.needsSizeUpdate = true), isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2]) || (e2 = t2.coords.scrCoords[1], t2.visPropOld.left !== r3 + e2 && (t2.rendNode.setAttributeNS(null, "x", e2 + "px"), "left" === r3 ? t2.rendNode.setAttributeNS(null, "text-anchor", "start") : "right" === r3 ? t2.rendNode.setAttributeNS(null, "text-anchor", "end") : "middle" === r3 && t2.rendNode.setAttributeNS(null, "text-anchor", "middle"), t2.visPropOld.left = r3 + e2), e2 = t2.coords.scrCoords[2], t2.visPropOld.top !== o2 + e2 && (t2.rendNode.setAttributeNS(null, "y", e2 + 0.5 * this.vOffsetText + "px"), "bottom" === o2 ? t2.rendNode.setAttributeNS(null, "dominant-baseline", "text-after-edge") : "top" === o2 ? t2.rendNode.setAttributeNS(null, "dy", "1.6ex") : "middle" === o2 && t2.rendNode.setAttributeNS(null, "dy", "0.6ex"), t2.visPropOld.top = o2 + e2)), t2.htmlStr !== i3 && (t2.rendNodeText.data = i3, t2.htmlStr = i3), this.transformImage(t2, t2.transformations);
  }, updateInternalTextStyle: function(t2, e2, i3, s2) {
    this.setObjectFillColor(t2, e2, i3);
  }, drawImage: function(t2) {
    var e2 = this.createPrim("image", t2.id);
    e2.setAttributeNS(null, "preserveAspectRatio", "none"), this.appendChildPrim(e2, s.Z.evaluate(t2.visProp.layer)), t2.rendNode = e2, this.updateImage(t2);
  }, transformImage: function(t2, e2) {
    var i3, s2 = t2.rendNode, r3 = "";
    e2.length > 0 && (r3 += " matrix(" + [(i3 = this.joinTransforms(t2, e2))[1][1], i3[2][1], i3[1][2], i3[2][2], i3[1][0], i3[2][0]].join(",") + ") ", s2.setAttributeNS(null, "transform", r3));
  }, updateImageURL: function(t2) {
    var e2 = s.Z.evaluate(t2.url);
    return t2._src !== e2 && (t2.imgIsLoaded = false, t2.rendNode.setAttributeNS(this.xlinkNamespace, "xlink:href", e2), t2._src = e2, true);
  }, updateImageStyle: function(t2, e2) {
    var i3 = s.Z.evaluate(e2 ? t2.visProp.highlightcssclass : t2.visProp.cssclass);
    t2.rendNode.setAttributeNS(null, "class", i3);
  }, drawForeignObject: function(t2) {
    t2.rendNode = this.appendChildPrim(this.createPrim("foreignObject", t2.id), s.Z.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "foreignObject"), this.updateForeignObject(t2);
  }, updateForeignObject: function(t2) {
    t2._useUserSize ? t2.rendNode.style.overflow = "hidden" : t2.rendNode.style.overflow = "visible", this.updateRectPrim(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1], t2.size[0], t2.size[1]), t2.rendNode.innerHTML = t2.content, this._updateVisual(t2, { stroke: true, dash: true }, true);
  }, appendChildPrim: function(t2, e2) {
    return s.Z.exists(e2) ? e2 >= M.Z.layer.numlayers && (e2 = M.Z.layer.numlayers - 1) : e2 = 0, this.layer[e2].appendChild(t2), t2;
  }, createPrim: function(t2, e2) {
    var i3 = this.container.ownerDocument.createElementNS(this.svgNamespace, t2);
    return i3.setAttributeNS(null, "id", this.container.id + "_" + e2), i3.style.position = "absolute", "path" === t2 && (i3.setAttributeNS(null, "stroke-linecap", "round"), i3.setAttributeNS(null, "stroke-linejoin", "round"), i3.setAttributeNS(null, "fill-rule", "evenodd")), i3;
  }, remove: function(t2) {
    s.Z.exists(t2) && s.Z.exists(t2.parentNode) && t2.parentNode.removeChild(t2);
  }, setLayer: function(t2, e2) {
    s.Z.exists(e2) ? e2 >= M.Z.layer.numlayers && (e2 = M.Z.layer.numlayers - 1) : e2 = 0, this.layer[e2].appendChild(t2.rendNode);
  }, makeArrows: function(t2, e2) {
    var i3, r3 = e2.evFirst, o2 = e2.evLast;
    t2.visPropOld.firstarrow !== r3 || t2.visPropOld.lastarrow !== o2 ? (r3 ? (i3 = t2.rendNodeTriangleStart, s.Z.exists(i3) ? this.defs.appendChild(i3) : (i3 = this._createArrowHead(t2, "End", e2.typeFirst), this.defs.appendChild(i3), t2.rendNodeTriangleStart = i3, t2.rendNode.setAttributeNS(null, "marker-start", this.toURL(this.container.id, "_", t2.id, "TriangleEnd")))) : (i3 = t2.rendNodeTriangleStart, s.Z.exists(i3) && this.remove(i3)), o2 ? (i3 = t2.rendNodeTriangleEnd, s.Z.exists(i3) ? this.defs.appendChild(i3) : (i3 = this._createArrowHead(t2, "Start", e2.typeLast), this.defs.appendChild(i3), t2.rendNodeTriangleEnd = i3, t2.rendNode.setAttributeNS(null, "marker-end", this.toURL(this.container.id, "_", t2.id, "TriangleStart")))) : (i3 = t2.rendNodeTriangleEnd, s.Z.exists(i3) && this.remove(i3)), t2.visPropOld.firstarrow = r3, t2.visPropOld.lastarrow = o2) : this.isIE && t2.visPropCalc.visible && (r3 || o2) && t2.rendNode.parentNode.insertBefore(t2.rendNode, t2.rendNode);
  }, updateEllipsePrim: function(t2, e2, i3, s2, r3) {
    var o2;
    o2 = 2e5, e2 = Math.abs(e2) < o2 ? e2 : o2 * e2 / Math.abs(e2), i3 = Math.abs(i3) < o2 ? i3 : o2 * i3 / Math.abs(i3), s2 = Math.abs(s2) < o2 ? s2 : o2 * s2 / Math.abs(s2), r3 = Math.abs(r3) < o2 ? r3 : o2 * r3 / Math.abs(r3), t2.setAttributeNS(null, "cx", e2), t2.setAttributeNS(null, "cy", i3), t2.setAttributeNS(null, "rx", Math.abs(s2)), t2.setAttributeNS(null, "ry", Math.abs(r3));
  }, updateLinePrim: function(t2, e2, i3, s2, r3) {
    var o2;
    o2 = 2e5, isNaN(e2 + i3 + s2 + r3) || (e2 = Math.abs(e2) < o2 ? e2 : o2 * e2 / Math.abs(e2), i3 = Math.abs(i3) < o2 ? i3 : o2 * i3 / Math.abs(i3), s2 = Math.abs(s2) < o2 ? s2 : o2 * s2 / Math.abs(s2), r3 = Math.abs(r3) < o2 ? r3 : o2 * r3 / Math.abs(r3), t2.setAttributeNS(null, "x1", e2), t2.setAttributeNS(null, "y1", i3), t2.setAttributeNS(null, "x2", s2), t2.setAttributeNS(null, "y2", r3));
  }, updatePathPrim: function(t2, e2) {
    "" === e2 && (e2 = "M 0 0"), t2.setAttributeNS(null, "d", e2);
  }, updatePathStringPoint: function(t2, e2, i3) {
    var s2 = "", r3 = t2.coords.scrCoords, o2 = e2 * Math.sqrt(3) * 0.5, n2 = 0.5 * e2;
    return "x" === i3 ? s2 = " M " + (r3[1] - e2) + " " + (r3[2] - e2) + " L " + (r3[1] + e2) + " " + (r3[2] + e2) + " M " + (r3[1] + e2) + " " + (r3[2] - e2) + " L " + (r3[1] - e2) + " " + (r3[2] + e2) : "+" === i3 ? s2 = " M " + (r3[1] - e2) + " " + r3[2] + " L " + (r3[1] + e2) + " " + r3[2] + " M " + r3[1] + " " + (r3[2] - e2) + " L " + r3[1] + " " + (r3[2] + e2) : "|" === i3 ? s2 = " M " + r3[1] + " " + (r3[2] - e2) + " L " + r3[1] + " " + (r3[2] + e2) : "-" === i3 ? s2 = " M " + (r3[1] - e2) + " " + r3[2] + " L " + (r3[1] + e2) + " " + r3[2] : "<>" === i3 ? s2 = " M " + (r3[1] - e2) + " " + r3[2] + " L " + r3[1] + " " + (r3[2] + e2) + " L " + (r3[1] + e2) + " " + r3[2] + " L " + r3[1] + " " + (r3[2] - e2) + " Z " : "^" === i3 ? s2 = " M " + r3[1] + " " + (r3[2] - e2) + " L " + (r3[1] - o2) + " " + (r3[2] + n2) + " L " + (r3[1] + o2) + " " + (r3[2] + n2) + " Z " : "v" === i3 ? s2 = " M " + r3[1] + " " + (r3[2] + e2) + " L " + (r3[1] - o2) + " " + (r3[2] - n2) + " L " + (r3[1] + o2) + " " + (r3[2] - n2) + " Z " : ">" === i3 ? s2 = " M " + (r3[1] + e2) + " " + r3[2] + " L " + (r3[1] - n2) + " " + (r3[2] - o2) + " L " + (r3[1] - n2) + " " + (r3[2] + o2) + " Z " : "<" === i3 && (s2 = " M " + (r3[1] - e2) + " " + r3[2] + " L " + (r3[1] + n2) + " " + (r3[2] - o2) + " L " + (r3[1] + n2) + " " + (r3[2] + o2) + " Z "), s2;
  }, updatePathStringPrim: function(t2) {
    var e2, i3, s2, r3 = " M ", o2 = r3, n2 = 5e3, a2 = "";
    if (t2.numberPoints <= 0)
      return "";
    if (s2 = Math.min(t2.points.length, t2.numberPoints), 1 === t2.bezierDegree)
      for (e2 = 0; e2 < s2; e2++)
        i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? o2 = r3 : (i3[1] = Math.max(Math.min(i3[1], n2), -5e3), i3[2] = Math.max(Math.min(i3[2], n2), -5e3), a2 += o2 + i3[1] + " " + i3[2], o2 = " L ");
    else if (3 === t2.bezierDegree)
      for (e2 = 0; e2 < s2; )
        i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? o2 = r3 : (a2 += o2 + i3[1] + " " + i3[2], " C " === o2 && (e2 += 1, a2 += " " + (i3 = t2.points[e2].scrCoords)[1] + " " + i3[2], e2 += 1, a2 += " " + (i3 = t2.points[e2].scrCoords)[1] + " " + i3[2]), o2 = " C "), e2 += 1;
    return a2;
  }, updatePathStringBezierPrim: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2, c2 = " M ", d2 = c2, u2 = 5e3, p2 = "", _2 = s.Z.evaluate(t2.visProp.strokewidth), f2 = "plot" !== s.Z.evaluate(t2.visProp.curvetype);
    if (t2.numberPoints <= 0)
      return "";
    for (f2 && t2.board.options.curve.RDPsmoothing && (t2.points = l.Z.RamerDouglasPeucker(t2.points, 0.5)), h2 = Math.min(t2.points.length, t2.numberPoints), i3 = 1; i3 < 3; i3++)
      for (d2 = c2, e2 = 0; e2 < h2; e2++)
        o2 = t2.points[e2].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? d2 = c2 : (o2[1] = Math.max(Math.min(o2[1], u2), -5e3), o2[2] = Math.max(Math.min(o2[2], u2), -5e3), d2 === c2 ? p2 += d2 + o2[1] + " " + o2[2] : (r3 = 2 * i3, p2 += [d2, n2 + 0.333 * (o2[1] - n2) + _2 * (r3 * Math.random() - i3), " ", a2 + 0.333 * (o2[2] - a2) + _2 * (r3 * Math.random() - i3), " ", n2 + 0.666 * (o2[1] - n2) + _2 * (r3 * Math.random() - i3), " ", a2 + 0.666 * (o2[2] - a2) + _2 * (r3 * Math.random() - i3), " ", o2[1], " ", o2[2]].join("")), d2 = " C ", n2 = o2[1], a2 = o2[2]);
    return p2;
  }, updatePolygonPrim: function(t2, e2) {
    var i3, s2, r3 = "", o2 = e2.vertices.length;
    for (t2.setAttributeNS(null, "stroke", "none"), t2.setAttributeNS(null, "fill-rule", "evenodd"), "polygonalchain" === e2.elType && o2++, i3 = 0; i3 < o2 - 1; i3++) {
      if (!e2.vertices[i3].isReal)
        return void t2.setAttributeNS(null, "points", "");
      r3 = r3 + (s2 = e2.vertices[i3].coords.scrCoords)[1] + "," + s2[2], i3 < o2 - 2 && (r3 += " ");
    }
    -1 === r3.indexOf("NaN") && t2.setAttributeNS(null, "points", r3);
  }, updateRectPrim: function(t2, e2, i3, s2, r3) {
    t2.setAttributeNS(null, "x", e2), t2.setAttributeNS(null, "y", i3), t2.setAttributeNS(null, "width", s2), t2.setAttributeNS(null, "height", r3);
  }, setPropertyPrim: function(t2, e2, i3) {
    "stroked" !== e2 && t2.setAttributeNS(null, e2, i3);
  }, display: function(t2, e2) {
    var i3;
    t2 && t2.rendNode && (t2.visPropOld.visible = e2, i3 = t2.rendNode, e2 ? (i3.setAttributeNS(null, "display", "inline"), i3.style.visibility = "inherit") : (i3.setAttributeNS(null, "display", "none"), i3.style.visibility = "hidden"));
  }, show: function(e2) {
    t.Z.deprecated("Board.renderer.show()", "Board.renderer.display()"), this.display(e2, true);
  }, hide: function(e2) {
    t.Z.deprecated("Board.renderer.hide()", "Board.renderer.display()"), this.display(e2, false);
  }, setBuffering: function(t2, e2) {
    t2.rendNode.setAttribute("buffered-rendering", e2);
  }, setDashStyle: function(t2) {
    var e2 = s.Z.evaluate(t2.visProp.dash), i3 = t2.rendNode;
    e2 > 0 ? i3.setAttributeNS(null, "stroke-dasharray", this.dashArray[e2 - 1]) : i3.hasAttributeNS(null, "stroke-dasharray") && i3.removeAttributeNS(null, "stroke-dasharray");
  }, setGradient: function(t2) {
    var e2, i3, r3, o2 = t2.rendNode, n2 = s.Z.evaluate(t2.visProp.gradient);
    "linear" === n2 || "radial" === n2 ? (e2 = this.createPrim(n2 + "Gradient", t2.id + "_gradient"), i3 = this.createPrim("stop", t2.id + "_gradient1"), r3 = this.createPrim("stop", t2.id + "_gradient2"), e2.appendChild(i3), e2.appendChild(r3), this.defs.appendChild(e2), o2.setAttributeNS(null, "style", "fill:" + this.toURL(this.container.id + "_" + t2.id + "_gradient")), t2.gradNode1 = i3, t2.gradNode2 = r3, t2.gradNode = e2) : o2.removeAttributeNS(null, "style");
  }, updateGradientAngle: function(t2, e2) {
    var i3 = 1, s2 = Math.cos(e2), r3 = Math.sin(e2);
    Math.abs(s2) > Math.abs(r3) ? i3 /= Math.abs(s2) : i3 /= Math.abs(r3), s2 >= 0 ? (t2.setAttributeNS(null, "x1", 0), t2.setAttributeNS(null, "x2", s2 * i3)) : (t2.setAttributeNS(null, "x1", -s2 * i3), t2.setAttributeNS(null, "x2", 0)), r3 >= 0 ? (t2.setAttributeNS(null, "y1", 0), t2.setAttributeNS(null, "y2", r3 * i3)) : (t2.setAttributeNS(null, "y1", -r3 * i3), t2.setAttributeNS(null, "y2", 0));
  }, updateGradientCircle: function(t2, e2, i3, s2, r3, o2, n2) {
    t2.setAttributeNS(null, "cx", 100 * e2 + "%"), t2.setAttributeNS(null, "cy", 100 * i3 + "%"), t2.setAttributeNS(null, "r", 100 * s2 + "%"), t2.setAttributeNS(null, "fx", 100 * r3 + "%"), t2.setAttributeNS(null, "fy", 100 * o2 + "%"), t2.setAttributeNS(null, "fr", 100 * n2 + "%");
  }, updateGradient: function(t2) {
    var e2, i3, r3 = t2.gradNode1, o2 = t2.gradNode2, n2 = s.Z.evaluate(t2.visProp.gradient);
    s.Z.exists(r3) && s.Z.exists(o2) && (i3 = (i3 = s.Z.evaluate(t2.visProp.fillopacity)) > 0 ? i3 : 0, e2 = s.Z.evaluate(t2.visProp.fillcolor), r3.setAttributeNS(null, "style", "stop-color:" + e2 + ";stop-opacity:" + i3), o2.setAttributeNS(null, "style", "stop-color:" + s.Z.evaluate(t2.visProp.gradientsecondcolor) + ";stop-opacity:" + s.Z.evaluate(t2.visProp.gradientsecondopacity)), r3.setAttributeNS(null, "offset", 100 * s.Z.evaluate(t2.visProp.gradientstartoffset) + "%"), o2.setAttributeNS(null, "offset", 100 * s.Z.evaluate(t2.visProp.gradientendoffset) + "%"), "linear" === n2 ? this.updateGradientAngle(t2.gradNode, s.Z.evaluate(t2.visProp.gradientangle)) : "radial" === n2 && this.updateGradientCircle(t2.gradNode, s.Z.evaluate(t2.visProp.gradientcx), s.Z.evaluate(t2.visProp.gradientcy), s.Z.evaluate(t2.visProp.gradientr), s.Z.evaluate(t2.visProp.gradientfx), s.Z.evaluate(t2.visProp.gradientfy), s.Z.evaluate(t2.visProp.gradientfr)));
  }, setObjectTransition: function(t2, e2) {
    var i3, r3, o2, n2 = [], a2 = 0, h2 = ["rendNode", "rendNodeTriangleStart", "rendNodeTriangleEnd"];
    if (void 0 === e2 && (e2 = s.Z.evaluate(t2.visProp.transitionduration)), i3 = s.Z.evaluate(t2.visProp.transitionproperties), e2 !== t2.visPropOld.transitionduration || i3 !== t2.visPropOld.transitionproperties) {
      for (s.Z.exists(i3) && (a2 = i3.length), o2 = 0; o2 < a2; o2++)
        n2.push(i3[o2] + " " + e2 + "ms");
      for (r3 = n2.join(", "), a2 = h2.length, o2 = 0; o2 < a2; ++o2)
        t2[h2[o2]] && (t2[h2[o2]].style.transition = r3);
      t2.visPropOld.transitionduration = e2, t2.visPropOld.transitionproperties = i3;
    }
  }, _setAttribute: function(t2, e2) {
    "" === e2 ? t2() : window.setTimeout(t2, 1);
  }, setObjectFillColor: function(e2, i3, r3, o2) {
    var n2, a2, h2, l2, c2 = s.Z.evaluate(i3), d2 = s.Z.evaluate(r3), u2 = s.Z.evaluate(e2.visProp.gradient);
    d2 = d2 > 0 ? d2 : 0, e2.visPropOld.fillcolor === c2 && e2.visPropOld.fillopacity === d2 && null === u2 || (s.Z.exists(c2) && false !== c2 && (9 !== c2.length ? (a2 = c2, l2 = d2) : (h2 = D.Z.rgba2rgbo(c2), a2 = h2[0], l2 = d2 * h2[1]), n2 = void 0 === o2 ? e2.rendNode : o2, "none" !== a2 && this._setAttribute(function() {
      n2.setAttributeNS(null, "fill", a2);
    }, e2.visPropOld.fillcolor), e2.type === t.Z.OBJECT_TYPE_IMAGE ? this._setAttribute(function() {
      n2.setAttributeNS(null, "opacity", l2);
    }, e2.visPropOld.fillopacity) : ("none" === a2 ? (l2 = 0, n2.setAttributeNS(null, "pointer-events", "visibleStroke")) : n2.setAttributeNS(null, "pointer-events", "visiblePainted"), this._setAttribute(function() {
      n2.setAttributeNS(null, "fill-opacity", l2);
    }, e2.visPropOld.fillopacity)), "linear" !== u2 && "radial" !== u2 || this.updateGradient(e2)), e2.visPropOld.fillcolor = c2, e2.visPropOld.fillopacity = d2);
  }, setObjectStrokeColor: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = s.Z.evaluate(e2), c2 = s.Z.evaluate(r3);
    c2 = c2 > 0 ? c2 : 0, t2.visPropOld.strokecolor === l2 && t2.visPropOld.strokeopacity === c2 || (s.Z.exists(l2) && false !== l2 && (9 !== l2.length ? (o2 = l2, a2 = c2) : (n2 = D.Z.rgba2rgbo(l2), o2 = n2[0], a2 = c2 * n2[1]), h2 = t2.rendNode, t2.elementClass === i2.Z.OBJECT_CLASS_TEXT ? "html" === s.Z.evaluate(t2.visProp.display) ? this._setAttribute(function() {
      h2.style.color = o2, h2.style.opacity = a2;
    }, t2.visPropOld.strokecolor) : this._setAttribute(function() {
      h2.setAttributeNS(null, "style", "fill:" + o2), h2.setAttributeNS(null, "style", "fill-opacity:" + a2);
    }, t2.visPropOld.strokecolor) : this._setAttribute(function() {
      h2.setAttributeNS(null, "stroke", o2), h2.setAttributeNS(null, "stroke-opacity", a2);
    }, t2.visPropOld.strokecolor), t2.elementClass !== i2.Z.OBJECT_CLASS_CURVE && t2.elementClass !== i2.Z.OBJECT_CLASS_LINE || (s.Z.evaluate(t2.visProp.firstarrow) && this._setArrowColor(t2.rendNodeTriangleStart, o2, a2, t2, t2.visPropCalc.typeFirst), s.Z.evaluate(t2.visProp.lastarrow) && this._setArrowColor(t2.rendNodeTriangleEnd, o2, a2, t2, t2.visPropCalc.typeLast))), t2.visPropOld.strokecolor = l2, t2.visPropOld.strokeopacity = c2);
  }, setObjectStrokeWidth: function(t2, e2) {
    var i3, r3 = s.Z.evaluate(e2);
    isNaN(r3) || t2.visPropOld.strokewidth === r3 || (i3 = t2.rendNode, this.setPropertyPrim(i3, "stroked", "true"), s.Z.exists(r3) && this.setPropertyPrim(i3, "stroke-width", r3 + "px"), t2.visPropOld.strokewidth = r3);
  }, setLineCap: function(t2) {
    var e2 = s.Z.evaluate(t2.visProp.linecap);
    void 0 !== e2 && "" !== e2 && t2.visPropOld.linecap !== e2 && s.Z.exists(t2.rendNode) && (this.setPropertyPrim(t2.rendNode, "stroke-linecap", e2), t2.visPropOld.linecap = e2);
  }, setShadow: function(e2) {
    var i3, r3, o2, n2, a2, h2, l2, c2, d2 = s.Z.evaluate(e2.visProp.shadow), u2 = true, p2 = false;
    (i3 = JSON.stringify(d2)) !== e2.visPropOld.shadow && ("boolean" == typeof d2 ? (u2 = true, p2 = d2, r3 = "none", o2 = 3, n2 = 0.1, a2 = [5, 5], h2 = 1) : s.Z.evaluate(d2.enabled) ? (u2 = false, p2 = true, r3 = t.Z.rgbParser(s.Z.evaluate(d2.color)), o2 = s.Z.evaluate(d2.blur), n2 = s.Z.evaluate(d2.blend), a2 = s.Z.evaluate(d2.offset), h2 = s.Z.evaluate(d2.opacity)) : p2 = false, s.Z.exists(e2.rendNode) && (p2 ? u2 ? e2.rendNode.setAttributeNS(null, "filter", this.toURL(this.container.id + "_f1")) : ((c2 = this.container.ownerDocument.getElementById(l2)) && this.defs.removeChild(c2), l2 = e2.rendNode.id + "_f1", this.defs.appendChild(this.createShadowFilter(l2, r3, h2, n2, o2, a2)), e2.rendNode.setAttributeNS(null, "filter", this.toURL(l2))) : e2.rendNode.removeAttributeNS(null, "filter")), e2.visPropOld.shadow = i3);
  }, suspendRedraw: function() {
  }, unsuspendRedraw: function() {
  }, resize: function(t2, e2) {
    this.svgRoot.setAttribute("width", parseFloat(t2)), this.svgRoot.setAttribute("height", parseFloat(e2));
  }, createTouchpoints: function(t2) {
    var e2, i3, s2, r3;
    for (this.touchpoints = [], e2 = 0; e2 < t2; e2++)
      i3 = "touchpoint1_" + e2, r3 = this.createPrim("path", i3), this.appendChildPrim(r3, 19), r3.setAttributeNS(null, "d", "M 0 0"), this.touchpoints.push(r3), this.setPropertyPrim(r3, "stroked", "true"), this.setPropertyPrim(r3, "stroke-width", "1px"), r3.setAttributeNS(null, "stroke", "#000000"), r3.setAttributeNS(null, "stroke-opacity", 1), r3.setAttributeNS(null, "display", "none"), s2 = "touchpoint2_" + e2, r3 = this.createPrim("ellipse", s2), this.appendChildPrim(r3, 19), this.updateEllipsePrim(r3, 0, 0, 0, 0), this.touchpoints.push(r3), this.setPropertyPrim(r3, "stroked", "true"), this.setPropertyPrim(r3, "stroke-width", "1px"), r3.setAttributeNS(null, "stroke", "#000000"), r3.setAttributeNS(null, "stroke-opacity", 1), r3.setAttributeNS(null, "fill", "#ffffff"), r3.setAttributeNS(null, "fill-opacity", 0), r3.setAttributeNS(null, "display", "none");
  }, showTouchpoint: function(t2) {
    this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (this.touchpoints[2 * t2].setAttributeNS(null, "display", "inline"), this.touchpoints[2 * t2 + 1].setAttributeNS(null, "display", "inline"));
  }, hideTouchpoint: function(t2) {
    this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (this.touchpoints[2 * t2].setAttributeNS(null, "display", "none"), this.touchpoints[2 * t2 + 1].setAttributeNS(null, "display", "none"));
  }, updateTouchpoint: function(t2, e2) {
    var i3, s2;
    this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (i3 = e2[0], s2 = e2[1], this.touchpoints[2 * t2].setAttributeNS(null, "d", "M " + (i3 - 37) + " " + s2 + " L " + (i3 + 37) + " " + s2 + " M " + i3 + " " + (s2 - 37) + " L " + i3 + " " + (s2 + 37)), this.updateEllipsePrim(this.touchpoints[2 * t2 + 1], e2[0], e2[1], 25, 25));
  }, _getValuesOfDOMElements: function(t2) {
    var e2 = [];
    if (1 === t2.nodeType)
      for (t2 = t2.firstChild; t2; )
        void 0 !== t2.id && void 0 !== t2.value && e2.push([t2.id, t2.value]), e2 = e2.concat(this._getValuesOfDOMElements(t2)), t2 = t2.nextSibling;
    return e2;
  }, _getDataUri: function(t2, e2) {
    var i3 = new Image();
    i3.onload = function() {
      var t3 = document.createElement("canvas");
      t3.width = this.naturalWidth, t3.height = this.naturalHeight, t3.getContext("2d").drawImage(this, 0, 0), e2(t3.toDataURL("image/png")), t3.remove();
    }, i3.src = t2;
  }, _getImgDataURL: function(t2) {
    var e2, i3, s2, r3, o2, n2;
    if ((i3 = (e2 = t2.getElementsByTagName("image")).length) > 0)
      for (s2 = document.createElement("canvas"), n2 = 0; n2 < i3; n2++) {
        e2[n2].setAttribute("crossorigin", "anonymous"), r3 = s2.getContext("2d"), s2.width = e2[n2].getAttribute("width"), s2.height = e2[n2].getAttribute("height");
        try {
          r3.drawImage(e2[n2], 0, 0, s2.width, s2.height), o2 = s2.toDataURL(), e2[n2].setAttribute("xlink:href", o2);
        } catch (t3) {
          console.log("CORS problem! Image can not be used", t3);
        }
      }
    return true;
  }, dumpToDataURI: function(t2) {
    var e2, i3, r3, o2 = this.svgRoot, n2 = window.btoa || O.encode, a2 = [];
    if (this.container.hasChildNodes() && s.Z.exists(this.foreignObjLayer))
      for (t2 || this.foreignObjLayer.setAttribute("display", "inline"); o2.nextSibling; )
        a2 = a2.concat(this._getValuesOfDOMElements(o2.nextSibling)), this.foreignObjLayer.appendChild(o2.nextSibling);
    if (this._getImgDataURL(o2), o2.setAttribute("xmlns", "http://www.w3.org/2000/svg"), e2 = new XMLSerializer().serializeToString(o2), true !== t2)
      for (r3 = a2.length, i3 = 0; i3 < r3; i3++)
        e2 = e2.replace('id="' + a2[i3][0] + '"', 'id="' + a2[i3][0] + '" value="' + a2[i3][1] + '"');
    if ((e2.match(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g) || []).length > 1 && (e2 = e2.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, "")), e2 = e2.replace(/&nbsp;/g, " "), s.Z.exists(this.foreignObjLayer) && this.foreignObjLayer.hasChildNodes()) {
      for (; this.foreignObjLayer.firstChild; )
        this.container.appendChild(this.foreignObjLayer.firstChild);
      this.foreignObjLayer.setAttribute("display", "none");
    }
    return "data:image/svg+xml;base64," + n2(unescape(encodeURIComponent(e2)));
  }, dumpToCanvas: function(t2, e2, i3, s2) {
    var r3, o2, n2, a2;
    return (n2 = this.container.ownerDocument.getElementById(t2)).width = n2.width, a2 = n2.getContext("2d"), void 0 !== e2 && void 0 !== i3 && (n2.style.width = parseFloat(e2) + "px", n2.style.height = parseFloat(i3) + "px", n2.setAttribute("width", parseFloat(e2)), n2.setAttribute("height", parseFloat(i3))), o2 = new Image(), r3 = this.dumpToDataURI(s2), o2.src = r3, "Promise" in window ? new Promise(function(t3, s3) {
      try {
        o2.onload = function() {
          a2.drawImage(o2, 0, 0, e2, i3), t3();
        };
      } catch (t4) {
        s3(t4);
      }
    }) : (o2.onload = function() {
      window.setTimeout(function() {
        try {
          a2.drawImage(o2, 0, 0, e2, i3);
        } catch (t3) {
          console.log("screenshots not longer supported on IE");
        }
      }, 200);
    }, this);
  }, screenshot: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2 = this.container.ownerDocument, b2 = this.container.parentNode, g2 = t2.attr.screenshot, m2 = false;
    return "no" === this.type || (c2 = g2.scale * this.container.getBoundingClientRect().width, d2 = g2.scale * this.container.getBoundingClientRect().height, void 0 === e2 || "" === e2 ? (m2 = true, (a2 = new Image()).style.width = c2 + "px", a2.style.height = d2 + "px") : (m2 = false, a2 = f2.getElementById(e2)), m2 && ((r3 = f2.createElement("div")).style.cssText = g2.css, r3.style.width = c2 + "px", r3.style.height = d2 + "px", r3.style.zIndex = this.container.style.zIndex + 120, r3.style.position = "absolute", r3.style.top = this.container.offsetTop + "px", r3.style.left = this.container.offsetLeft + "px"), o2 = f2.createElement("canvas"), n2 = Math.random().toString(36).substr(2, 5), o2.setAttribute("id", n2), o2.setAttribute("width", c2), o2.setAttribute("height", d2), o2.style.width = c2 + "px", o2.style.height = c2 + "px", o2.style.display = "none", b2.appendChild(o2), m2 && (h2 = f2.createElement("span"), l2 = f2.createTextNode(""), h2.style.cssText = g2.cssButton, h2.appendChild(l2), h2.onclick = function() {
      r3.parentNode.removeChild(r3);
    }, r3.appendChild(a2), r3.appendChild(h2), b2.insertBefore(r3, this.container.nextSibling)), u2 = f2.getElementById(this.container.id + "_navigationbar"), s.Z.exists(u2) && (p2 = u2.style.display, u2.style.display = "none"), _2 = function() {
      a2.src = o2.toDataURL("image/png"), b2.removeChild(o2);
    }, "Promise" in window ? this.dumpToCanvas(n2, c2, d2, i3).then(_2) : (this.dumpToCanvas(n2, c2, d2, i3), window.setTimeout(_2, 200)), s.Z.exists(u2) && (u2.style.display = p2)), this;
  } });
  const I = t.Z.SVGRenderer;
  t.Z.VMLRenderer = function(e2) {
    this.type = "vml", this.container = e2, this.container.style.overflow = "hidden", "" === this.container.style.position && (this.container.style.position = "relative"), this.container.onselectstart = function() {
      return false;
    }, this.resolution = 10, s.Z.exists(t.Z.vmlStylesheet) || (e2.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml"), t.Z.vmlStylesheet = this.container.ownerDocument.createStyleSheet(), t.Z.vmlStylesheet.addRule(".jxgvml", "behavior:url(#default#VML)"));
    try {
      e2.ownerDocument.namespaces.jxgvml || e2.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml"), this.createNode = function(t2) {
        return e2.ownerDocument.createElement("<jxgvml:" + t2 + ' class="jxgvml">');
      };
    } catch (t2) {
      this.createNode = function(t3) {
        return e2.ownerDocument.createElement("<" + t3 + ' xmlns="urn:schemas-microsoft.com:vml" class="jxgvml">');
      };
    }
    this.dashArray = ["Solid", "1 1", "ShortDash", "Dash", "LongDash", "ShortDashDot", "LongDashDot"];
  }, t.Z.VMLRenderer.prototype = new N(), t.Z.extend(t.Z.VMLRenderer.prototype, { _setAttr: function(e2, i3, s2, r3) {
    try {
      8 === this.container.ownerDocument.documentMode ? e2[i3] = s2 : e2.setAttribute(i3, s2, r3);
    } catch (e3) {
      t.Z.debug("_setAttr: " + i3 + " " + s2 + "<br>\n");
    }
  }, updateTicks: function(t2) {
    var e2, i3, r3, o2, n2, a2 = this.resolution, h2 = [];
    for (i3 = t2.ticks.length, e2 = 0; e2 < i3; e2++)
      o2 = (r3 = t2.ticks[e2])[0], n2 = r3[1], s.Z.isNumber(o2[0]) && s.Z.isNumber(o2[1]) && h2.push(" m " + Math.round(a2 * o2[0]) + ", " + Math.round(a2 * n2[0]) + " l " + Math.round(a2 * o2[1]) + ", " + Math.round(a2 * n2[1]) + " ");
    s.Z.exists(t2.rendNode) || (t2.rendNode = this.createPrim("path", t2.id), this.appendChildPrim(t2.rendNode, s.Z.evaluate(t2.visProp.layer))), this._setAttr(t2.rendNode, "stroked", "true"), this._setAttr(t2.rendNode, "strokecolor", s.Z.evaluate(t2.visProp.strokecolor), 1), this._setAttr(t2.rendNode, "strokeweight", s.Z.evaluate(t2.visProp.strokewidth)), this._setAttr(t2.rendNodeStroke, "opacity", 100 * s.Z.evaluate(t2.visProp.strokeopacity) + "%"), this.updatePathPrim(t2.rendNode, h2, t2.board);
  }, displayCopyright: function(t2, e2) {
    var i3, s2;
    (i3 = this.createNode("textbox")).style.position = "absolute", this._setAttr(i3, "id", this.container.id + "_licenseText"), i3.style.left = 20, i3.style.top = 2, i3.style.fontSize = e2, i3.style.color = "#356AA0", i3.style.fontFamily = "Arial,Helvetica,sans-serif", this._setAttr(i3, "opacity", "30%"), i3.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 30, enabled = true)", s2 = this.container.ownerDocument.createTextNode(t2), i3.appendChild(s2), this.appendChildPrim(i3, 0);
  }, drawInternalText: function(t2) {
    var e2;
    return (e2 = this.createNode("textbox")).style.position = "absolute", t2.rendNodeText = this.container.ownerDocument.createTextNode(""), e2.appendChild(t2.rendNodeText), this.appendChildPrim(e2, 9), e2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)", e2;
  }, updateInternalText: function(t2) {
    var e2, i3, s2, r3, n2, a2, h2 = t2.plaintext, l2 = this.joinTransforms(t2, t2.transformations), c2 = [0, 0], d2 = t2.rendNode, u2 = [], p2 = t2.getAnchorX(), _2 = t2.getAnchorY();
    if (!isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2])) {
      for ("right" === p2 ? c2[0] = 1 : "middle" === p2 && (c2[0] = 0.5), "bottom" === _2 ? c2[1] = 1 : "middle" === _2 && (c2[1] = 0.5), u2[0] = o.Z.matVecMult(l2, [1, t2.coords.scrCoords[1] - c2[0] * t2.size[0], t2.coords.scrCoords[2] + (1 - c2[1]) * t2.size[1] + this.vOffsetText]), u2[0][1] /= u2[0][0], u2[0][2] /= u2[0][0], u2[1] = o.Z.matVecMult(l2, [1, t2.coords.scrCoords[1] + (1 - c2[0]) * t2.size[0], t2.coords.scrCoords[2] + (1 - c2[1]) * t2.size[1] + this.vOffsetText]), u2[1][1] /= u2[1][0], u2[1][2] /= u2[1][0], u2[2] = o.Z.matVecMult(l2, [1, t2.coords.scrCoords[1] + (1 - c2[0]) * t2.size[0], t2.coords.scrCoords[2] - c2[1] * t2.size[1] + this.vOffsetText]), u2[2][1] /= u2[2][0], u2[2][2] /= u2[2][0], u2[3] = o.Z.matVecMult(l2, [1, t2.coords.scrCoords[1] - c2[0] * t2.size[0], t2.coords.scrCoords[2] - c2[1] * t2.size[1] + this.vOffsetText]), u2[3][1] /= u2[3][0], u2[3][2] /= u2[3][0], i3 = u2[0][1], r3 = u2[0][1], s2 = u2[0][2], n2 = u2[0][2], a2 = 1; a2 < 4; a2++)
        i3 = Math.max(i3, u2[a2][1]), r3 = Math.min(r3, u2[a2][1]), s2 = Math.max(s2, u2[a2][2]), n2 = Math.min(n2, u2[a2][2]);
      e2 = 1 === c2[0] ? Math.floor(t2.board.canvasWidth - i3) : Math.floor(r3), t2.visPropOld.left !== p2 + e2 && (1 === c2[0] ? (t2.rendNode.style.right = e2 + "px", t2.rendNode.style.left = "auto") : (t2.rendNode.style.left = e2 + "px", t2.rendNode.style.right = "auto"), t2.visPropOld.left = p2 + e2), e2 = 1 === c2[1] ? Math.floor(t2.board.canvasHeight - s2) : Math.floor(n2), t2.visPropOld.top !== _2 + e2 && (1 === c2[1] ? (t2.rendNode.style.bottom = e2 + "px", t2.rendNode.style.top = "auto") : (t2.rendNode.style.top = e2 + "px", t2.rendNode.style.bottom = "auto"), t2.visPropOld.top = _2 + e2);
    }
    t2.htmlStr !== h2 && (t2.rendNodeText.data = h2, t2.htmlStr = h2), d2.filters.item(0).M11 = l2[1][1], d2.filters.item(0).M12 = l2[1][2], d2.filters.item(0).M21 = l2[2][1], d2.filters.item(0).M22 = l2[2][2], d2.filters.item(0).enabled = true;
  }, drawImage: function(t2) {
    var e2;
    (e2 = this.container.ownerDocument.createElement("img")).style.position = "absolute", this._setAttr(e2, "id", this.container.id + "_" + t2.id), this.container.appendChild(e2), this.appendChildPrim(e2, s.Z.evaluate(t2.visProp.layer)), e2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand') progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)", t2.rendNode = e2, this.updateImage(t2);
  }, transformImage: function(t2, e2) {
    var i3, s2, r3, n2, a2, h2, l2 = t2.rendNode, c2 = [];
    if (e2.length > 0) {
      for (i3 = this.joinTransforms(t2, e2), c2[0] = o.Z.matVecMult(i3, t2.coords.scrCoords), c2[0][1] /= c2[0][0], c2[0][2] /= c2[0][0], c2[1] = o.Z.matVecMult(i3, [1, t2.coords.scrCoords[1] + t2.size[0], t2.coords.scrCoords[2]]), c2[1][1] /= c2[1][0], c2[1][2] /= c2[1][0], c2[2] = o.Z.matVecMult(i3, [1, t2.coords.scrCoords[1] + t2.size[0], t2.coords.scrCoords[2] - t2.size[1]]), c2[2][1] /= c2[2][0], c2[2][2] /= c2[2][0], c2[3] = o.Z.matVecMult(i3, [1, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1]]), c2[3][1] /= c2[3][0], c2[3][2] /= c2[3][0], s2 = c2[0][1], n2 = c2[0][1], r3 = c2[0][2], a2 = c2[0][2], h2 = 1; h2 < 4; h2++)
        s2 = Math.max(s2, c2[h2][1]), n2 = Math.min(n2, c2[h2][1]), r3 = Math.max(r3, c2[h2][2]), a2 = Math.min(a2, c2[h2][2]);
      l2.style.left = Math.floor(n2) + "px", l2.style.top = Math.floor(a2) + "px", l2.filters.item(0).M11 = i3[1][1], l2.filters.item(0).M12 = i3[1][2], l2.filters.item(0).M21 = i3[2][1], l2.filters.item(0).M22 = i3[2][2], l2.filters.item(0).enabled = true;
    }
  }, updateImageURL: function(t2) {
    var e2 = s.Z.evaluate(t2.url);
    this._setAttr(t2.rendNode, "src", e2);
  }, appendChildPrim: function(t2, e2) {
    return s.Z.exists(e2) || (e2 = 0), t2.style.zIndex = e2, this.container.appendChild(t2), t2;
  }, appendNodesToElement: function(t2, e2) {
    "shape" !== e2 && "path" !== e2 && "polygon" !== e2 || (t2.rendNodePath = this.getElementById(t2.id + "_path")), t2.rendNodeFill = this.getElementById(t2.id + "_fill"), t2.rendNodeStroke = this.getElementById(t2.id + "_stroke"), t2.rendNodeShadow = this.getElementById(t2.id + "_shadow"), t2.rendNode = this.getElementById(t2.id);
  }, createPrim: function(t2, e2) {
    var i3, s2, r3 = this.createNode("fill"), o2 = this.createNode("stroke"), n2 = this.createNode("shadow");
    return this._setAttr(r3, "id", this.container.id + "_" + e2 + "_fill"), this._setAttr(o2, "id", this.container.id + "_" + e2 + "_stroke"), this._setAttr(n2, "id", this.container.id + "_" + e2 + "_shadow"), "circle" === t2 || "ellipse" === t2 ? ((i3 = this.createNode("oval")).appendChild(r3), i3.appendChild(o2), i3.appendChild(n2)) : "polygon" === t2 || "path" === t2 || "shape" === t2 || "line" === t2 ? ((i3 = this.createNode("shape")).appendChild(r3), i3.appendChild(o2), i3.appendChild(n2), s2 = this.createNode("path"), this._setAttr(s2, "id", this.container.id + "_" + e2 + "_path"), i3.appendChild(s2)) : ((i3 = this.createNode(t2)).appendChild(r3), i3.appendChild(o2), i3.appendChild(n2)), i3.style.position = "absolute", i3.style.left = "0px", i3.style.top = "0px", this._setAttr(i3, "id", this.container.id + "_" + e2), i3;
  }, remove: function(t2) {
    s.Z.exists(t2) && t2.removeNode(true);
  }, makeArrows: function(t2) {
    var e2, i3 = s.Z.evaluate(t2.visProp.firstarrow), r3 = s.Z.evaluate(t2.visProp.lastarrow);
    t2.visPropOld.firstarrow === i3 && t2.visPropOld.lastarrow === r3 || (i3 ? (e2 = t2.rendNodeStroke, this._setAttr(e2, "startarrow", "block"), this._setAttr(e2, "startarrowlength", "long")) : (e2 = t2.rendNodeStroke, s.Z.exists(e2) && this._setAttr(e2, "startarrow", "none")), r3 ? (e2 = t2.rendNodeStroke, this._setAttr(e2, "id", this.container.id + "_" + t2.id + "stroke"), this._setAttr(e2, "endarrow", "block"), this._setAttr(e2, "endarrowlength", "long")) : (e2 = t2.rendNodeStroke, s.Z.exists(e2) && this._setAttr(e2, "endarrow", "none")), t2.visPropOld.firstarrow = i3, t2.visPropOld.lastarrow = r3);
  }, updateEllipsePrim: function(t2, e2, i3, s2, r3) {
    t2.style.left = Math.floor(e2 - s2) + "px", t2.style.top = Math.floor(i3 - r3) + "px", t2.style.width = Math.floor(2 * Math.abs(s2)) + "px", t2.style.height = Math.floor(2 * Math.abs(r3)) + "px";
  }, updateLinePrim: function(t2, e2, i3, s2, r3, o2) {
    var n2, a2 = this.resolution;
    isNaN(e2 + i3 + s2 + r3) || (n2 = ["m ", Math.floor(a2 * e2), ", ", Math.floor(a2 * i3), " l ", Math.floor(a2 * s2), ", ", Math.floor(a2 * r3)], this.updatePathPrim(t2, n2, o2));
  }, updatePathPrim: function(t2, e2, i3) {
    var s2 = i3.canvasWidth, r3 = i3.canvasHeight;
    e2.length <= 0 && (e2 = ["m 0,0"]), t2.style.width = s2, t2.style.height = r3, this._setAttr(t2, "coordsize", [Math.floor(this.resolution * s2), Math.floor(this.resolution * r3)].join(",")), this._setAttr(t2, "path", e2.join(""));
  }, updatePathStringPoint: function(t2, e2, i3) {
    var s2 = [], r3 = Math.round, o2 = t2.coords.scrCoords, n2 = e2 * Math.sqrt(3) * 0.5, a2 = 0.5 * e2, h2 = this.resolution;
    return "x" === i3 ? s2.push([" m ", r3(h2 * (o2[1] - e2)), ", ", r3(h2 * (o2[2] - e2)), " l ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * (o2[2] + e2)), " m ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * (o2[2] - e2)), " l ", r3(h2 * (o2[1] - e2)), ", ", r3(h2 * (o2[2] + e2))].join("")) : "+" === i3 ? s2.push([" m ", r3(h2 * (o2[1] - e2)), ", ", r3(h2 * o2[2]), " l ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * o2[2]), " m ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] - e2)), " l ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] + e2))].join("")) : "<>" === i3 ? s2.push([" m ", r3(h2 * (o2[1] - e2)), ", ", r3(h2 * o2[2]), " l ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] + e2)), " l ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * o2[2]), " l ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] - e2)), " x e "].join("")) : "^" === i3 ? s2.push([" m ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] - e2)), " l ", r3(h2 * (o2[1] - n2)), ", ", r3(h2 * (o2[2] + a2)), " l ", r3(h2 * (o2[1] + n2)), ", ", r3(h2 * (o2[2] + a2)), " x e "].join("")) : "v" === i3 ? s2.push([" m ", r3(h2 * o2[1]), ", ", r3(h2 * (o2[2] + e2)), " l ", r3(h2 * (o2[1] - n2)), ", ", r3(h2 * (o2[2] - a2)), " l ", r3(h2 * (o2[1] + n2)), ", ", r3(h2 * (o2[2] - a2)), " x e "].join("")) : ">" === i3 ? s2.push([" m ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * o2[2]), " l ", r3(h2 * (o2[1] - a2)), ", ", r3(h2 * (o2[2] - n2)), " l ", r3(h2 * (o2[1] - a2)), ", ", r3(h2 * (o2[2] + n2)), " l ", r3(h2 * (o2[1] + e2)), ", ", r3(h2 * o2[2])].join("")) : "<" === i3 && s2.push([" m ", r3(h2 * (o2[1] - e2)), ", ", r3(h2 * o2[2]), " l ", r3(h2 * (o2[1] + a2)), ", ", r3(h2 * (o2[2] - n2)), " l ", r3(h2 * (o2[1] + a2)), ", ", r3(h2 * (o2[2] + n2)), " x e "].join("")), s2;
  }, updatePathStringPrim: function(t2) {
    var e2, i3, s2 = [], r3 = this.resolution, o2 = Math.round, n2 = " m ", a2 = n2, h2 = Math.min(t2.numberPoints, 8192);
    if (t2.numberPoints <= 0)
      return "";
    if (h2 = Math.min(h2, t2.points.length), 1 === t2.bezierDegree)
      for (e2 = 0; e2 < h2; e2++)
        i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? a2 = n2 : (i3[1] > 2e4 ? i3[1] = 2e4 : i3[1] < -2e4 && (i3[1] = -2e4), i3[2] > 2e4 ? i3[2] = 2e4 : i3[2] < -2e4 && (i3[2] = -2e4), s2.push([a2, o2(r3 * i3[1]), ", ", o2(r3 * i3[2])].join("")), a2 = " l ");
    else if (3 === t2.bezierDegree)
      for (e2 = 0; e2 < h2; )
        i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? a2 = n2 : (s2.push([a2, o2(r3 * i3[1]), ", ", o2(r3 * i3[2])].join("")), " c " === a2 && (e2 += 1, i3 = t2.points[e2].scrCoords, s2.push([" ", o2(r3 * i3[1]), ", ", o2(r3 * i3[2])].join("")), e2 += 1, i3 = t2.points[e2].scrCoords, s2.push([" ", o2(r3 * i3[1]), ", ", o2(r3 * i3[2])].join(""))), a2 = " c "), e2 += 1;
    return s2.push(" e"), s2;
  }, updatePathStringBezierPrim: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2 = [], c2 = s.Z.evaluate(t2.visProp.strokewidth), d2 = this.resolution, u2 = Math.round, p2 = " m ", _2 = p2, f2 = "plot" !== s.Z.evaluate(t2.visProp.curvetype), b2 = Math.min(t2.numberPoints, 8192);
    if (t2.numberPoints <= 0)
      return "";
    for (f2 && t2.board.options.curve.RDPsmoothing && (t2.points = l.Z.RamerDouglasPeucker(t2.points, 1)), b2 = Math.min(b2, t2.points.length), i3 = 1; i3 < 3; i3++)
      for (_2 = p2, e2 = 0; e2 < b2; e2++)
        o2 = t2.points[e2].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? _2 = p2 : (o2[1] > 2e4 ? o2[1] = 2e4 : o2[1] < -2e4 && (o2[1] = -2e4), o2[2] > 2e4 ? o2[2] = 2e4 : o2[2] < -2e4 && (o2[2] = -2e4), _2 === p2 ? h2.push([_2, u2(d2 * o2[1]), " ", u2(d2 * o2[2])].join("")) : (r3 = 2 * i3, h2.push([_2, u2(d2 * (n2 + 0.333 * (o2[1] - n2) + c2 * (r3 * Math.random() - i3))), " ", u2(d2 * (a2 + 0.333 * (o2[2] - a2) + c2 * (r3 * Math.random() - i3))), " ", u2(d2 * (n2 + 0.666 * (o2[1] - n2) + c2 * (r3 * Math.random() - i3))), " ", u2(d2 * (a2 + 0.666 * (o2[2] - a2) + c2 * (r3 * Math.random() - i3))), " ", u2(d2 * o2[1]), " ", u2(d2 * o2[2])].join(""))), _2 = " c ", n2 = o2[1], a2 = o2[2]);
    return h2.push(" e"), h2;
  }, updatePolygonPrim: function(t2, e2) {
    var i3, s2, r3 = e2.vertices.length, o2 = this.resolution, n2 = [];
    if (this._setAttr(t2, "stroked", "false"), s2 = e2.vertices[0].coords.scrCoords, !isNaN(s2[1] + s2[2])) {
      for (n2.push(["m ", Math.floor(o2 * s2[1]), ",", Math.floor(o2 * s2[2]), " l "].join("")), i3 = 1; i3 < r3 - 1; i3++) {
        if (!e2.vertices[i3].isReal)
          return void this.updatePathPrim(t2, "", e2.board);
        if (s2 = e2.vertices[i3].coords.scrCoords, isNaN(s2[1] + s2[2]))
          return;
        n2.push(Math.floor(o2 * s2[1]) + "," + Math.floor(o2 * s2[2])), i3 < r3 - 2 && n2.push(", ");
      }
      n2.push(" x e"), this.updatePathPrim(t2, n2, e2.board);
    }
  }, updateRectPrim: function(t2, e2, i3, s2, r3) {
    t2.style.left = Math.floor(e2) + "px", t2.style.top = Math.floor(i3) + "px", s2 >= 0 && (t2.style.width = s2 + "px"), r3 >= 0 && (t2.style.height = r3 + "px");
  }, setPropertyPrim: function(t2, e2, i3) {
    var r3, o2 = "";
    switch (e2) {
      case "stroke":
        o2 = "strokecolor";
        break;
      case "stroke-width":
        o2 = "strokeweight";
        break;
      case "stroke-dasharray":
        o2 = "dashstyle";
    }
    "" !== o2 && (r3 = s.Z.evaluate(i3), this._setAttr(t2, o2, r3));
  }, display: function(t2, e2) {
    t2 && t2.rendNode && (t2.visPropOld.visible = e2, t2.rendNode.style.visibility = e2 ? "inherit" : "hidden");
  }, show: function(e2) {
    t.Z.deprecated("Board.renderer.show()", "Board.renderer.display()"), e2 && e2.rendNode && (e2.rendNode.style.visibility = "inherit");
  }, hide: function(e2) {
    t.Z.deprecated("Board.renderer.hide()", "Board.renderer.display()"), e2 && e2.rendNode && (e2.rendNode.style.visibility = "hidden");
  }, setDashStyle: function(t2, e2) {
    var i3;
    e2.dash >= 0 && (i3 = t2.rendNodeStroke, this._setAttr(i3, "dashstyle", this.dashArray[e2.dash]));
  }, setGradient: function(t2) {
    var e2 = t2.rendNodeFill, i3 = s.Z.evaluate(t2.visProp.gradient);
    "linear" === i3 ? (this._setAttr(e2, "type", "gradient"), this._setAttr(e2, "color2", s.Z.evaluate(t2.visProp.gradientsecondcolor)), this._setAttr(e2, "opacity2", s.Z.evaluate(t2.visProp.gradientsecondopacity)), this._setAttr(e2, "angle", s.Z.evaluate(t2.visProp.gradientangle))) : "radial" === i3 ? (this._setAttr(e2, "type", "gradientradial"), this._setAttr(e2, "color2", s.Z.evaluate(t2.visProp.gradientsecondcolor)), this._setAttr(e2, "opacity2", s.Z.evaluate(t2.visProp.gradientsecondopacity)), this._setAttr(e2, "focusposition", 100 * s.Z.evaluate(t2.visProp.gradientpositionx) + "%," + 100 * s.Z.evaluate(t2.visProp.gradientpositiony) + "%"), this._setAttr(e2, "focussize", "0,0")) : this._setAttr(e2, "type", "solid");
  }, setObjectFillColor: function(t2, e2, r3) {
    var o2, n2, a2, h2 = s.Z.evaluate(e2), l2 = s.Z.evaluate(r3), c2 = t2.rendNode;
    l2 = l2 > 0 ? l2 : 0, t2.visPropOld.fillcolor === h2 && t2.visPropOld.fillopacity === l2 || (s.Z.exists(h2) && false !== h2 && (9 !== h2.length ? (o2 = h2, a2 = l2) : (o2 = (n2 = D.Z.rgba2rgbo(h2))[0], a2 = l2 * n2[1]), "none" === o2 || false === o2 ? this._setAttr(t2.rendNode, "filled", "false") : (this._setAttr(t2.rendNode, "filled", "true"), this._setAttr(t2.rendNode, "fillcolor", o2), s.Z.exists(a2) && t2.rendNodeFill && this._setAttr(t2.rendNodeFill, "opacity", 100 * a2 + "%")), t2.type === i2.Z.OBJECT_TYPE_IMAGE && c2.filters.length > 1 && (c2.filters.item(1).opacity = Math.round(100 * a2), c2.filters.item(1).enabled = true)), t2.visPropOld.fillcolor = h2, t2.visPropOld.fillopacity = l2);
  }, setObjectStrokeColor: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = s.Z.evaluate(e2), c2 = s.Z.evaluate(r3), d2 = t2.rendNode;
    c2 = c2 > 0 ? c2 : 0, t2.visPropOld.strokecolor === l2 && t2.visPropOld.strokeopacity === c2 || (s.Z.exists(l2) && false !== l2 && (9 !== l2.length ? (o2 = l2, a2 = c2) : (o2 = (n2 = e2.rgba2rgbo(l2))[0], a2 = c2 * n2[1]), t2.elementClass === i2.Z.OBJECT_CLASS_TEXT ? (d2.filters.length > 1 && (d2.filters.item(1).opacity = Math.round(100 * a2), d2.filters.item(1).enabled = true), d2.style.color = o2) : (false !== o2 && (this._setAttr(d2, "stroked", "true"), this._setAttr(d2, "strokecolor", o2)), h2 = t2.rendNodeStroke, s.Z.exists(a2) && t2.type !== i2.Z.OBJECT_TYPE_IMAGE && this._setAttr(h2, "opacity", 100 * a2 + "%"))), t2.visPropOld.strokecolor = l2, t2.visPropOld.strokeopacity = c2);
  }, setObjectStrokeWidth: function(t2, e2) {
    var i3, r3 = s.Z.evaluate(e2);
    isNaN(r3) || t2.visPropOld.strokewidth === r3 || (i3 = t2.rendNode, this.setPropertyPrim(i3, "stroked", "true"), s.Z.exists(r3) && (this.setPropertyPrim(i3, "stroke-width", r3), 0 === r3 && s.Z.exists(t2.rendNodeStroke) && this._setAttr(i3, "stroked", "false")), t2.visPropOld.strokewidth = r3);
  }, setShadow: function(t2) {
    var e2 = t2.rendNodeShadow, i3 = s.Z.evaluate(t2.visProp.shadow);
    e2 && t2.visPropOld.shadow !== i3 && (i3 ? (this._setAttr(e2, "On", "True"), this._setAttr(e2, "Offset", "3pt,3pt"), this._setAttr(e2, "Opacity", "60%"), this._setAttr(e2, "Color", "#aaaaaa")) : this._setAttr(e2, "On", "False"), t2.visPropOld.shadow = i3);
  }, suspendRedraw: function() {
    this.container.style.display = "none";
  }, unsuspendRedraw: function() {
    this.container.style.display = "";
  } });
  const Y = t.Z.VMLRenderer;
  var j = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
  t.Z.Util = t.Z.Util || {}, t.Z.Util.genUUID = function(t2) {
    var e2, i3, s2 = [], r3 = 0;
    for ("" !== (t2 = t2 || "") && "-" !== t2.substr(t2.length - 1) && (t2 += "-"), i3 = 0; i3 < 36; i3++)
      8 === i3 || 13 === i3 || 18 === i3 || 23 === i3 ? s2[i3] = "-" : 14 === i3 ? s2[i3] = "4" : (r3 <= 2 && (r3 = 33554432 + 16777216 * Math.random() | 0), e2 = 15 & r3, r3 >>= 4, s2[i3] = j[19 === i3 ? 3 & e2 | 8 : e2]);
    return t2 + s2.join("");
  };
  const X = t.Z.Util;
  t.Z.CanvasRenderer = function(i3, s2) {
    if (this.type = "canvas", this.canvasRoot = null, this.suspendHandle = null, this.canvasId = X.genUUID(), this.canvasNamespace = null, e.Z.isBrowser)
      this.container = i3, this.container.style.MozUserSelect = "none", this.container.style.userSelect = "none", this.container.style.overflow = "hidden", "" === this.container.style.position && (this.container.style.position = "relative"), this.container.innerHTML = ['<canvas id="', this.canvasId, '" width="', s2.width, 'px" height="', s2.height, 'px"><', "/canvas>"].join(""), this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId), this.canvasRoot.style.display = "block", this.context = this.canvasRoot.getContext("2d");
    else if (e.Z.isNode())
      try {
        this.canvasRoot = t.Z.createCanvas(500, 500), this.context = this.canvasRoot.getContext("2d");
      } catch (t2) {
        throw new Error('JXG.createCanvas not available.\nInstall the npm package `canvas`\nand call:\n    import { createCanvas } from "canvas";\n    JXG.createCanvas = createCanvas;\n');
      }
    this.dashArray = [[2, 2], [5, 5], [10, 10], [20, 20], [20, 10, 10, 10], [20, 5, 10, 5]];
  }, t.Z.CanvasRenderer.prototype = new N(), t.Z.extend(t.Z.CanvasRenderer.prototype, { _drawPolygon: function(t2, e2, i3) {
    var s2, r3 = t2.length, o2 = this.context;
    if (r3 > 0) {
      if (i3 && (o2.lineWidth = 0), o2.beginPath(), o2.moveTo(t2[0][0], t2[0][1]), 1 === e2)
        for (s2 = 1; s2 < r3; s2++)
          o2.lineTo(t2[s2][0], t2[s2][1]);
      else
        for (s2 = 1; s2 < r3; s2 += 3)
          o2.bezierCurveTo(t2[s2][0], t2[s2][1], t2[s2 + 1][0], t2[s2 + 1][1], t2[s2 + 2][0], t2[s2 + 2][1]);
      i3 ? (o2.lineTo(t2[0][0], t2[0][1]), o2.closePath(), o2.fill("evenodd")) : o2.stroke();
    }
  }, _fill: function(t2) {
    var e2 = this.context;
    e2.save(), this._setColor(t2, "fill") && e2.fill("evenodd"), e2.restore();
  }, _rotatePoint: function(t2, e2, i3) {
    return [e2 * Math.cos(t2) - i3 * Math.sin(t2), e2 * Math.sin(t2) + i3 * Math.cos(t2)];
  }, _rotateShape: function(t2, e2) {
    var i3, s2 = [], r3 = t2.length;
    if (r3 <= 0)
      return t2;
    for (i3 = 0; i3 < r3; i3++)
      s2.push(this._rotatePoint(e2, t2[i3][0], t2[i3][1]));
    return s2;
  }, updateGradientAngle: function(t2, e2) {
    var s2, r3, o2, n2, a2, h2, l2, d2, u2, p2, _2, f2, b2 = 1, g2 = Math.cos(-e2), m2 = Math.sin(-e2), v2 = t2.getBoundingBox();
    return Math.abs(g2) > Math.abs(m2) ? b2 /= Math.abs(g2) : b2 /= Math.abs(m2), g2 >= 0 ? (o2 = 0, n2 = g2 * b2) : (o2 = -g2 * b2, n2 = 0), m2 >= 0 ? (a2 = 0, h2 = m2 * b2) : (a2 = -m2 * b2, h2 = 0), s2 = new c.Z(i2.Z.COORDS_BY_USER, [v2[0], v2[1]], t2.board), _2 = (r3 = new c.Z(i2.Z.COORDS_BY_USER, [v2[2], v2[3]], t2.board)).scrCoords[1] - s2.scrCoords[1], f2 = r3.scrCoords[2] - s2.scrCoords[2], l2 = s2.scrCoords[1] + _2 * o2, u2 = s2.scrCoords[2] + f2 * a2, d2 = s2.scrCoords[1] + _2 * n2, p2 = s2.scrCoords[2] + f2 * h2, this.context.createLinearGradient(l2, u2, d2, p2);
  }, updateGradientCircle: function(t2, e2, s2, r3, o2, n2, a2) {
    var h2, l2, d2, u2, p2, _2, f2, b2, g2, m2, v2 = t2.getBoundingBox();
    return h2 = new c.Z(i2.Z.COORDS_BY_USER, [v2[0], v2[1]], t2.board), g2 = (l2 = new c.Z(i2.Z.COORDS_BY_USER, [v2[2], v2[3]], t2.board)).scrCoords[1] - h2.scrCoords[1], m2 = h2.scrCoords[2] - l2.scrCoords[2], d2 = h2.scrCoords[1] + g2 * e2, u2 = l2.scrCoords[2] + m2 * s2, _2 = h2.scrCoords[1] + g2 * o2, f2 = l2.scrCoords[2] + m2 * n2, p2 = r3 * (g2 + m2) * 0.5, b2 = a2 * (g2 + m2) * 0.5, this.context.createRadialGradient(_2, f2, b2, d2, u2, p2);
  }, updateGradient: function(t2) {
    var e2, i3, r3, o2 = s.Z.evaluate(t2.visProp.gradient);
    return i3 = (i3 = s.Z.evaluate(t2.visProp.fillopacity)) > 0 ? i3 : 0, e2 = s.Z.evaluate(t2.visProp.fillcolor), "linear" === o2 ? r3 = this.updateGradientAngle(t2, s.Z.evaluate(t2.visProp.gradientangle)) : "radial" === o2 && (r3 = this.updateGradientCircle(t2, s.Z.evaluate(t2.visProp.gradientcx), s.Z.evaluate(t2.visProp.gradientcy), s.Z.evaluate(t2.visProp.gradientr), s.Z.evaluate(t2.visProp.gradientfx), s.Z.evaluate(t2.visProp.gradientfy), s.Z.evaluate(t2.visProp.gradientfr))), r3.addColorStop(s.Z.evaluate(t2.visProp.gradientstartoffset), e2), r3.addColorStop(s.Z.evaluate(t2.visProp.gradientendoffset), s.Z.evaluate(t2.visProp.gradientsecondcolor)), r3;
  }, _setColor: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2 = true, p2 = t2.visProp;
    return e2 = e2 || "stroke", i3 = i3 || e2, r3 = this._getHighlighted(t2), "linear" === (d2 = s.Z.evaluate(t2.visProp.gradient)) || "radial" === d2 ? (this.context[i3 + "Style"] = this.updateGradient(t2), u2) : ("none" !== (n2 = s.Z.evaluate(p2[r3 + e2 + "color"])) && false !== n2 ? (l2 = (l2 = s.Z.evaluate(p2[r3 + e2 + "opacity"])) > 0 ? l2 : 0, 9 !== n2.length ? (h2 = n2, c2 = l2) : (h2 = (a2 = D.Z.rgba2rgbo(n2))[0], c2 = l2 * a2[1]), this.context.globalAlpha = c2, this.context[i3 + "Style"] = h2) : u2 = false, o2 = parseFloat(s.Z.evaluate(p2[r3 + "strokewidth"])), "stroke" !== e2 || isNaN(o2) || (0 === o2 ? this.context.globalAlpha = 0 : this.context.lineWidth = o2), "stroke" === e2 && void 0 !== p2.linecap && "" !== p2.linecap && (this.context.lineCap = p2.linecap), u2);
  }, _stroke: function(t2) {
    var e2 = this.context, i3 = s.Z.evaluate(t2.visProp.dash);
    e2.save(), i3 > 0 ? e2.setLineDash && e2.setLineDash(this.dashArray[i3]) : this.context.lineDashArray = [], this._setColor(t2, "stroke") && e2.stroke(), e2.restore();
  }, _translateShape: function(t2, e2, i3) {
    var s2, r3 = [], o2 = t2.length;
    if (o2 <= 0)
      return t2;
    for (s2 = 0; s2 < o2; s2++)
      r3.push([t2[s2][0] + e2, t2[s2][1] + i3]);
    return r3;
  }, drawPoint: function(t2) {
    var e2 = s.Z.evaluate(t2.visProp.face), i3 = s.Z.evaluate(t2.visProp.size), r3 = t2.coords.scrCoords, o2 = i3 * Math.sqrt(3) * 0.5, n2 = 0.5 * i3, a2 = parseFloat(s.Z.evaluate(t2.visProp.strokewidth)) / 2, h2 = this.context;
    if (t2.visPropCalc.visible)
      switch (e2) {
        case "cross":
        case "x":
          h2.beginPath(), h2.moveTo(r3[1] - i3, r3[2] - i3), h2.lineTo(r3[1] + i3, r3[2] + i3), h2.moveTo(r3[1] + i3, r3[2] - i3), h2.lineTo(r3[1] - i3, r3[2] + i3), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
          break;
        case "circle":
        case "o":
          h2.beginPath(), h2.arc(r3[1], r3[2], i3 + 1 + a2, 0, 2 * Math.PI, false), h2.closePath(), this._fill(t2), this._stroke(t2);
          break;
        case "square":
        case "[]":
          if (i3 <= 0)
            break;
          h2.save(), this._setColor(t2, "stroke", "fill") && h2.fillRect(r3[1] - i3 - a2, r3[2] - i3 - a2, 2 * i3 + 3 * a2, 2 * i3 + 3 * a2), h2.restore(), h2.save(), this._setColor(t2, "fill"), h2.fillRect(r3[1] - i3 + a2, r3[2] - i3 + a2, 2 * i3 - a2, 2 * i3 - a2), h2.restore();
          break;
        case "plus":
        case "+":
          h2.beginPath(), h2.moveTo(r3[1] - i3, r3[2]), h2.lineTo(r3[1] + i3, r3[2]), h2.moveTo(r3[1], r3[2] - i3), h2.lineTo(r3[1], r3[2] + i3), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
          break;
        case "divide":
        case "|":
          h2.beginPath(), h2.moveTo(r3[1], r3[2] - i3), h2.lineTo(r3[1], r3[2] + i3), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
          break;
        case "minus":
        case "-":
          h2.beginPath(), h2.moveTo(r3[1] - i3, r3[2]), h2.lineTo(r3[1] + i3, r3[2]), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
          break;
        case "diamond":
        case "<>":
          h2.beginPath(), h2.moveTo(r3[1] - i3, r3[2]), h2.lineTo(r3[1], r3[2] + i3), h2.lineTo(r3[1] + i3, r3[2]), h2.lineTo(r3[1], r3[2] - i3), h2.closePath(), this._fill(t2), this._stroke(t2);
          break;
        case "triangleup":
        case "a":
        case "^":
          h2.beginPath(), h2.moveTo(r3[1], r3[2] - i3), h2.lineTo(r3[1] - o2, r3[2] + n2), h2.lineTo(r3[1] + o2, r3[2] + n2), h2.closePath(), this._fill(t2), this._stroke(t2);
          break;
        case "triangledown":
        case "v":
          h2.beginPath(), h2.moveTo(r3[1], r3[2] + i3), h2.lineTo(r3[1] - o2, r3[2] - n2), h2.lineTo(r3[1] + o2, r3[2] - n2), h2.closePath(), this._fill(t2), this._stroke(t2);
          break;
        case "triangleleft":
        case "<":
          h2.beginPath(), h2.moveTo(r3[1] - i3, r3[2]), h2.lineTo(r3[1] + n2, r3[2] - o2), h2.lineTo(r3[1] + n2, r3[2] + o2), h2.closePath(), this._fill(t2), this._stroke(t2);
          break;
        case "triangleright":
        case ">":
          h2.beginPath(), h2.moveTo(r3[1] + i3, r3[2]), h2.lineTo(r3[1] - n2, r3[2] - o2), h2.lineTo(r3[1] - n2, r3[2] + o2), h2.closePath(), this._fill(t2), this._stroke(t2);
      }
  }, updatePoint: function(t2) {
    this.drawPoint(t2);
  }, drawArrows: function(t2, e2, r3, o2, n2) {
    var a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2 = this.context, S2 = 1, T2 = 1, M2 = 1, N2 = n2.evFirst, A2 = n2.evLast;
    if ("none" !== s.Z.evaluate(t2.visProp.strokecolor) && (N2 || A2)) {
      if (t2.elementClass === i2.Z.OBJECT_CLASS_LINE)
        a2 = e2.scrCoords[1], h2 = e2.scrCoords[2], l2 = r3.scrCoords[1], c2 = r3.scrCoords[2], O2 = x2 = Math.atan2(c2 - h2, l2 - a2);
      else {
        if (a2 = t2.points[0].scrCoords[1], h2 = t2.points[0].scrCoords[2], (E2 = t2.points.length - 1) < 1)
          return;
        l2 = t2.points[t2.points.length - 1].scrCoords[1], c2 = t2.points[t2.points.length - 1].scrCoords[2], Z2 = t2.points[1].scrCoords[1] - t2.points[0].scrCoords[1], C2 = t2.points[1].scrCoords[2] - t2.points[0].scrCoords[2], y2 = t2.points[E2].scrCoords[1] - t2.points[E2 - 1].scrCoords[1], P2 = t2.points[E2].scrCoords[2] - t2.points[E2 - 1].scrCoords[2], N2 && (O2 = Math.atan2(C2, Z2)), A2 && (x2 = Math.atan2(P2, y2));
      }
      if (d2 = s.Z.evaluate(t2.visProp[o2 + "strokewidth"]), N2)
        if (u2 = d2 * n2.sizeFirst, f2 = S2 = n2.typeFirst, 2 === S2)
          _2 = [[u2, 0.5 * -u2], [0, 0], [u2, 0.5 * u2], [0.5 * u2, 0]];
        else if (3 === S2)
          _2 = [[u2 / 3, 0.5 * -u2], [0, 0.5 * -u2], [0, 0.5 * u2], [u2 / 3, 0.5 * u2]];
        else if (4 === S2)
          for (u2 /= 10, T2 = 3, v2 = (_2 = [[10, 3.31], [6.47, 3.84], [2.87, 4.5], [0, 6.63], [0.67, 5.52], [1.33, 4.42], [2, 3.31], [1.33, 2.21], [0.67, 1.1], [0, 0], [2.87, 2.13], [6.47, 2.79], [10, 3.31]]).length, m2 = 0; m2 < v2; m2++)
            _2[m2][0] *= -u2, _2[m2][1] *= u2, _2[m2][0] += 10 * u2, _2[m2][1] -= 3.31 * u2;
        else if (5 === S2)
          for (u2 /= 10, T2 = 3, v2 = (_2 = [[10, 3.28], [6.61, 4.19], [3.19, 5.07], [0, 6.55], [0.62, 5.56], [1, 4.44], [1, 3.28], [1, 2.11], [0.62, 0.99], [0, 0], [3.19, 1.49], [6.61, 2.37], [10, 3.28]]).length, m2 = 0; m2 < v2; m2++)
            _2[m2][0] *= -u2, _2[m2][1] *= u2, _2[m2][0] += 10 * u2, _2[m2][1] -= 3.28 * u2;
        else if (6 === S2)
          for (u2 /= 10, T2 = 3, v2 = (_2 = [[10, 2.84], [6.61, 3.59], [3.21, 4.35], [0, 5.68], [0.33, 4.73], [0.67, 3.78], [1, 2.84], [0.67, 1.89], [0.33, 0.95], [0, 0], [3.21, 1.33], [6.61, 2.09], [10, 2.84]]).length, m2 = 0; m2 < v2; m2++)
            _2[m2][0] *= -u2, _2[m2][1] *= u2, _2[m2][0] += 10 * u2, _2[m2][1] -= 2.84 * u2;
        else if (7 === S2)
          for (u2 = d2, T2 = 3, v2 = (_2 = [[0, 10.39], [2.01, 6.92], [5.96, 5.2], [10, 5.2], [5.96, 5.2], [2.01, 3.47], [0, 0]]).length, m2 = 0; m2 < v2; m2++)
            _2[m2][0] *= -u2, _2[m2][1] *= u2, _2[m2][0] += 10 * u2, _2[m2][1] -= 5.2 * u2;
        else
          _2 = [[u2, 0.5 * -u2], [0, 0], [u2, 0.5 * u2]];
      if (A2)
        if (u2 = d2 * n2.sizeLast, b2 = S2 = n2.typeLast, 2 === S2)
          p2 = [[-u2, 0.5 * -u2], [0, 0], [-u2, 0.5 * u2], [0.5 * -u2, 0]];
        else if (3 === S2)
          p2 = [[-u2 / 3, 0.5 * -u2], [0, 0.5 * -u2], [0, 0.5 * u2], [-u2 / 3, 0.5 * u2]];
        else if (4 === S2)
          for (u2 /= 10, M2 = 3, v2 = (p2 = [[10, 3.31], [6.47, 3.84], [2.87, 4.5], [0, 6.63], [0.67, 5.52], [1.33, 4.42], [2, 3.31], [1.33, 2.21], [0.67, 1.1], [0, 0], [2.87, 2.13], [6.47, 2.79], [10, 3.31]]).length, m2 = 0; m2 < v2; m2++)
            p2[m2][0] *= u2, p2[m2][1] *= u2, p2[m2][0] -= 10 * u2, p2[m2][1] -= 3.31 * u2;
        else if (5 === S2)
          for (u2 /= 10, M2 = 3, v2 = (p2 = [[10, 3.28], [6.61, 4.19], [3.19, 5.07], [0, 6.55], [0.62, 5.56], [1, 4.44], [1, 3.28], [1, 2.11], [0.62, 0.99], [0, 0], [3.19, 1.49], [6.61, 2.37], [10, 3.28]]).length, m2 = 0; m2 < v2; m2++)
            p2[m2][0] *= u2, p2[m2][1] *= u2, p2[m2][0] -= 10 * u2, p2[m2][1] -= 3.28 * u2;
        else if (6 === S2)
          for (u2 /= 10, M2 = 3, v2 = (p2 = [[10, 2.84], [6.61, 3.59], [3.21, 4.35], [0, 5.68], [0.33, 4.73], [0.67, 3.78], [1, 2.84], [0.67, 1.89], [0.33, 0.95], [0, 0], [3.21, 1.33], [6.61, 2.09], [10, 2.84]]).length, m2 = 0; m2 < v2; m2++)
            p2[m2][0] *= u2, p2[m2][1] *= u2, p2[m2][0] -= 10 * u2, p2[m2][1] -= 2.84 * u2;
        else if (7 === S2)
          for (u2 = d2, M2 = 3, v2 = (p2 = [[0, 10.39], [2.01, 6.92], [5.96, 5.2], [10, 5.2], [5.96, 5.2], [2.01, 3.47], [0, 0]]).length, m2 = 0; m2 < v2; m2++)
            p2[m2][0] *= u2, p2[m2][1] *= u2, p2[m2][0] -= 10 * u2, p2[m2][1] -= 5.2 * u2;
        else
          p2 = [[-u2, 0.5 * -u2], [0, 0], [-u2, 0.5 * u2]];
      w2.save(), this._setColor(t2, "stroke", "fill") && (this._setColor(t2, "stroke"), N2 && (g2 = 7 !== f2, this._drawPolygon(this._translateShape(this._rotateShape(_2, O2), a2, h2), T2, g2)), A2 && (g2 = 7 !== b2, this._drawPolygon(this._translateShape(this._rotateShape(p2, x2), l2, c2), M2, g2))), w2.restore();
    }
  }, drawLine: function(t2) {
    var e2, r3, o2, n2, a2, h2 = new c.Z(i2.Z.COORDS_BY_USER, t2.point1.coords.usrCoords, t2.board), l2 = new c.Z(i2.Z.COORDS_BY_USER, t2.point2.coords.usrCoords, t2.board), d2 = null;
    t2.visPropCalc.visible && (o2 = this._getHighlighted(t2), n2 = s.Z.evaluate(t2.visProp[o2 + "strokewidth"]), ((a2 = this.getArrowHeadData(t2, n2, o2)).evFirst || a2.evLast) && (d2 = -4), u.Z.calcStraight(t2, h2, l2, d2), this.handleTouchpoints(t2, h2, l2, a2), e2 = new c.Z(i2.Z.COORDS_BY_USER, h2.usrCoords, t2.board), r3 = new c.Z(i2.Z.COORDS_BY_USER, l2.usrCoords, t2.board), this.getPositionArrowHead(t2, h2, l2, a2), this.context.beginPath(), this.context.moveTo(h2.scrCoords[1], h2.scrCoords[2]), this.context.lineTo(l2.scrCoords[1], l2.scrCoords[2]), this._stroke(t2), (a2.evFirst || a2.evLast) && this.drawArrows(t2, e2, r3, o2, a2));
  }, updateLine: function(t2) {
    this.drawLine(t2);
  }, drawTicks: function() {
  }, updateTicks: function(t2) {
    var e2, i3, s2, r3, o2, n2, a2 = t2.ticks.length, h2 = this.context;
    for (h2.beginPath(), e2 = 0; e2 < a2; e2++)
      for (s2 = (i3 = t2.ticks[e2])[0], r3 = i3[1], o2 = s2.length, h2.moveTo(s2[0], r3[0]), n2 = 1; n2 < o2; ++n2)
        h2.lineTo(s2[n2], r3[n2]);
    h2.lineCap = "round", this._stroke(t2);
  }, drawCurve: function(t2) {
    var e2, i3, r3;
    s.Z.evaluate(t2.visProp.handdrawing) ? this.updatePathStringBezierPrim(t2) : this.updatePathStringPrim(t2), t2.numberPoints > 1 && (e2 = this._getHighlighted(t2), i3 = s.Z.evaluate(t2.visProp[e2 + "strokewidth"]), ((r3 = this.getArrowHeadData(t2, i3, e2)).evFirst || r3.evLast) && this.drawArrows(t2, null, null, e2, r3));
  }, updateCurve: function(t2) {
    this.drawCurve(t2);
  }, drawEllipse: function(t2) {
    var e2 = t2.center.coords.scrCoords[1], i3 = t2.center.coords.scrCoords[2], s2 = t2.board.unitX, r3 = t2.board.unitY, o2 = 2 * t2.Radius(), n2 = 2 * t2.Radius(), a2 = o2 * s2, h2 = n2 * r3, l2 = e2 - a2 / 2, c2 = i3 - h2 / 2, d2 = a2 / 2 * 0.5522848, u2 = h2 / 2 * 0.5522848, p2 = l2 + a2, _2 = c2 + h2, f2 = l2 + a2 / 2, b2 = c2 + h2 / 2, g2 = this.context;
    o2 > 0 && n2 > 0 && !isNaN(e2 + i3) && (g2.beginPath(), g2.moveTo(l2, b2), g2.bezierCurveTo(l2, b2 - u2, f2 - d2, c2, f2, c2), g2.bezierCurveTo(f2 + d2, c2, p2, b2 - u2, p2, b2), g2.bezierCurveTo(p2, b2 + u2, f2 + d2, _2, f2, _2), g2.bezierCurveTo(f2 - d2, _2, l2, b2 + u2, l2, b2), g2.closePath(), this._fill(t2), this._stroke(t2));
  }, updateEllipse: function(t2) {
    return this.drawEllipse(t2);
  }, displayCopyright: function(t2, e2) {
    var i3 = this.context;
    i3.save(), i3.font = e2 + "px Arial", i3.fillStyle = "#aaa", i3.lineWidth = 0.5, i3.fillText(t2, 10, 2 + e2), i3.restore();
  }, drawInternalText: function(t2) {
    var e2 = s.Z.evaluate(t2.visProp.fontsize), i3 = s.Z.evaluate(t2.visProp.fontunit), r3 = t2.getAnchorX(), o2 = t2.getAnchorY(), n2 = this.context;
    return n2.save(), this._setColor(t2, "stroke", "fill") && !isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2]) && (n2.font = (e2 > 0 ? e2 : 0) + i3 + " Arial", this.transformImage(t2, t2.transformations), "left" === r3 ? n2.textAlign = "left" : "right" === r3 ? n2.textAlign = "right" : "middle" === r3 && (n2.textAlign = "center"), "bottom" === o2 ? n2.textBaseline = "bottom" : "top" === o2 ? n2.textBaseline = "top" : "middle" === o2 && (n2.textBaseline = "middle"), n2.fillText(t2.plaintext, t2.coords.scrCoords[1], t2.coords.scrCoords[2])), n2.restore(), null;
  }, updateInternalText: function(t2) {
    this.drawInternalText(t2);
  }, setObjectStrokeColor: function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = s.Z.evaluate(e2), c2 = s.Z.evaluate(r3);
    c2 = c2 > 0 ? c2 : 0, t2.visPropOld.strokecolor === l2 && t2.visPropOld.strokeopacity === c2 || (s.Z.exists(l2) && false !== l2 && (9 !== l2.length ? (o2 = l2, a2 = c2) : (o2 = (n2 = D.Z.rgba2rgbo(l2))[0], a2 = c2 * n2[1]), h2 = t2.rendNode, t2.elementClass === i2.Z.OBJECT_CLASS_TEXT && "html" === s.Z.evaluate(t2.visProp.display) && (h2.style.color = o2, h2.style.opacity = a2)), t2.visPropOld.strokecolor = l2, t2.visPropOld.strokeopacity = c2);
  }, drawImage: function(t2) {
    t2.rendNode = new Image(), t2._src = "", this.updateImage(t2);
  }, updateImage: function(t2) {
    var e2 = this.context, i3 = s.Z.evaluate(t2.visProp.fillopacity), r3 = s.Z.bind(function() {
      t2.imgIsLoaded = true, t2.size[0] <= 0 || t2.size[1] <= 0 || (e2.save(), e2.globalAlpha = i3, this.transformImage(t2, t2.transformations), e2.drawImage(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1], t2.size[0], t2.size[1]), e2.restore());
    }, this);
    this.updateImageURL(t2) ? t2.rendNode.onload = r3 : t2.imgIsLoaded && r3();
  }, transformImage: function(t2, e2) {
    var i3, s2 = e2.length, r3 = this.context;
    s2 > 0 && (i3 = this.joinTransforms(t2, e2), Math.abs(l.Z.det(i3)) >= o.Z.eps && r3.transform(i3[1][1], i3[2][1], i3[1][2], i3[2][2], i3[1][0], i3[2][0]));
  }, updateImageURL: function(t2) {
    var e2;
    return e2 = s.Z.evaluate(t2.url), t2._src !== e2 && (t2.imgIsLoaded = false, t2.rendNode.src = e2, t2._src = e2, true);
  }, remove: function(t2) {
    s.Z.exists(t2) && s.Z.exists(t2.parentNode) && t2.parentNode.removeChild(t2);
  }, updatePathStringPrim: function(t2) {
    var e2, i3, s2, r3, o2, n2 = "M", a2 = n2, h2 = 5e3, l2 = this.context;
    if (!(t2.numberPoints <= 0)) {
      if (o2 = Math.min(t2.points.length, t2.numberPoints), l2.beginPath(), 1 === t2.bezierDegree)
        for (e2 = 0; e2 < o2; e2++)
          i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? a2 = n2 : (i3[1] > h2 ? i3[1] = h2 : i3[1] < -5e3 && (i3[1] = -5e3), i3[2] > h2 ? i3[2] = h2 : i3[2] < -5e3 && (i3[2] = -5e3), a2 === n2 ? l2.moveTo(i3[1], i3[2]) : l2.lineTo(i3[1], i3[2]), a2 = "L");
      else if (3 === t2.bezierDegree)
        for (e2 = 0; e2 < o2; )
          i3 = t2.points[e2].scrCoords, isNaN(i3[1]) || isNaN(i3[2]) ? a2 = n2 : (a2 === n2 ? l2.moveTo(i3[1], i3[2]) : (e2 += 1, s2 = t2.points[e2].scrCoords, e2 += 1, r3 = t2.points[e2].scrCoords, l2.bezierCurveTo(i3[1], i3[2], s2[1], s2[2], r3[1], r3[2])), a2 = "C"), e2 += 1;
      l2.lineCap = "round", this._fill(t2), this._stroke(t2);
    }
  }, updatePathStringBezierPrim: function(t2) {
    var e2, i3, r3, o2, n2, a2, h2, c2 = "M", d2 = c2, u2 = 5e3, p2 = s.Z.evaluate(t2.visProp.strokewidth), _2 = "plot" !== s.Z.evaluate(t2.visProp.curvetype), f2 = this.context;
    if (!(t2.numberPoints <= 0)) {
      for (_2 && t2.board.options.curve.RDPsmoothing && (t2.points = l.Z.RamerDouglasPeucker(t2.points, 0.5)), h2 = Math.min(t2.points.length, t2.numberPoints), f2.beginPath(), i3 = 1; i3 < 3; i3++)
        for (d2 = c2, e2 = 0; e2 < h2; e2++)
          o2 = t2.points[e2].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? d2 = c2 : (o2[1] > u2 ? o2[1] = u2 : o2[1] < -5e3 && (o2[1] = -5e3), o2[2] > u2 ? o2[2] = u2 : o2[2] < -5e3 && (o2[2] = -5e3), d2 === c2 ? f2.moveTo(o2[1], o2[2]) : (r3 = 2 * i3, f2.bezierCurveTo(n2 + 0.333 * (o2[1] - n2) + p2 * (r3 * Math.random() - i3), a2 + 0.333 * (o2[2] - a2) + p2 * (r3 * Math.random() - i3), n2 + 0.666 * (o2[1] - n2) + p2 * (r3 * Math.random() - i3), a2 + 0.666 * (o2[2] - a2) + p2 * (r3 * Math.random() - i3), o2[1], o2[2])), d2 = "C", n2 = o2[1], a2 = o2[2]);
      f2.lineCap = "round", this._fill(t2), this._stroke(t2);
    }
  }, updatePolygonPrim: function(t2, e2) {
    var i3, s2, r3, o2 = e2.vertices.length, n2 = this.context, a2 = true;
    if (!(o2 <= 0) && e2.visPropCalc.visible) {
      for ("polygonalchain" === e2.elType && o2++, n2.beginPath(), s2 = 0; !e2.vertices[s2].isReal && s2 < o2 - 1; )
        s2++, a2 = false;
      for (i3 = e2.vertices[s2].coords.scrCoords, n2.moveTo(i3[1], i3[2]), r3 = s2; r3 < o2 - 1; r3++)
        e2.vertices[r3].isReal || (a2 = false), i3 = e2.vertices[r3].coords.scrCoords, n2.lineTo(i3[1], i3[2]);
      n2.closePath(), a2 && this._fill(e2);
    }
  }, display: function(t2, e2) {
    t2 && t2.rendNode && (t2.visPropOld.visible = e2, t2.rendNode.style.visibility = e2 ? "inherit" : "hidden");
  }, show: function(e2) {
    t.Z.deprecated("Board.renderer.show()", "Board.renderer.display()"), s.Z.exists(e2.rendNode) && (e2.rendNode.style.visibility = "inherit");
  }, hide: function(e2) {
    t.Z.deprecated("Board.renderer.hide()", "Board.renderer.display()"), s.Z.exists(e2.rendNode) && (e2.rendNode.style.visibility = "hidden");
  }, setGradient: function(t2) {
    var e2;
    e2 = (e2 = s.Z.evaluate(t2.visProp.fillopacity)) > 0 ? e2 : 0;
  }, setShadow: function(t2) {
    t2.visPropOld.shadow !== t2.visProp.shadow && (t2.visPropOld.shadow = t2.visProp.shadow);
  }, highlight: function(t2) {
    return t2.elementClass === i2.Z.OBJECT_CLASS_TEXT && "html" === s.Z.evaluate(t2.visProp.display) ? this.updateTextStyle(t2, true) : (t2.board.prepareUpdate(), t2.board.renderer.suspendRedraw(t2.board), t2.board.updateRenderer(), t2.board.renderer.unsuspendRedraw()), this;
  }, noHighlight: function(t2) {
    return t2.elementClass === i2.Z.OBJECT_CLASS_TEXT && "html" === s.Z.evaluate(t2.visProp.display) ? this.updateTextStyle(t2, false) : (t2.board.prepareUpdate(), t2.board.renderer.suspendRedraw(t2.board), t2.board.updateRenderer(), t2.board.renderer.unsuspendRedraw()), this;
  }, suspendRedraw: function(e2) {
    this.context.save(), this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height), e2 && e2.attr.showcopyright && this.displayCopyright(t.Z.licenseText, 12);
  }, unsuspendRedraw: function() {
    this.context.restore();
  }, resize: function(t2, e2) {
    this.container ? (this.canvasRoot.style.width = parseFloat(t2) + "px", this.canvasRoot.style.height = parseFloat(e2) + "px", this.canvasRoot.setAttribute("width", 2 * parseFloat(t2) + "px"), this.canvasRoot.setAttribute("height", 2 * parseFloat(e2) + "px")) : (this.canvasRoot.width = 2 * parseFloat(t2), this.canvasRoot.height = 2 * parseFloat(e2)), this.context = this.canvasRoot.getContext("2d"), this.context.scale(2, 2);
  }, removeToInsertLater: function() {
    return function() {
    };
  } });
  const U = t.Z.CanvasRenderer;
  t.Z.NoRenderer = function() {
    this.enhancedRendering = false, this.type = "no";
  }, t.Z.extend(t.Z.NoRenderer.prototype, { drawPoint: function(t2) {
  }, updatePoint: function(t2) {
  }, changePointStyle: function(t2) {
  }, drawLine: function(t2) {
  }, updateLine: function(t2) {
  }, drawTicks: function(t2) {
  }, updateTicks: function(t2) {
  }, drawCurve: function(t2) {
  }, updateCurve: function(t2) {
  }, drawEllipse: function(t2) {
  }, updateEllipse: function(t2) {
  }, drawPolygon: function(t2) {
  }, updatePolygon: function(t2) {
  }, displayCopyright: function(t2, e2) {
  }, drawInternalText: function(t2) {
  }, updateInternalText: function(t2) {
  }, drawText: function(t2) {
  }, updateText: function(t2) {
  }, updateTextStyle: function(t2, e2) {
  }, updateInternalTextStyle: function(t2, e2, i3) {
  }, drawImage: function(t2) {
  }, updateImage: function(t2) {
  }, transformImage: function(t2, e2) {
  }, updateImageURL: function(t2) {
  }, appendChildPrim: function(t2, e2) {
  }, appendNodesToElement: function(t2, e2) {
  }, createPrim: function(t2, e2) {
    return null;
  }, remove: function(t2) {
  }, makeArrows: function(t2) {
  }, updateEllipsePrim: function(t2, e2, i3, s2, r3) {
  }, updateLinePrim: function(t2, e2, i3, s2, r3, o2) {
  }, updatePathPrim: function(t2, e2, i3) {
  }, updatePathStringPoint: function(t2, e2, i3) {
  }, updatePathStringPrim: function(t2) {
  }, updatePathStringBezierPrim: function(t2) {
  }, updatePolygonPrim: function(t2, e2) {
  }, updateRectPrim: function(t2, e2, i3, s2, r3) {
  }, setPropertyPrim: function(t2, e2, i3) {
  }, display: function(t2, e2) {
    t2 && (t2.visPropOld.visible = e2);
  }, show: function(t2) {
  }, hide: function(t2) {
  }, setBuffering: function(t2, e2) {
  }, setDashStyle: function(t2) {
  }, setDraft: function(t2) {
  }, removeDraft: function(t2) {
  }, setGradient: function(t2) {
  }, updateGradient: function(t2) {
  }, setObjectTransition: function(t2, e2) {
  }, setObjectFillColor: function(t2, e2, i3) {
  }, setObjectStrokeColor: function(t2, e2, i3) {
  }, setObjectStrokeWidth: function(t2, e2) {
  }, setShadow: function(t2) {
  }, highlight: function(t2) {
  }, noHighlight: function(t2) {
  }, suspendRedraw: function() {
  }, unsuspendRedraw: function() {
  }, drawZoomBar: function(t2) {
  }, getElementById: function(t2) {
    return null;
  }, resize: function(t2, e2) {
  }, removeToInsertLater: function() {
    return function() {
    };
  } }), t.Z.NoRenderer.prototype = new N();
  const F = t.Z.NoRenderer;
  t.Z.JSXGraph = { rendererType: (M.Z.board.renderer = "no", e.Z.supportsVML() && (M.Z.board.renderer = "vml", document.onmousemove = function() {
    var t2;
    return document.body && (t2 = document.body.scrollLeft, t2 += document.body.scrollTop), t2;
  }), e.Z.supportsCanvas() && (M.Z.board.renderer = "canvas"), e.Z.supportsSVG() && (M.Z.board.renderer = "svg"), e.Z.isNode() && e.Z.supportsCanvas() && (M.Z.board.renderer = "canvas"), (e.Z.isNode() || "no" === M.Z.renderer) && (M.Z.text.display = "internal", M.Z.infobox.display = "internal"), M.Z.board.renderer), initRenderer: function(t2, e2, i3, r3) {
    var o2;
    if (s.Z.exists(i3) && false !== i3 || "object" != typeof document || (i3 = document), "object" == typeof i3 && null !== t2)
      for (o2 = i3.getElementById(t2); o2.firstChild; )
        o2.removeChild(o2.firstChild);
    else
      o2 = t2;
    return void 0 !== r3 && "auto" !== r3 || (r3 = this.rendererType), "svg" === r3 ? new I(o2, e2) : "vml" === r3 ? new Y(o2) : "canvas" === r3 ? new U(o2, e2) : new F();
  }, _setAttributes: function(t2) {
    var e2 = s.Z.copyAttributes(t2, M.Z, "board");
    return e2.zoom = s.Z.copyAttributes(e2, M.Z, "board", "zoom"), e2.pan = s.Z.copyAttributes(e2, M.Z, "board", "pan"), e2.drag = s.Z.copyAttributes(e2, M.Z, "board", "drag"), e2.keyboard = s.Z.copyAttributes(e2, M.Z, "board", "keyboard"), e2.selection = s.Z.copyAttributes(e2, M.Z, "board", "selection"), e2.navbar = s.Z.copyAttributes(e2.navbar, M.Z, "navbar"), e2.screenshot = s.Z.copyAttributes(e2, M.Z, "board", "screenshot"), e2.resize = s.Z.copyAttributes(e2, M.Z, "board", "resize"), e2.fullscreen = s.Z.copyAttributes(e2, M.Z, "board", "fullscreen"), e2.logging = s.Z.copyAttributes(e2, M.Z, "board", "logging"), e2.movetarget = t2.moveTarget || t2.movetarget || M.Z.board.moveTarget, e2;
  }, _fillBoard: function(e2, i3, s2) {
    e2.initInfobox(), e2.maxboundingbox = i3.maxboundingbox, e2.resizeContainer(s2.width, s2.height, true, true), e2._createSelectionPolygon(i3), e2.renderer.drawZoomBar(e2, i3.navbar), t.Z.boards[e2.id] = e2;
  }, _setARIA: function(t2, i3) {
    var s2, r3, o2, n2, a2, h2, l2 = i3.document;
    if ("object" != typeof l2) {
      if (!e.Z.isBrowser)
        return;
      l2 = document;
    }
    s2 = (r3 = l2.getElementById(t2)).ownerDocument, n2 = r3.parentNode, a2 = t2 + "_ARIAlabel", h2 = t2 + "_ARIAdescription", (o2 = s2.createElement("div")).innerHTML = i3.title, o2.setAttribute("id", a2), o2.style.display = "none", n2.insertBefore(o2, r3), (o2 = s2.createElement("div")).innerHTML = i3.description, o2.setAttribute("id", h2), o2.style.display = "none", n2.insertBefore(o2, r3), r3.setAttribute("aria-labelledby", a2), r3.setAttribute("aria-describedby", h2);
  }, _removeARIANodes: function(t2) {
    var e2, i3, s2;
    "object" == typeof (s2 = t2.document || document) && (i3 = t2.containerObj.getAttribute("aria-labelledby"), (e2 = s2.getElementById(i3)) && e2.parentNode && e2.parentNode.removeChild(e2), i3 = t2.containerObj.getAttribute("aria-describedby"), (e2 = s2.getElementById(i3)) && e2.parentNode && e2.parentNode.removeChild(e2));
  }, initBoard: function(t2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2 = 0, v2 = 0;
    return i3 = i3 || {}, p2 = this._setAttributes(i3), d2 = e.Z.getDimensions(t2, p2.document), p2.unitx || p2.unity ? (r3 = s.Z.def(p2.originx, 150), o2 = s.Z.def(p2.originy, 150), n2 = s.Z.def(p2.unitx, 50), a2 = s.Z.def(p2.unity, 50)) : ((u2 = p2.boundingbox)[0] < p2.maxboundingbox[0] && (u2[0] = p2.maxboundingbox[0]), u2[1] > p2.maxboundingbox[1] && (u2[1] = p2.maxboundingbox[1]), u2[2] > p2.maxboundingbox[2] && (u2[2] = p2.maxboundingbox[2]), u2[3] < p2.maxboundingbox[3] && (u2[3] = p2.maxboundingbox[3]), l2 = parseInt(d2.width, 10), c2 = parseInt(d2.height, 10), s.Z.exists(u2) && p2.keepaspectratio ? (n2 = l2 / (u2[2] - u2[0]), a2 = c2 / (u2[1] - u2[3]), Math.abs(n2) < Math.abs(a2) ? v2 = 0.5 * (c2 / (a2 = Math.abs(n2) * a2 / Math.abs(a2)) - (u2[1] - u2[3])) : m2 = 0.5 * (l2 / (n2 = Math.abs(a2) * n2 / Math.abs(n2)) - (u2[2] - u2[0]))) : (n2 = l2 / (u2[2] - u2[0]), a2 = c2 / (u2[1] - u2[3])), r3 = -n2 * (u2[0] - m2), o2 = a2 * (u2[1] + v2)), h2 = this.initRenderer(t2, d2, p2.document, p2.renderer), this._setARIA(t2, p2), (g2 = new B(t2, h2, p2.id, [r3, o2], p2.zoomfactor * p2.zoomx, p2.zoomfactor * p2.zoomy, n2, a2, d2.width, d2.height, p2)).keepaspectratio = p2.keepaspectratio, this._fillBoard(g2, p2, d2), g2.suspendUpdate(), p2.axis && (_2 = "object" == typeof p2.axis ? p2.axis : {}, f2 = s.Z.deepCopy(M.Z.board.defaultAxes.x, _2), b2 = s.Z.deepCopy(M.Z.board.defaultAxes.y, _2), p2.defaultaxes.x && (f2 = s.Z.deepCopy(f2, p2.defaultaxes.x)), p2.defaultaxes.y && (b2 = s.Z.deepCopy(b2, p2.defaultaxes.y)), g2.defaultAxes = {}, g2.defaultAxes.x = g2.create("axis", [[0, 0], [1, 0]], f2), g2.defaultAxes.y = g2.create("axis", [[0, 0], [0, 1]], b2)), p2.grid && g2.create("grid", [], "object" == typeof p2.grid ? p2.grid : {}), g2.unsuspendUpdate(), g2;
  }, loadBoardFromFile: function(t2, i3, s2, r3, o2) {
    var n2, a2, h2, l2, c2;
    return r3 = r3 || {}, n2 = this._setAttributes(r3), l2 = e.Z.getDimensions(t2, n2.document), a2 = this.initRenderer(t2, l2, n2.document, n2.renderer), this._setARIA(t2, n2), h2 = new B(t2, a2, "", [150, 150], 1, 1, 50, 50, l2.width, l2.height, n2), this._fillBoard(h2, n2, l2), c2 = n2.encoding || "iso-8859-1", A.parseFileContent(i3, h2, s2, true, c2, o2), h2;
  }, loadBoardFromString: function(t2, i3, s2, r3, o2) {
    var n2, a2, h2, l2;
    return r3 = r3 || {}, n2 = this._setAttributes(r3), l2 = e.Z.getDimensions(t2, n2.document), a2 = this.initRenderer(t2, l2, n2.document, n2.renderer), this._setARIA(t2, n2), h2 = new B(t2, a2, "", [150, 150], 1, 1, 50, 50, l2.width, l2.height, n2), this._fillBoard(h2, n2, l2), A.parseString(i3, h2, s2, true, o2), h2;
  }, freeBoard: function(e2) {
    var i3;
    for (i3 in "string" == typeof e2 && (e2 = t.Z.boards[e2]), this._removeARIANodes(e2), e2.removeEventHandlers(), e2.suspendUpdate(), e2.objects)
      e2.objects.hasOwnProperty(i3) && e2.objects[i3].remove();
    for (; e2.containerObj.firstChild; )
      e2.containerObj.removeChild(e2.containerObj.firstChild);
    for (i3 in e2.objects)
      e2.objects.hasOwnProperty(i3) && delete e2.objects[i3];
    delete e2.renderer, e2.jc.creator.clearCache(), delete e2.jc, delete t.Z.boards[e2.id];
  }, registerElement: function(e2, i3) {
    t.Z.deprecated("JXG.JSXGraph.registerElement()", "JXG.registerElement()"), t.Z.registerElement(e2, i3);
  } }, e.Z.isBrowser && "object" == typeof window && "object" == typeof document && e.Z.addEvent(window, "load", function() {
    var e2, i3, r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2 = false, C2 = document.getElementsByTagName("script"), y2 = function(e3, i4, s2) {
      var r4 = t.Z.JSXGraph.initBoard(n2, { boundingbox: s2, keepaspectratio: true, grid: b2, axis: f2, showReload: true });
      if (i4.toLowerCase().indexOf("script") > -1)
        r4.construct(e3);
      else
        try {
          r4.jc.parse(e3);
        } catch (e4) {
          t.Z.debug(e4);
        }
      return r4;
    }, P2 = function(e3, i4, s2, r4) {
      return function() {
        var o3;
        t.Z.JSXGraph.freeBoard(e3), (o3 = y2(i4, s2, r4)).reload = P2(o3, i4, s2, r4);
      };
    };
    for (i3 = 0; i3 < C2.length; i3++)
      if (e2 = C2[i3].getAttribute("type", false), s.Z.exists(e2) && ("text/jessiescript" === e2.toLowerCase() || "jessiescript" === e2.toLowerCase() || "text/jessiecode" === e2.toLowerCase() || "jessiecode" === e2.toLowerCase())) {
        if (p2 = C2[i3].getAttribute("class", false) || "", l2 = C2[i3].getAttribute("width", false) || "", c2 = C2[i3].getAttribute("height", false) || "", d2 = C2[i3].getAttribute("maxwidth", false) || "100%", u2 = C2[i3].getAttribute("aspectratio", false) || "1/1", _2 = C2[i3].getAttribute("boundingbox", false) || "-5, 5, 5, -5", n2 = C2[i3].getAttribute("container", false), m2 = C2[i3].getAttribute("src", false), 4 !== (_2 = _2.split(",")).length)
          _2 = [-5, 5, 5, -5];
        else
          for (r3 = 0; r3 < _2.length; r3++)
            _2[r3] = parseFloat(_2[r3]);
        if (f2 = s.Z.str2Bool(C2[i3].getAttribute("axis", false) || "false"), b2 = s.Z.str2Bool(C2[i3].getAttribute("grid", false) || "false"), s.Z.exists(n2))
          o2 = document.getElementById(n2);
        else {
          n2 = "jessiescript_autgen_jxg_" + i3, (o2 = document.createElement("div")).setAttribute("id", n2), h2 = "" !== l2 ? "width:" + l2 + ";" : "", h2 += "" !== c2 ? "height:" + c2 + ";" : "", h2 += "" !== d2 ? "max-width:" + d2 + ";" : "", h2 += "" !== u2 ? "aspect-ratio:" + u2 + ";" : "", o2.setAttribute("style", h2), o2.setAttribute("class", "jxgbox " + p2);
          try {
            document.body.insertBefore(o2, C2[i3]);
          } catch (t2) {
            "object" == typeof jQuery && jQuery(o2).insertBefore(C2[i3]);
          }
        }
        g2 = "", s.Z.exists(m2) ? (Z2 = true, (v2 = new XMLHttpRequest()).open("GET", m2), v2.overrideMimeType("text/plain; charset=x-user-defined"), v2.addEventListener("load", function() {
          if (!(this.status < 400))
            throw new Error("\nJSXGraph: failed to load file", m2, ":", this.responseText);
          g2 = this.responseText + "\n" + g2, (a2 = y2(g2, e2, _2)).reload = P2(a2, g2, e2, _2);
        }), v2.addEventListener("error", function(t2) {
          throw new Error("\nJSXGraph: failed to load file", m2, ":", t2);
        }), v2.send()) : Z2 = false, document.getElementById(n2) ? (g2 = (g2 = C2[i3].innerHTML).replace(/<!\[CDATA\[/g, "").replace(/\]\]>/g, ""), C2[i3].innerHTML = g2, Z2 || ((a2 = y2(g2, e2, _2)).reload = P2(a2, g2, e2, _2))) : t.Z.debug("JSXGraph: Apparently the div injection failed. Can't create a board, sorry.");
      }
  }, window);
  t.Z.JSXGraph;
  var J = __webpack_require__(958), G = __webpack_require__(218);
  t.Z.Point = function(t2, e2, s2) {
    this.constructor(t2, s2, i2.Z.OBJECT_TYPE_POINT, i2.Z.OBJECT_CLASS_POINT), this.element = this.board.select(s2.anchor), this.coordsConstructor(e2), this.elType = "point", this.id = this.board.setId(this, "P"), this.board.renderer.drawPoint(this), this.board.finalizeAdding(this), this.createGradient(), this.createLabel();
  }, t.Z.Point.prototype = new J.Z(), s.Z.copyPrototypeMethods(t.Z.Point, G.Z, "coordsConstructor"), t.Z.extend(t.Z.Point.prototype, { hasPoint: function(t2, e2) {
    var i3, r3, o2, n2 = this.coords.scrCoords, a2 = s.Z.evaluate(this.visProp.sizeunit);
    return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (o2 = this.board._inputDevice, r3 = s.Z.evaluate(this.visProp.precision[o2])) : r3 = this.board.options.precision.hasPoint, i3 = parseFloat(s.Z.evaluate(this.visProp.size)), "user" === a2 && (i3 *= Math.sqrt(this.board.unitX * this.board.unitY)), (i3 += 0.5 * parseFloat(s.Z.evaluate(this.visProp.strokewidth))) < r3 && (i3 = r3), Math.abs(n2[1] - t2) < i3 + 2 && Math.abs(n2[2] - e2) < i3 + 2;
  }, update: function(t2) {
    return this.needsUpdate ? (this.updateCoords(t2), s.Z.evaluate(this.visProp.trace) && this.cloneToBackground(true), this) : this;
  }, updateTransform: function(t2) {
    var e2, s2;
    if (0 === this.transformations.length || null === this.baseElement)
      return this;
    for (this === this.baseElement ? (e2 = this.transformations[0].apply(this.baseElement, "self"), this.coords.setCoordinates(i2.Z.COORDS_BY_USER, e2)) : e2 = this.transformations[0].apply(this.baseElement), this.coords.setCoordinates(i2.Z.COORDS_BY_USER, e2), s2 = 1; s2 < this.transformations.length; s2++)
      this.coords.setCoordinates(i2.Z.COORDS_BY_USER, this.transformations[s2].apply(this));
    return this;
  }, updateRenderer: function() {
    return this.updateRendererGeneric("updatePoint"), this;
  }, bounds: function() {
    return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));
  }, makeIntersection: function(t2, e2, s2, r3) {
    var o2;
    t2 = this.board.select(t2), e2 = this.board.select(e2), o2 = u.Z.intersectionFunction(this.board, t2, e2, s2, r3, this.visProp.alwaysintersect), this.addConstraint([o2]);
    try {
      t2.addChild(this), e2.addChild(this);
    } catch (i3) {
      throw new Error("JSXGraph: Can't create 'intersection' with parent types '" + typeof t2 + "' and '" + typeof e2 + "'.");
    }
    this.type = i2.Z.OBJECT_TYPE_INTERSECTION, this.elType = "intersection", this.parents = [t2.id, e2.id, s2, r3], this.generatePolynomial = function() {
      var i3 = t2.generatePolynomial(this), s3 = e2.generatePolynomial(this);
      return 0 === i3.length || 0 === s3.length ? [] : [i3[0], s3[0]];
    }, this.prepareUpdate().update();
  }, setStyle: function(t2) {
    return this.visProp.face = ["cross", "cross", "cross", "circle", "circle", "circle", "circle", "square", "square", "square", "plus", "plus", "plus"][t2], this.visProp.size = [2, 3, 4, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4][t2], this.board.renderer.changePointStyle(this), this;
  }, normalizeFace: function(e2) {
    return t.Z.deprecated("Point.normalizeFace()", "JXG.normalizePointFace()"), M.Z.normalizePointFace(e2);
  }, face: function(e2) {
    t.Z.deprecated("Point.face()", "Point.setAttribute()"), this.setAttribute({ face: e2 });
  }, size: function(e2) {
    t.Z.deprecated("Point.size()", "Point.setAttribute()"), this.setAttribute({ size: e2 });
  }, isOn: function(e2, r3) {
    var n2, a2;
    return r3 = r3 || o.Z.eps, s.Z.isPoint(e2) ? this.Dist(e2) < r3 : e2.elementClass === i2.Z.OBJECT_CLASS_LINE ? ("segment" !== e2.elType || s.Z.evaluate(this.visProp.alwaysintersect) || (n2 = t.Z.Math.Geometry.projectCoordsToSegment(this.coords.usrCoords, e2.point1.coords.usrCoords, e2.point2.coords.usrCoords))[1] >= 0 && n2[1] <= 1) && u.Z.distPointLine(this.coords.usrCoords, e2.stdform) < r3 : e2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE ? s.Z.evaluate(e2.visProp.hasinnerpoints) ? this.Dist(e2.center) < e2.Radius() + r3 : Math.abs(this.Dist(e2.center) - e2.Radius()) < r3 : e2.elementClass === i2.Z.OBJECT_CLASS_CURVE ? (a2 = u.Z.projectPointToCurve(this, e2, this.board)[0], u.Z.distance(this.coords.usrCoords, a2.usrCoords, 3) < r3) : e2.type === i2.Z.OBJECT_TYPE_POLYGON ? !(!s.Z.evaluate(e2.visProp.hasinnerpoints) || !e2.pnpoly(this.coords.usrCoords[1], this.coords.usrCoords[2], t.Z.COORDS_BY_USER)) || (n2 = u.Z.projectCoordsToPolygon(this.coords.usrCoords, e2), u.Z.distance(this.coords.usrCoords, n2, 3) < r3) : e2.type === i2.Z.OBJECT_TYPE_TURTLE && (a2 = u.Z.projectPointToTurtle(this, e2, this.board), u.Z.distance(this.coords.usrCoords, a2.usrCoords, 3) < r3);
  }, cloneToBackground: function() {
    var t2 = {};
    return t2.id = this.id + "T" + this.numTraces, this.numTraces += 1, t2.coords = this.coords, t2.visProp = s.Z.deepCopy(this.visProp, this.visProp.traceattributes, true), t2.visProp.layer = this.board.options.layer.trace, t2.elementClass = i2.Z.OBJECT_CLASS_POINT, t2.board = this.board, s.Z.clearVisPropOld(t2), t2.visPropCalc = { visible: s.Z.evaluate(t2.visProp.visible) }, this.board.renderer.drawPoint(t2), this.traces[t2.id] = t2.rendNode, this;
  } }), t.Z.createPoint = function(e2, i3, r3) {
    var o2, n2;
    if (n2 = s.Z.copyAttributes(r3, e2.options, "point"), !(o2 = G.Z.create(t.Z.Point, e2, i3, n2)))
      throw new Error("JSXGraph: Can't create point with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
    return o2;
  }, t.Z.createGlider = function(t2, e2, i3) {
    var r3, o2, n2 = s.Z.copyAttributes(i3, t2.options, "glider");
    return o2 = 1 === e2.length ? [0, 0] : e2.slice(0, 2), (r3 = t2.create("point", o2, n2)).makeGlider(e2[e2.length - 1]), r3;
  }, t.Z.createIntersectionPoint = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, c2, d2 = s.Z.copyAttributes(r3, t2.options, "intersection");
    e2.push(0, 0), n2 = t2.select(e2[0]), a2 = t2.select(e2[1]), l2 = e2[2] || 0, c2 = e2[3] || 0, o2 = t2.create("point", [0, 0, 0], d2), h2 = u.Z.intersectionFunction(t2, n2, a2, l2, c2, o2.visProp.alwaysintersect), o2.addConstraint([h2]);
    try {
      n2.addChild(o2), a2.addChild(o2);
    } catch (t3) {
      throw new Error("JSXGraph: Can't create 'intersection' with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.");
    }
    return o2.type = i2.Z.OBJECT_TYPE_INTERSECTION, o2.elType = "intersection", o2.setParents([n2.id, a2.id]), o2.intersectionNumbers = [l2, c2], o2.getParents = function() {
      return this.parents.concat(this.intersectionNumbers);
    }, o2.generatePolynomial = function() {
      var t3 = n2.generatePolynomial(o2), e3 = a2.generatePolynomial(o2);
      return 0 === t3.length || 0 === e3.length ? [] : [t3[0], e3[0]];
    }, o2;
  }, t.Z.createOtherIntersectionPoint = function(t2, e2, r3) {
    var n2, a2, h2, l2;
    if (3 !== e2.length || !s.Z.isPoint(e2[2]) || e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE && e2[0].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE || e2[1].elementClass !== i2.Z.OBJECT_CLASS_LINE && e2[1].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
      throw new Error("JSXGraph: Can't create 'other intersection point' with parent types '" + typeof e2[0] + "',  '" + typeof e2[1] + "'and  '" + typeof e2[2] + "'.\nPossible parent types: [circle|line,circle|line,point]");
    return a2 = t2.select(e2[0]), h2 = t2.select(e2[1]), l2 = t2.select(e2[2]), (n2 = t2.create("point", [function() {
      var t3 = u.Z.meet(a2.stdform, h2.stdform, 0, a2.board);
      return Math.abs(l2.X() - t3.usrCoords[1]) > o.Z.eps || Math.abs(l2.Y() - t3.usrCoords[2]) > o.Z.eps || Math.abs(l2.Z() - t3.usrCoords[0]) > o.Z.eps ? t3 : u.Z.meet(a2.stdform, h2.stdform, 1, a2.board);
    }], r3)).type = i2.Z.OBJECT_TYPE_INTERSECTION, n2.elType = "otherintersection", n2.setParents([a2.id, h2.id, l2]), a2.addChild(n2), h2.addChild(n2), n2.generatePolynomial = function() {
      var t3 = a2.generatePolynomial(n2), e3 = h2.generatePolynomial(n2);
      return 0 === t3.length || 0 === e3.length ? [] : [t3[0], e3[0]];
    }, n2;
  }, t.Z.createPolePoint = function(e2, s2, r3) {
    var o2, n2, a2, h2, l2, c2, d2;
    if (s2.length > 1 && (h2 = s2[0].type === i2.Z.OBJECT_TYPE_CONIC || s2[0].elementClass === i2.Z.OBJECT_CLASS_CIRCLE, l2 = s2[1].type === i2.Z.OBJECT_TYPE_CONIC || s2[1].elementClass === i2.Z.OBJECT_CLASS_CIRCLE, c2 = s2[0].elementClass === i2.Z.OBJECT_CLASS_LINE, d2 = s2[1].elementClass === i2.Z.OBJECT_CLASS_LINE), 2 !== s2.length || !(h2 && d2 || c2 && l2))
      throw new Error("JSXGraph: Can't create 'pole point' with parent types '" + typeof s2[0] + "' and '" + typeof s2[1] + "'.\nPossible parent type: [conic|circle,line], [line,conic|circle]");
    return d2 ? (n2 = e2.select(s2[0]), a2 = e2.select(s2[1])) : (n2 = e2.select(s2[1]), a2 = e2.select(s2[0])), (o2 = e2.create("point", [function() {
      var e3 = n2.quadraticform, i3 = a2.stdform.slice(0, 3);
      return [t.Z.Math.Numerics.det([i3, e3[1], e3[2]]), t.Z.Math.Numerics.det([e3[0], i3, e3[2]]), t.Z.Math.Numerics.det([e3[0], e3[1], i3])];
    }], r3)).elType = "polepoint", o2.setParents([n2.id, a2.id]), n2.addChild(o2), a2.addChild(o2), o2;
  }, t.Z.registerElement("point", t.Z.createPoint), t.Z.registerElement("glider", t.Z.createGlider), t.Z.registerElement("intersection", t.Z.createIntersectionPoint), t.Z.registerElement("otherintersection", t.Z.createOtherIntersectionPoint), t.Z.registerElement("polepoint", t.Z.createPolePoint);
  const z = t.Z.Point;
  t.Z.Line = function(e2, s2, r3, o2) {
    this.constructor(e2, o2, i2.Z.OBJECT_TYPE_LINE, i2.Z.OBJECT_CLASS_LINE), this.point1 = this.board.select(s2), this.point2 = this.board.select(r3), this.ticks = [], this.defaultTicks = null, this.parentPolygon = null, this.id = this.board.setId(this, "L"), this.board.renderer.drawLine(this), this.board.finalizeAdding(this), this.elType = "line", this.point1._is_new ? (this.addChild(this.point1), delete this.point1._is_new) : this.point1.addChild(this), this.point2._is_new ? (this.addChild(this.point2), delete this.point2._is_new) : this.point2.addChild(this), this.inherits.push(this.point1, this.point2), this.updateStdform(), this.createLabel(), this.methodMap = t.Z.deepCopy(this.methodMap, { point1: "point1", point2: "point2", getSlope: "getSlope", getRise: "getRise", getYIntersect: "getRise", getAngle: "getAngle", L: "L", length: "L" });
  }, t.Z.Line.prototype = new J.Z(), t.Z.extend(t.Z.Line.prototype, { hasPoint: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, p2, _2, f2, b2 = [], g2 = [1, t2, e2], m2 = s.Z.evaluate(this.visProp.strokewidth);
    return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (f2 = this.board._inputDevice, _2 = s.Z.evaluate(this.visProp.precision[f2])) : _2 = this.board.options.precision.hasPoint, _2 += 0.5 * m2, b2[0] = this.stdform[0] - this.stdform[1] * this.board.origin.scrCoords[1] / this.board.unitX + this.stdform[2] * this.board.origin.scrCoords[2] / this.board.unitY, b2[1] = this.stdform[1] / this.board.unitX, b2[2] = this.stdform[2] / -this.board.unitY, r3 = u.Z.distPointLine(g2, b2), !(isNaN(r3) || r3 > _2) && (!(!s.Z.evaluate(this.visProp.straightfirst) || !s.Z.evaluate(this.visProp.straightlast)) || (a2 = this.point1.coords, h2 = this.point2.coords, n2 = [0, b2[1], b2[2]], n2 = o.Z.crossProduct(n2, g2), (n2 = o.Z.crossProduct(n2, b2))[1] /= n2[0], n2[2] /= n2[0], n2[0] = 1, n2 = new c.Z(i2.Z.COORDS_BY_SCREEN, n2.slice(1), this.board).usrCoords, l2 = a2.distance(i2.Z.COORDS_BY_USER, h2), a2 = a2.usrCoords.slice(0), h2 = h2.usrCoords.slice(0), l2 < o.Z.eps ? d2 = 0 : (l2 === Number.POSITIVE_INFINITY && (l2 = 1 / o.Z.eps, Math.abs(h2[0]) < o.Z.eps ? (l2 /= u.Z.distance([0, 0, 0], h2), h2 = [1, a2[1] + h2[1] * l2, a2[2] + h2[2] * l2]) : (l2 /= u.Z.distance([0, 0, 0], a2), a2 = [1, h2[1] + a2[1] * l2, h2[2] + a2[2] * l2])), l2 = h2[p2 = 1] - a2[p2], Math.abs(l2) < o.Z.eps && (l2 = h2[p2 = 2] - a2[p2]), d2 = (n2[p2] - a2[p2]) / l2), !(!s.Z.evaluate(this.visProp.straightfirst) && d2 < 0) && !(!s.Z.evaluate(this.visProp.straightlast) && d2 > 1)));
  }, update: function() {
    var t2;
    return this.needsUpdate ? (this.constrained && (s.Z.isFunction(this.funps) ? (t2 = this.funps()) && t2.length && 2 === t2.length && (this.point1 = t2[0], this.point2 = t2[1]) : (s.Z.isFunction(this.funp1) && (t2 = this.funp1(), s.Z.isPoint(t2) ? this.point1 = t2 : t2 && t2.length && 2 === t2.length && this.point1.setPositionDirectly(i2.Z.COORDS_BY_USER, t2)), s.Z.isFunction(this.funp2) && (t2 = this.funp2(), s.Z.isPoint(t2) ? this.point2 = t2 : t2 && t2.length && 2 === t2.length && this.point2.setPositionDirectly(i2.Z.COORDS_BY_USER, t2)))), this.updateSegmentFixedLength(), this.updateStdform(), s.Z.evaluate(this.visProp.trace) && this.cloneToBackground(true), this) : this;
  }, updateSegmentFixedLength: function() {
    var t2, e2, r3, n2, a2, h2, l2, c2;
    return this.hasFixedLength ? (t2 = this.point1.Dist(this.point2), e2 = this.fixedLength(), r3 = this.fixedLengthOldCoords[0].distance(i2.Z.COORDS_BY_USER, this.point1.coords), n2 = this.fixedLengthOldCoords[1].distance(i2.Z.COORDS_BY_USER, this.point2.coords), (r3 > o.Z.eps || n2 > o.Z.eps || t2 !== e2) && (a2 = this.point1.isDraggable && this.point1.type !== i2.Z.OBJECT_TYPE_GLIDER && !s.Z.evaluate(this.point1.visProp.fixed), h2 = this.point2.isDraggable && this.point2.type !== i2.Z.OBJECT_TYPE_GLIDER && !s.Z.evaluate(this.point2.visProp.fixed), t2 > o.Z.eps ? r3 > n2 && h2 || r3 <= n2 && h2 && !a2 ? (this.point2.setPositionDirectly(i2.Z.COORDS_BY_USER, [this.point1.X() + (this.point2.X() - this.point1.X()) * e2 / t2, this.point1.Y() + (this.point2.Y() - this.point1.Y()) * e2 / t2]), this.point2.fullUpdate()) : (r3 <= n2 && a2 || r3 > n2 && a2 && !h2) && (this.point1.setPositionDirectly(i2.Z.COORDS_BY_USER, [this.point2.X() + (this.point1.X() - this.point2.X()) * e2 / t2, this.point2.Y() + (this.point1.Y() - this.point2.Y()) * e2 / t2]), this.point1.fullUpdate()) : (l2 = Math.random() - 0.5, c2 = Math.random() - 0.5, t2 = Math.sqrt(l2 * l2 + c2 * c2), h2 ? (this.point2.setPositionDirectly(i2.Z.COORDS_BY_USER, [this.point1.X() + l2 * e2 / t2, this.point1.Y() + c2 * e2 / t2]), this.point2.fullUpdate()) : a2 && (this.point1.setPositionDirectly(i2.Z.COORDS_BY_USER, [this.point2.X() + l2 * e2 / t2, this.point2.Y() + c2 * e2 / t2]), this.point1.fullUpdate())), this.fixedLengthOldCoords[0].setCoordinates(i2.Z.COORDS_BY_USER, this.point1.coords.usrCoords), this.fixedLengthOldCoords[1].setCoordinates(i2.Z.COORDS_BY_USER, this.point2.coords.usrCoords)), this) : this;
  }, updateStdform: function() {
    var t2 = o.Z.crossProduct(this.point1.coords.usrCoords, this.point2.coords.usrCoords);
    this.stdform[0] = t2[0], this.stdform[1] = t2[1], this.stdform[2] = t2[2], this.stdform[3] = 0, this.normalize();
  }, updateRenderer: function() {
    return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.point1.coords.usrCoords[1] + this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[1] + this.point2.coords.usrCoords[2]) && o.Z.innerProduct(this.stdform, this.stdform, 3) >= o.Z.eps * o.Z.eps, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateLine(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
  }, generatePolynomial: function(t2) {
    var e2 = this.point1.symbolic.x, i3 = this.point1.symbolic.y, s2 = this.point2.symbolic.x, r3 = this.point2.symbolic.y, o2 = t2.symbolic.x, n2 = t2.symbolic.y;
    return [["(", i3, ")*(", o2, ")-(", i3, ")*(", s2, ")+(", n2, ")*(", s2, ")-(", e2, ")*(", n2, ")+(", e2, ")*(", r3, ")-(", o2, ")*(", r3, ")"].join("")];
  }, getRise: function() {
    return Math.abs(this.stdform[2]) >= o.Z.eps ? -this.stdform[0] / this.stdform[2] : 1 / 0;
  }, getSlope: function() {
    return Math.abs(this.stdform[2]) >= o.Z.eps ? -this.stdform[1] / this.stdform[2] : 1 / 0;
  }, getAngle: function() {
    return Math.atan2(-this.stdform[1], this.stdform[2]);
  }, setStraight: function(t2, e2) {
    return this.visProp.straightfirst = t2, this.visProp.straightlast = e2, this.board.renderer.updateLine(this), this;
  }, getTextAnchor: function() {
    return new c.Z(i2.Z.COORDS_BY_USER, [0.5 * (this.point2.X() + this.point1.X()), 0.5 * (this.point2.Y() + this.point1.Y())], this.board);
  }, setLabelRelativeCoords: function(t2) {
    s.Z.exists(this.label) && (this.label.relativeCoords = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2[0], -t2[1]], this.board));
  }, getLabelAnchor: function() {
    var t2, e2, r3 = 0, n2 = new c.Z(i2.Z.COORDS_BY_USER, this.point1.coords.usrCoords, this.board), a2 = new c.Z(i2.Z.COORDS_BY_USER, this.point2.coords.usrCoords, this.board), h2 = s.Z.evaluate(this.visProp.straightfirst), l2 = s.Z.evaluate(this.visProp.straightlast);
    if ((h2 || l2) && u.Z.calcStraight(this, n2, a2, 0), n2 = n2.scrCoords, a2 = a2.scrCoords, !s.Z.exists(this.label))
      return new c.Z(i2.Z.COORDS_BY_SCREEN, [NaN, NaN], this.board);
    switch (s.Z.evaluate(this.label.visProp.position)) {
      case "last":
        t2 = a2[1], e2 = a2[2];
        break;
      case "first":
        t2 = n2[1], e2 = n2[2];
        break;
      case "lft":
      case "llft":
      case "ulft":
        n2[1] <= a2[1] ? (t2 = n2[1], e2 = n2[2]) : (t2 = a2[1], e2 = a2[2]);
        break;
      case "rt":
      case "lrt":
      case "urt":
        n2[1] > a2[1] ? (t2 = n2[1], e2 = n2[2]) : (t2 = a2[1], e2 = a2[2]);
        break;
      default:
        t2 = 0.5 * (n2[1] + a2[1]), e2 = 0.5 * (n2[2] + a2[2]);
    }
    return (h2 || l2) && (s.Z.exists(this.label) && (r3 = s.Z.evaluate(this.label.visProp.fontsize)), Math.abs(t2) < o.Z.eps ? t2 = r3 : this.board.canvasWidth + o.Z.eps > t2 && t2 > this.board.canvasWidth - r3 - o.Z.eps && (t2 = this.board.canvasWidth - r3), o.Z.eps + r3 > e2 && e2 > -o.Z.eps ? e2 = r3 : this.board.canvasHeight + o.Z.eps > e2 && e2 > this.board.canvasHeight - r3 - o.Z.eps && (e2 = this.board.canvasHeight - r3)), new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e2], this.board);
  }, cloneToBackground: function() {
    var t2, e2, r3, o2 = {};
    return o2.id = this.id + "T" + this.numTraces, o2.elementClass = i2.Z.OBJECT_CLASS_LINE, this.numTraces++, o2.point1 = this.point1, o2.point2 = this.point2, o2.stdform = this.stdform, o2.board = this.board, o2.visProp = s.Z.deepCopy(this.visProp, this.visProp.traceattributes, true), o2.visProp.layer = this.board.options.layer.trace, s.Z.clearVisPropOld(o2), o2.visPropCalc = { visible: s.Z.evaluate(o2.visProp.visible) }, e2 = this.getSlope(), t2 = this.getRise(), o2.getSlope = function() {
      return e2;
    }, o2.getRise = function() {
      return t2;
    }, r3 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawLine(o2), this.board.renderer.enhancedRendering = r3, this.traces[o2.id] = o2.rendNode, this;
  }, addTransform: function(t2) {
    var e2, i3 = s.Z.isArray(t2) ? t2 : [t2], r3 = i3.length;
    for (e2 = 0; e2 < r3; e2++)
      this.point1.transformations.push(i3[e2]), this.point2.transformations.push(i3[e2]);
    return this;
  }, snapToGrid: function(t2) {
    var e2, r3, o2, n2, a2, h2, l2, p2;
    return s.Z.evaluate(this.visProp.snaptogrid) ? this.parents.length < 3 ? (this.point1.handleSnapToGrid(true, true), this.point2.handleSnapToGrid(true, true)) : s.Z.exists(t2) && (l2 = s.Z.evaluate(this.visProp.snapsizex), p2 = s.Z.evaluate(this.visProp.snapsizey), a2 = (e2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2.Xprev, t2.Yprev], this.board)).usrCoords[1], h2 = e2.usrCoords[2], l2 <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks && (l2 = (n2 = this.board.defaultAxes.x.defaultTicks).ticksDelta * (s.Z.evaluate(n2.visProp.minorticks) + 1)), p2 <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks && (p2 = (n2 = this.board.defaultAxes.y.defaultTicks).ticksDelta * (s.Z.evaluate(n2.visProp.minorticks) + 1)), l2 > 0 && p2 > 0 && (r3 = u.Z.projectPointToLine({ coords: e2 }, this, this.board), o2 = d.Z.subtract([1, Math.round(a2 / l2) * l2, Math.round(h2 / p2) * p2], r3.usrCoords), this.board.create("transform", o2.slice(1), { type: "translate" }).applyOnce([this.point1, this.point2]))) : (this.point1.handleSnapToGrid(false, true), this.point2.handleSnapToGrid(false, true)), this;
  }, snapToPoints: function() {
    var t2 = s.Z.evaluate(this.visProp.snaptopoints);
    return this.parents.length < 3 && (this.point1.handleSnapToPoints(t2), this.point2.handleSnapToPoints(t2)), this;
  }, X: function(t2) {
    var e2, i3 = this.stdform[2];
    return e2 = Math.abs(this.point1.coords.usrCoords[0]) > o.Z.eps ? this.point1.coords.usrCoords[1] : this.point2.coords.usrCoords[1], t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * e2 - t2 * i3;
  }, Y: function(t2) {
    var e2, i3 = this.stdform[1];
    return e2 = Math.abs(this.point1.coords.usrCoords[0]) > o.Z.eps ? this.point1.coords.usrCoords[2] : this.point2.coords.usrCoords[2], t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * e2 + t2 * i3;
  }, Z: function(t2) {
    var e2 = Math.abs(this.point1.coords.usrCoords[0]) > o.Z.eps ? this.point1.coords.usrCoords[0] : this.point2.coords.usrCoords[0];
    return t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * e2;
  }, L: function() {
    return this.point1.Dist(this.point2);
  }, minX: function() {
    return 0;
  }, maxX: function() {
    return 1;
  }, bounds: function() {
    var t2 = this.point1.coords.usrCoords, e2 = this.point2.coords.usrCoords;
    return [Math.min(t2[1], e2[1]), Math.max(t2[2], e2[2]), Math.max(t2[1], e2[1]), Math.min(t2[2], e2[2])];
  }, remove: function() {
    this.removeAllTicks(), J.Z.prototype.remove.call(this);
  } }), t.Z.createLine = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2 = [], p2 = false, _2 = false;
    if (2 === i3.length) {
      if (s.Z.isArray(i3[0]) && i3[0].length > 1)
        c2 = s.Z.copyAttributes(r3, e2.options, "line", "point1"), a2 = e2.create("point", i3[0], c2);
      else if (s.Z.isString(i3[0]) || s.Z.isPoint(i3[0]))
        a2 = e2.select(i3[0]);
      else if (s.Z.isFunction(i3[0]) && s.Z.isPoint(i3[0]()))
        a2 = i3[0](), _2 = true;
      else if (s.Z.isFunction(i3[0]) && i3[0]().length && i3[0]().length >= 2)
        c2 = s.Z.copyAttributes(r3, e2.options, "line", "point1"), a2 = t.Z.createPoint(e2, i3[0](), c2), _2 = true;
      else {
        if (!s.Z.isObject(i3[0]) || !s.Z.isTransformationOrArray(i3[1]))
          throw new Error("JSXGraph: Can't create line with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
        p2 = true, c2 = s.Z.copyAttributes(r3, e2.options, "line", "point1"), a2 = e2.create("point", [i3[0].point1, i3[1]], c2);
      }
      if (p2)
        c2 = s.Z.copyAttributes(r3, e2.options, "line", "point2"), h2 = e2.create("point", [i3[0].point2, i3[1]], c2);
      else if (s.Z.isArray(i3[1]) && i3[1].length > 1)
        c2 = s.Z.copyAttributes(r3, e2.options, "line", "point2"), h2 = e2.create("point", i3[1], c2);
      else if (s.Z.isString(i3[1]) || s.Z.isPoint(i3[1]))
        h2 = e2.select(i3[1]);
      else if (s.Z.isFunction(i3[1]) && s.Z.isPoint(i3[1]()))
        h2 = i3[1](), _2 = true;
      else {
        if (!(s.Z.isFunction(i3[1]) && i3[1]().length && i3[1]().length >= 2))
          throw new Error("JSXGraph: Can't create line with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
        c2 = s.Z.copyAttributes(r3, e2.options, "line", "point2"), h2 = t.Z.createPoint(e2, i3[1](), c2), _2 = true;
      }
      c2 = s.Z.copyAttributes(r3, e2.options, "line"), n2 = new t.Z.Line(e2, a2, h2, c2), _2 ? (n2.constrained = true, n2.funp1 = i3[0], n2.funp2 = i3[1]) : p2 || (n2.isDraggable = true), n2.setParents([a2.id, h2.id]);
    } else if (3 === i3.length) {
      for (d2 = true, l2 = 0; l2 < 3; l2++)
        if (s.Z.isNumber(i3[l2]))
          u2[l2] = s.Z.createFunction(i3[l2]);
        else {
          if (!s.Z.isFunction(i3[l2]))
            throw new Error("JSXGraph: Can't create line with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
          u2[l2] = i3[l2], d2 = false;
        }
      c2 = s.Z.copyAttributes(r3, e2.options, "line", "point1"), a2 = d2 ? e2.create("point", [u2[2]() * u2[2]() + u2[1]() * u2[1](), u2[2]() - u2[1]() * u2[0]() + u2[2](), -u2[1]() - u2[2]() * u2[0]() - u2[1]()], c2) : e2.create("point", [function() {
        return 0.5 * (u2[2]() * u2[2]() + u2[1]() * u2[1]());
      }, function() {
        return 0.5 * (u2[2]() - u2[1]() * u2[0]() + u2[2]());
      }, function() {
        return 0.5 * (-u2[1]() - u2[2]() * u2[0]() - u2[1]());
      }], c2), c2 = s.Z.copyAttributes(r3, e2.options, "line", "point2"), h2 = d2 ? e2.create("point", [u2[2]() * u2[2]() + u2[1]() * u2[1](), -u2[1]() * u2[0]() + u2[2](), -u2[2]() * u2[0]() - u2[1]()], c2) : e2.create("point", [function() {
        return u2[2]() * u2[2]() + u2[1]() * u2[1]();
      }, function() {
        return -u2[1]() * u2[0]() + u2[2]();
      }, function() {
        return -u2[2]() * u2[0]() - u2[1]();
      }], c2), a2.prepareUpdate().update(), h2.prepareUpdate().update(), c2 = s.Z.copyAttributes(r3, e2.options, "line"), (n2 = new t.Z.Line(e2, a2, h2, c2)).isDraggable = d2, n2.setParents([a2, h2]);
    } else if (1 === i3.length && s.Z.isFunction(i3[0]) && 2 === i3[0]().length && s.Z.isPoint(i3[0]()[0]) && s.Z.isPoint(i3[0]()[1]))
      o2 = i3[0](), c2 = s.Z.copyAttributes(r3, e2.options, "line"), (n2 = new t.Z.Line(e2, o2[0], o2[1], c2)).constrained = true, n2.funps = i3[0], n2.setParents(o2);
    else {
      if (!(1 === i3.length && s.Z.isFunction(i3[0]) && 3 === i3[0]().length && s.Z.isNumber(i3[0]()[0]) && s.Z.isNumber(i3[0]()[1]) && s.Z.isNumber(i3[0]()[2])))
        throw new Error("JSXGraph: Can't create line with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
      o2 = i3[0], c2 = s.Z.copyAttributes(r3, e2.options, "line", "point1"), a2 = e2.create("point", [function() {
        var t2 = o2();
        return [0.5 * (t2[2] * t2[2] + t2[1] * t2[1]), 0.5 * (t2[2] - t2[1] * t2[0] + t2[2]), 0.5 * (-t2[1] - t2[2] * t2[0] - t2[1])];
      }], c2), c2 = s.Z.copyAttributes(r3, e2.options, "line", "point2"), h2 = e2.create("point", [function() {
        var t2 = o2();
        return [t2[2] * t2[2] + t2[1] * t2[1], -t2[1] * t2[0] + t2[2], -t2[2] * t2[0] - t2[1]];
      }], c2), c2 = s.Z.copyAttributes(r3, e2.options, "line"), (n2 = new t.Z.Line(e2, a2, h2, c2)).constrained = true, n2.funps = i3[0], n2.setParents([a2, h2]);
    }
    return n2;
  }, t.Z.registerElement("line", t.Z.createLine), t.Z.createSegment = function(t2, e2, r3) {
    var o2, n2;
    if (r3.straightFirst = false, r3.straightLast = false, n2 = s.Z.copyAttributes(r3, t2.options, "segment"), o2 = t2.create("line", e2.slice(0, 2), n2), 3 === e2.length) {
      if (o2.hasFixedLength = true, s.Z.isNumber(e2[2]))
        o2.fixedLength = function() {
          return e2[2];
        };
      else {
        if (!s.Z.isFunction(e2[2]))
          throw new Error("JSXGraph: Can't create segment with third parent type '" + typeof e2[2] + "'.\nPossible third parent types: number or function");
        o2.fixedLength = e2[2];
      }
      o2.getParents = function() {
        return this.parents.concat(this.fixedLength());
      }, o2.fixedLengthOldCoords = [], o2.fixedLengthOldCoords[0] = new c.Z(i2.Z.COORDS_BY_USER, o2.point1.coords.usrCoords.slice(1, 3), t2), o2.fixedLengthOldCoords[1] = new c.Z(i2.Z.COORDS_BY_USER, o2.point2.coords.usrCoords.slice(1, 3), t2);
    }
    return o2.elType = "segment", o2;
  }, t.Z.registerElement("segment", t.Z.createSegment), t.Z.createArrow = function(t2, e2, r3) {
    var o2, n2;
    return r3.straightFirst = false, r3.straightLast = false, n2 = s.Z.copyAttributes(r3, t2.options, "arrow"), (o2 = t2.create("line", e2, n2)).type = i2.Z.OBJECT_TYPE_VECTOR, o2.elType = "arrow", o2;
  }, t.Z.registerElement("arrow", t.Z.createArrow), t.Z.createAxis = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2;
    if (!s.Z.isArray(e2[0]) && !s.Z.isPoint(e2[0]) || !s.Z.isArray(e2[1]) && !s.Z.isPoint(e2[1]))
      throw new Error("JSXGraph: Can't create axis with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
    for (h2 in o2 = s.Z.copyAttributes(r3, t2.options, "axis"), (a2 = t2.create("line", e2, o2)).type = i2.Z.OBJECT_TYPE_AXIS, a2.isDraggable = false, a2.point1.isDraggable = false, a2.point2.isDraggable = false, a2.ancestors)
      a2.ancestors.hasOwnProperty(h2) && (a2.ancestors[h2].type = i2.Z.OBJECT_TYPE_AXISPOINT);
    return n2 = s.Z.copyAttributes(r3, t2.options, "axis", "ticks"), l2 = s.Z.exists(n2.ticksdistance) ? n2.ticksdistance : s.Z.isArray(n2.ticks) ? n2.ticks : 1, a2.defaultTicks = t2.create("ticks", [a2, l2], n2), a2.defaultTicks.dump = false, a2.elType = "axis", a2.subs = { ticks: a2.defaultTicks }, a2.inherits.push(a2.defaultTicks), a2;
  }, t.Z.registerElement("axis", t.Z.createAxis), t.Z.createTangent = function(t2, e2, r3) {
    var n2, a2, h2, c2, d2;
    if (1 === e2.length)
      n2 = e2[0], a2 = n2.slideObject;
    else {
      if (2 !== e2.length)
        throw new Error("JSXGraph: Can't create tangent with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]");
      if (s.Z.isPoint(e2[0]))
        n2 = e2[0], a2 = e2[1];
      else {
        if (!s.Z.isPoint(e2[1]))
          throw new Error("JSXGraph: Can't create tangent with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]");
        a2 = e2[0], n2 = e2[1];
      }
    }
    if (a2.elementClass === i2.Z.OBJECT_CLASS_LINE ? (d2 = t2.create("line", [a2.point1, a2.point2], r3)).glider = n2 : a2.elementClass === i2.Z.OBJECT_CLASS_CURVE && a2.type !== i2.Z.OBJECT_TYPE_CONIC ? "plot" !== s.Z.evaluate(a2.visProp.curvetype) ? (d2 = t2.create("line", [function() {
      var t3 = a2.X, e3 = a2.Y;
      return -n2.X() * l.Z.D(e3)(n2.position) + n2.Y() * l.Z.D(t3)(n2.position);
    }, function() {
      return l.Z.D(a2.Y)(n2.position);
    }, function() {
      return -l.Z.D(a2.X)(n2.position);
    }], r3), n2.addChild(d2), d2.glider = n2) : (d2 = t2.create("line", [function() {
      var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3, u2 = Math.floor(n2.position);
      if (1 === a2.bezierDegree)
        u2 === a2.numberPoints - 1 && u2--;
      else {
        if (3 !== a2.bezierDegree)
          return 0;
        u2 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), i3 = (n2.position * (a2.numberPoints - 1) - u2) / 3, u2 >= a2.numberPoints - 1 && (u2 = a2.numberPoints - 4, i3 = 1);
      }
      return u2 < 0 ? 1 : (1 === a2.bezierDegree ? (t3 = a2.points[u2].usrCoords, e3 = a2.points[u2 + 1].usrCoords) : (s2 = a2.points[u2].usrCoords, r4 = a2.points[u2 + 1].usrCoords, o2 = a2.points[u2 + 2].usrCoords, h3 = a2.points[u2 + 3].usrCoords, l2 = (1 - i3) * (1 - i3) * (r4[1] - s2[1]) + 2 * (1 - i3) * i3 * (o2[1] - r4[1]) + i3 * i3 * (h3[1] - o2[1]), c3 = (1 - i3) * (1 - i3) * (r4[2] - s2[2]) + 2 * (1 - i3) * i3 * (o2[2] - r4[2]) + i3 * i3 * (h3[2] - o2[2]), l2 /= d3 = Math.sqrt(l2 * l2 + c3 * c3), c3 /= d3, e3 = [1, (t3 = n2.coords.usrCoords)[1] + l2, t3[2] + c3]), t3[2] * e3[1] - t3[1] * e3[2]);
    }, function() {
      var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3, u2 = Math.floor(n2.position);
      if (1 === a2.bezierDegree)
        u2 === a2.numberPoints - 1 && u2--;
      else {
        if (3 !== a2.bezierDegree)
          return 0;
        u2 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), i3 = (n2.position * (a2.numberPoints - 1) - u2) / 3, u2 >= a2.numberPoints - 1 && (u2 = a2.numberPoints - 4, i3 = 1);
      }
      return u2 < 0 ? 0 : (1 === a2.bezierDegree ? (t3 = a2.points[u2].usrCoords, e3 = a2.points[u2 + 1].usrCoords) : (s2 = a2.points[u2].usrCoords, r4 = a2.points[u2 + 1].usrCoords, o2 = a2.points[u2 + 2].usrCoords, h3 = a2.points[u2 + 3].usrCoords, l2 = (1 - i3) * (1 - i3) * (r4[1] - s2[1]) + 2 * (1 - i3) * i3 * (o2[1] - r4[1]) + i3 * i3 * (h3[1] - o2[1]), c3 = (1 - i3) * (1 - i3) * (r4[2] - s2[2]) + 2 * (1 - i3) * i3 * (o2[2] - r4[2]) + i3 * i3 * (h3[2] - o2[2]), l2 /= d3 = Math.sqrt(l2 * l2 + c3 * c3), c3 /= d3, e3 = [1, (t3 = n2.coords.usrCoords)[1] + l2, t3[2] + c3]), e3[2] - t3[2]);
    }, function() {
      var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3, u2 = Math.floor(n2.position);
      if (1 === a2.bezierDegree)
        u2 === a2.numberPoints - 1 && u2--;
      else {
        if (3 !== a2.bezierDegree)
          return 0;
        u2 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), i3 = (n2.position * (a2.numberPoints - 1) - u2) / 3, u2 >= a2.numberPoints - 1 && (u2 = a2.numberPoints - 4, i3 = 1);
      }
      return u2 < 0 ? 0 : (1 === a2.bezierDegree ? (t3 = a2.points[u2].usrCoords, e3 = a2.points[u2 + 1].usrCoords) : (s2 = a2.points[u2].usrCoords, r4 = a2.points[u2 + 1].usrCoords, o2 = a2.points[u2 + 2].usrCoords, h3 = a2.points[u2 + 3].usrCoords, l2 = (1 - i3) * (1 - i3) * (r4[1] - s2[1]) + 2 * (1 - i3) * i3 * (o2[1] - r4[1]) + i3 * i3 * (h3[1] - o2[1]), c3 = (1 - i3) * (1 - i3) * (r4[2] - s2[2]) + 2 * (1 - i3) * i3 * (o2[2] - r4[2]) + i3 * i3 * (h3[2] - o2[2]), l2 /= d3 = Math.sqrt(l2 * l2 + c3 * c3), c3 /= d3, e3 = [1, (t3 = n2.coords.usrCoords)[1] + l2, t3[2] + c3]), t3[1] - e3[1]);
    }], r3), n2.addChild(d2), d2.glider = n2) : a2.type === i2.Z.OBJECT_TYPE_TURTLE ? (d2 = t2.create("line", [function() {
      var t3 = Math.floor(n2.position);
      for (h2 = 0; h2 < a2.objects.length; h2++)
        if ((c2 = a2.objects[h2]).type === i2.Z.OBJECT_TYPE_CURVE) {
          if (t3 < c2.numberPoints)
            break;
          t3 -= c2.numberPoints;
        }
      return t3 === c2.numberPoints - 1 && t3--, t3 < 0 ? 1 : c2.Y(t3) * c2.X(t3 + 1) - c2.X(t3) * c2.Y(t3 + 1);
    }, function() {
      var t3 = Math.floor(n2.position);
      for (h2 = 0; h2 < a2.objects.length; h2++)
        if ((c2 = a2.objects[h2]).type === i2.Z.OBJECT_TYPE_CURVE) {
          if (t3 < c2.numberPoints)
            break;
          t3 -= c2.numberPoints;
        }
      return t3 === c2.numberPoints - 1 && t3--, t3 < 0 ? 0 : c2.Y(t3 + 1) - c2.Y(t3);
    }, function() {
      var t3 = Math.floor(n2.position);
      for (h2 = 0; h2 < a2.objects.length; h2++)
        if ((c2 = a2.objects[h2]).type === i2.Z.OBJECT_TYPE_CURVE) {
          if (t3 < c2.numberPoints)
            break;
          t3 -= c2.numberPoints;
        }
      return t3 === c2.numberPoints - 1 && t3--, t3 < 0 ? 0 : c2.X(t3) - c2.X(t3 + 1);
    }], r3), n2.addChild(d2), d2.glider = n2) : a2.elementClass !== i2.Z.OBJECT_CLASS_CIRCLE && a2.type !== i2.Z.OBJECT_TYPE_CONIC || (d2 = t2.create("line", [function() {
      return o.Z.matVecMult(a2.quadraticform, n2.coords.usrCoords)[0];
    }, function() {
      return o.Z.matVecMult(a2.quadraticform, n2.coords.usrCoords)[1];
    }, function() {
      return o.Z.matVecMult(a2.quadraticform, n2.coords.usrCoords)[2];
    }], r3), n2.addChild(d2), d2.glider = n2), !s.Z.exists(d2))
      throw new Error("JSXGraph: Couldn't create tangent with the given parents.");
    return d2.elType = "tangent", d2.type = i2.Z.OBJECT_TYPE_TANGENT, d2.setParents(e2), d2;
  }, t.Z.createRadicalAxis = function(t2, e2, s2) {
    var r3, n2, a2;
    if (2 !== e2.length || e2[0].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE || e2[1].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
      throw new Error("JSXGraph: Can't create 'radical axis' with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent type: [circle,circle]");
    return n2 = t2.select(e2[0]), a2 = t2.select(e2[1]), (r3 = t2.create("line", [function() {
      var t3 = n2.stdform, e3 = a2.stdform;
      return o.Z.matVecMult(o.Z.transpose([t3.slice(0, 3), e3.slice(0, 3)]), [e3[3], -t3[3]]);
    }], s2)).elType = "radicalaxis", r3.setParents([n2.id, a2.id]), n2.addChild(r3), a2.addChild(r3), r3;
  }, t.Z.createPolarLine = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, c2, d2;
    if (e2.length > 1 && (h2 = e2[0].type === i2.Z.OBJECT_TYPE_CONIC || e2[0].elementClass === i2.Z.OBJECT_CLASS_CIRCLE, l2 = e2[1].type === i2.Z.OBJECT_TYPE_CONIC || e2[1].elementClass === i2.Z.OBJECT_CLASS_CIRCLE, c2 = s.Z.isPoint(e2[0]), d2 = s.Z.isPoint(e2[1])), 2 !== e2.length || !(h2 && d2 || c2 && l2))
      throw new Error("JSXGraph: Can't create 'polar line' with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent type: [conic|circle,point], [point,conic|circle]");
    return d2 ? (n2 = t2.select(e2[0]), a2 = t2.select(e2[1])) : (n2 = t2.select(e2[1]), a2 = t2.select(e2[0])), (o2 = t2.create("tangent", [n2, a2], r3)).elType = "polarline", o2;
  }, t.Z.registerElement("tangent", t.Z.createTangent), t.Z.registerElement("polar", t.Z.createTangent), t.Z.registerElement("radicalaxis", t.Z.createRadicalAxis), t.Z.registerElement("polarline", t.Z.createPolarLine);
  t.Z.Line;
  t.Z.Group = function(t2, e2, r3, o2, n2) {
    var a2, h2, l2, c2;
    for (this.board = t2, this.objects = {}, a2 = this.board.numObjects, this.board.numObjects += 1, "" !== e2 && s.Z.exists(e2) ? this.id = e2 : this.id = this.board.id + "Group" + a2, this.board.groups[this.id] = this, this.type = i2.Z.OBJECT_TYPE_POINT, this.elementClass = i2.Z.OBJECT_CLASS_POINT, "" !== r3 && s.Z.exists(r3) ? this.name = r3 : this.name = "group_" + this.board.generateName(this), delete this.type, this.coords = {}, this.needsRegularUpdate = n2.needsregularupdate, this.rotationCenter = "centroid", this.scaleCenter = null, this.rotationPoints = [], this.translationPoints = [], this.scalePoints = [], this.scaleDirections = {}, this.parents = [], h2 = s.Z.isArray(o2) ? o2 : Array.prototype.slice.call(arguments, 3), l2 = 0; l2 < h2.length; l2++)
      c2 = this.board.select(h2[l2]), !s.Z.evaluate(c2.visProp.fixed) && s.Z.exists(c2.coords) && this.addPoint(c2);
    this.methodMap = { ungroup: "ungroup", add: "addPoint", addPoint: "addPoint", addPoints: "addPoints", addGroup: "addGroup", remove: "removePoint", removePoint: "removePoint", setAttribute: "setAttribute", setProperty: "setAttribute" };
  }, t.Z.extend(t.Z.Group.prototype, { ungroup: function() {
    var t2, e2, i3;
    for (t2 in this.objects)
      this.objects.hasOwnProperty(t2) && (e2 = this.objects[t2].point, s.Z.isArray(e2.groups) && (i3 = s.Z.indexOf(e2.groups, this.id)) >= 0 && delete e2.groups[i3]);
    return this.objects = {}, this;
  }, addParents: function(t2) {
    var e2, i3, r3;
    for (i3 = (r3 = s.Z.isArray(t2) ? t2 : arguments).length, e2 = 0; e2 < i3; ++e2)
      s.Z.isId(this.board, r3[e2]) ? this.parents.push(r3[e2]) : s.Z.exists(r3[e2].id) && this.parents.push(r3[e2].id);
    this.parents = s.Z.uniqueArray(this.parents);
  }, setParents: function(t2) {
    return this.parents = [], this.addParents(t2), this;
  }, getParents: function() {
    return s.Z.isArray(this.parents) ? this.parents : [];
  }, _updateCoordsCache: function(t2) {
    var e2;
    "" !== t2 && s.Z.exists(this.objects[t2]) && (e2 = this.objects[t2].point, this.coords[e2.id] = { usrCoords: e2.coords.usrCoords.slice(0) });
  }, update: function() {
    var t2, e2, i3, r3, n2, a2, h2, l2, c2, d2, p2 = null;
    if (!this.needsUpdate)
      return this;
    if ("nothing" === (t2 = this._update_find_drag_type()).action)
      return this._updateCoordsCache(t2.id), this;
    if (p2 = this.objects[t2.id].point, "translation" === t2.action)
      c2 = [p2.coords.usrCoords[1] - this.coords[t2.id].usrCoords[1], p2.coords.usrCoords[2] - this.coords[t2.id].usrCoords[2]];
    else if ("rotation" === t2.action || "scaling" === t2.action) {
      if (i3 = "rotation" === t2.action ? "rotationCenter" : "scaleCenter", s.Z.isPoint(this[i3]))
        d2 = this[i3].coords.usrCoords.slice(1);
      else if ("centroid" === this[i3])
        d2 = this._update_centroid_center();
      else if (s.Z.isArray(this[i3]))
        d2 = this[i3];
      else {
        if (!s.Z.isFunction(this[i3]))
          return this;
        d2 = this[i3]();
      }
      if ("rotation" === t2.action)
        l2 = u.Z.rad(this.coords[t2.id].usrCoords.slice(1), d2, this.objects[t2.id].point), (c2 = this.board.create("transform", [l2, d2[0], d2[1]], { type: "rotate" })).update();
      else {
        if ("scaling" !== t2.action)
          return this;
        if (n2 = u.Z.distance(this.coords[t2.id].usrCoords.slice(1), d2), Math.abs(n2) < o.Z.eps)
          return this;
        n2 = u.Z.distance(p2.coords.usrCoords.slice(1), d2) / n2, a2 = this.scaleDirections[t2.id].indexOf("x") >= 0 ? n2 : 1, h2 = this.scaleDirections[t2.id].indexOf("y") >= 0 ? n2 : 1, (c2 = this.board.create("transform", [1, 0, 0, d2[0] * (1 - a2), a2, 0, d2[1] * (1 - h2), 0, h2], { type: "generic" })).update();
      }
    }
    for (e2 in this._update_apply_transformation(t2, c2), this.needsUpdate = false, this.objects)
      if (this.objects.hasOwnProperty(e2))
        for (r3 in this.objects[e2].descendants)
          this.objects[e2].descendants.hasOwnProperty(r3) && (this.objects[e2].descendants.needsUpdate = this.objects[e2].descendants.needsRegularUpdate || this.board.needsFullUpdate);
    for (e2 in this.board.updateElements(t2), this.objects)
      this.objects.hasOwnProperty(e2) && this._updateCoordsCache(e2);
    return this;
  }, _update_find_drag_type: function() {
    var t2, e2, r3, n2 = "nothing", a2 = [];
    for (t2 in this.objects)
      this.objects.hasOwnProperty(t2) && (e2 = this.objects[t2].point).coords.distance(i2.Z.COORDS_BY_USER, this.coords[t2]) > o.Z.eps && a2.push(e2.id);
    return 0 === a2.length ? { action: n2, id: "", changed: a2 } : (r3 = a2[0], e2 = this.objects[r3].point, a2.length > 1 ? n2 = "translation" : s.Z.isInArray(this.rotationPoints, e2) && s.Z.exists(this.rotationCenter) ? n2 = "rotation" : s.Z.isInArray(this.scalePoints, e2) && s.Z.exists(this.scaleCenter) ? n2 = "scaling" : s.Z.isInArray(this.translationPoints, e2) && (n2 = "translation"), { action: n2, id: r3, changed: a2 });
  }, _update_centroid_center: function() {
    var t2, e2, i3;
    for (i3 in t2 = [0, 0], e2 = 0, this.coords)
      this.coords.hasOwnProperty(i3) && (t2[0] += this.coords[i3].usrCoords[1], t2[1] += this.coords[i3].usrCoords[2], ++e2);
    return e2 > 0 && (t2[0] /= e2, t2[1] /= e2), t2;
  }, _update_apply_transformation: function(t2, e2) {
    var r3, n2;
    for (r3 in this.objects)
      this.objects.hasOwnProperty(r3) && (s.Z.exists(this.board.objects[r3]) ? (n2 = this.objects[r3].point).id !== t2.id ? "translation" === t2.action ? s.Z.isInArray(t2.changed, n2.id) || n2.coords.setCoordinates(i2.Z.COORDS_BY_USER, [this.coords[r3].usrCoords[1] + e2[0], this.coords[r3].usrCoords[2] + e2[1]]) : "rotation" !== t2.action && "scaling" !== t2.action || e2.applyOnce([n2]) : "rotation" !== t2.action && "scaling" !== t2.action || n2.coords.setCoordinates(i2.Z.COORDS_BY_USER, o.Z.matVecMult(e2.matrix, this.coords[n2.id].usrCoords)) : delete this.objects[r3]);
  }, addPoint: function(t2) {
    return this.objects[t2.id] = { point: this.board.select(t2) }, this._updateCoordsCache(t2.id), this.translationPoints.push(t2), t2.groups.push(this.id), t2.groups = s.Z.uniqueArray(t2.groups), this;
  }, addPoints: function(t2) {
    var e2;
    for (e2 = 0; e2 < t2.length; e2++)
      this.addPoint(t2[e2]);
    return this;
  }, addGroup: function(t2) {
    var e2;
    for (e2 in t2.objects)
      t2.objects.hasOwnProperty(e2) && this.addPoint(t2.objects[e2].point);
    return this;
  }, removePoint: function(t2) {
    return delete this.objects[t2.id], this;
  }, setRotationCenter: function(t2) {
    return this.rotationCenter = t2, this;
  }, setRotationPoints: function(t2) {
    return this._setActionPoints("rotation", t2);
  }, addRotationPoint: function(t2) {
    return this._addActionPoint("rotation", t2);
  }, removeRotationPoint: function(t2) {
    return this._removeActionPoint("rotation", t2);
  }, setTranslationPoints: function(t2) {
    return this._setActionPoints("translation", t2);
  }, addTranslationPoint: function(t2) {
    return this._addActionPoint("translation", t2);
  }, removeTranslationPoint: function(t2) {
    return this._removeActionPoint("translation", t2);
  }, setScaleCenter: function(t2) {
    return this.scaleCenter = t2, this;
  }, setScalePoints: function(t2, e2) {
    var i3, r3, o2;
    for (o2 = (i3 = s.Z.isArray(t2) ? t2 : arguments).length, r3 = 0; r3 < o2; ++r3)
      this.scaleDirections[this.board.select(i3[r3]).id] = e2 || "xy";
    return this._setActionPoints("scale", t2);
  }, addScalePoint: function(t2, e2) {
    return this._addActionPoint("scale", t2), this.scaleDirections[this.board.select(t2).id] = e2 || "xy", this;
  }, removeScalePoint: function(t2) {
    return this._removeActionPoint("scale", t2);
  }, _setActionPoints: function(t2, e2) {
    var i3, r3, o2;
    for (o2 = (i3 = s.Z.isArray(e2) ? e2 : arguments).length, this[t2 + "Points"] = [], r3 = 0; r3 < o2; ++r3)
      this._addActionPoint(t2, i3[r3]);
    return this;
  }, _addActionPoint: function(t2, e2) {
    return this[t2 + "Points"].push(this.board.select(e2)), this;
  }, _removeActionPoint: function(t2, e2) {
    var i3 = this[t2 + "Points"].indexOf(this.board.select(e2));
    return i3 > -1 && this[t2 + "Points"].splice(i3, 1), this;
  }, setProperty: function() {
    t.Z.deprecated("Group.setProperty", "Group.setAttribute()"), this.setAttribute.apply(this, arguments);
  }, setAttribute: function() {
    var t2;
    for (t2 in this.objects)
      this.objects.hasOwnProperty(t2) && this.objects[t2].point.setAttribute.apply(this.objects[t2].point, arguments);
    return this;
  } }), t.Z.createGroup = function(e2, i3, r3) {
    var o2 = s.Z.copyAttributes(r3, e2.options, "group"), n2 = new t.Z.Group(e2, o2.id, o2.name, i3, o2);
    return n2.elType = "group", n2.setParents(i3), n2;
  }, t.Z.registerElement("group", t.Z.createGroup);
  t.Z.Group;
  t.Z.Circle = function(t2, e2, r3, o2, n2) {
    this.constructor(t2, n2, i2.Z.OBJECT_TYPE_CIRCLE, i2.Z.OBJECT_CLASS_CIRCLE), this.method = e2, this.midpoint = this.board.select(r3), this.center = this.board.select(r3), this.point2 = null, this.radius = 0, this.line = null, this.circle = null, this.points = [], "twoPoints" === e2 ? (this.point2 = t2.select(o2), this.radius = this.Radius()) : "pointRadius" === e2 ? (this.gxtterm = o2, this.updateRadius = s.Z.createFunction(o2, this.board, null, true), this.updateRadius(), this.addParentsFromJCFunctions([this.updateRadius])) : "pointLine" === e2 ? (this.line = t2.select(o2), this.radius = this.line.point1.coords.distance(i2.Z.COORDS_BY_USER, this.line.point2.coords)) : "pointCircle" === e2 && (this.circle = t2.select(o2), this.radius = this.circle.Radius()), this.id = this.board.setId(this, "C"), this.board.renderer.drawEllipse(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "circle", this.createLabel(), s.Z.exists(this.center._is_new) ? (this.addChild(this.center), delete this.center._is_new) : this.center.addChild(this), "pointRadius" === e2 ? this.notifyParents(o2) : "pointLine" === e2 ? this.line.addChild(this) : "pointCircle" === e2 ? this.circle.addChild(this) : "twoPoints" === e2 && (s.Z.exists(this.point2._is_new) ? (this.addChild(this.point2), delete this.point2._is_new) : this.point2.addChild(this)), this.methodMap = s.Z.deepCopy(this.methodMap, { setRadius: "setRadius", getRadius: "getRadius", Area: "Area", area: "Area", radius: "Radius", center: "center", line: "line", point2: "point2" });
  }, t.Z.Circle.prototype = new J.Z(), t.Z.extend(t.Z.Circle.prototype, { hasPoint: function(t2, e2) {
    var r3, o2, n2, a2, h2, l2 = this.center.coords.usrCoords, d2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e2], this.board), u2 = this.Radius();
    return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (o2 = this.board._inputDevice, r3 = s.Z.evaluate(this.visProp.precision[o2])) : r3 = this.board.options.precision.hasPoint, n2 = l2[1] - d2.usrCoords[1], a2 = l2[2] - d2.usrCoords[2], h2 = Math.sqrt(n2 * n2 + a2 * a2), r3 += 0.5 * s.Z.evaluate(this.visProp.strokewidth), r3 /= Math.sqrt(this.board.unitX * this.board.unitY), s.Z.evaluate(this.visProp.hasinnerpoints) ? h2 < u2 + r3 : Math.abs(h2 - u2) < r3;
  }, generatePolynomial: function(t2) {
    var e2 = this.center.symbolic.x, i3 = this.center.symbolic.y, s2 = t2.symbolic.x, r3 = t2.symbolic.y, o2 = this.generateRadiusSquared();
    return "" === o2 ? [] : ["((" + s2 + ")-(" + e2 + "))^2 + ((" + r3 + ")-(" + i3 + "))^2 - (" + o2 + ")"];
  }, generateRadiusSquared: function() {
    var t2, e2, i3, r3, o2 = "";
    return "twoPoints" === this.method ? (t2 = this.center.symbolic.x, e2 = this.center.symbolic.y, o2 = "((" + (i3 = this.point2.symbolic.x) + ")-(" + t2 + "))^2 + ((" + (r3 = this.point2.symbolic.y) + ")-(" + e2 + "))^2") : "pointRadius" === this.method ? s.Z.isNumber(this.radius) && (o2 = (this.radius * this.radius).toString()) : "pointLine" === this.method ? (i3 = this.line.point1.symbolic.x, r3 = this.line.point1.symbolic.y, o2 = "((" + i3 + ")-(" + this.line.point2.symbolic.x + "))^2 + ((" + r3 + ")-(" + this.line.point2.symbolic.y + "))^2") : "pointCircle" === this.method && (o2 = this.circle.Radius()), o2;
  }, update: function() {
    var t2, e2, r3, o2, n2, a2;
    if (this.needsUpdate)
      for (s.Z.evaluate(this.visProp.trace) && this.cloneToBackground(true), "pointLine" === this.method ? this.radius = this.line.point1.coords.distance(i2.Z.COORDS_BY_USER, this.line.point2.coords) : "pointCircle" === this.method ? this.radius = this.circle.Radius() : "pointRadius" === this.method && (this.radius = this.updateRadius()), this.updateStdform(), this.updateQuadraticform(), r3 = this.center.coords.usrCoords[0], t2 = this.center.coords.usrCoords[1] / r3, e2 = this.center.coords.usrCoords[2] / r3, r3 /= r3, o2 = this.Radius(), n2 = 0.551915024494, this.numberPoints = 13, this.dataX = [t2 + o2, t2 + o2, t2 + o2 * n2, t2, t2 - o2 * n2, t2 - o2, t2 - o2, t2 - o2, t2 - o2 * n2, t2, t2 + o2 * n2, t2 + o2, t2 + o2], this.dataY = [e2, e2 + o2 * n2, e2 + o2, e2 + o2, e2 + o2, e2 + o2 * n2, e2, e2 - o2 * n2, e2 - o2, e2 - o2, e2 - o2, e2 - o2 * n2, e2], this.bezierDegree = 3, a2 = 0; a2 < this.numberPoints; a2++)
        this.points[a2] = new c.Z(i2.Z.COORDS_BY_USER, [this.dataX[a2], this.dataY[a2]], this.board);
    return this;
  }, updateQuadraticform: function() {
    var t2 = this.center, e2 = t2.X(), i3 = t2.Y(), s2 = this.Radius();
    this.quadraticform = [[e2 * e2 + i3 * i3 - s2 * s2, -e2, -i3], [-e2, 1, 0], [-i3, 0, 1]];
  }, updateStdform: function() {
    this.stdform[3] = 0.5, this.stdform[4] = this.Radius(), this.stdform[1] = -this.center.coords.usrCoords[1], this.stdform[2] = -this.center.coords.usrCoords[2], isFinite(this.stdform[4]) || (this.stdform[0] = s.Z.exists(this.point2) ? -(this.stdform[1] * this.point2.coords.usrCoords[1] + this.stdform[2] * this.point2.coords.usrCoords[2]) : 0), this.normalize();
  }, updateRenderer: function() {
    return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.center.coords.usrCoords[1] + this.center.coords.usrCoords[2] + this.Radius()) && this.center.isReal, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateEllipse(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
  }, notifyParents: function(t2) {
    s.Z.isString(t2) && k.Z.findDependencies(this, t2, this.board);
  }, setRadius: function(t2) {
    return this.updateRadius = s.Z.createFunction(t2, this.board, null, true), this.addParentsFromJCFunctions([this.updateRadius]), this.board.update(), this;
  }, Radius: function(t2) {
    return s.Z.exists(t2) ? (this.setRadius(t2), this.Radius()) : "twoPoints" === this.method ? s.Z.cmpArrays(this.point2.coords.usrCoords, [0, 0, 0]) || s.Z.cmpArrays(this.center.coords.usrCoords, [0, 0, 0]) ? NaN : this.center.Dist(this.point2) : "pointLine" === this.method || "pointCircle" === this.method ? this.radius : "pointRadius" === this.method ? this.updateRadius() : NaN;
  }, getRadius: function() {
    return t.Z.deprecated("Circle.getRadius()", "Circle.Radius()"), this.Radius();
  }, getTextAnchor: function() {
    return this.center.coords;
  }, getLabelAnchor: function() {
    var t2, e2, r3 = this.Radius(), o2 = this.center.coords.usrCoords, n2 = 0.7071067811865;
    switch (s.Z.evaluate(this.visProp.label.position)) {
      case "lft":
        t2 = o2[1] - r3, e2 = o2[2];
        break;
      case "llft":
        t2 = o2[1] - n2 * r3, e2 = o2[2] - n2 * r3;
        break;
      case "rt":
        t2 = o2[1] + r3, e2 = o2[2];
        break;
      case "lrt":
        t2 = o2[1] + n2 * r3, e2 = o2[2] - n2 * r3;
        break;
      case "urt":
        t2 = o2[1] + n2 * r3, e2 = o2[2] + n2 * r3;
        break;
      case "top":
        t2 = o2[1], e2 = o2[2] + r3;
        break;
      case "bot":
        t2 = o2[1], e2 = o2[2] - r3;
        break;
      default:
        t2 = o2[1] - n2 * r3, e2 = o2[2] + n2 * r3;
    }
    return new c.Z(i2.Z.COORDS_BY_USER, [t2, e2], this.board);
  }, cloneToBackground: function() {
    var t2, e2 = this.Radius(), r3 = { id: this.id + "T" + this.numTraces, elementClass: i2.Z.OBJECT_CLASS_CIRCLE, center: { coords: this.center.coords }, Radius: function() {
      return e2;
    }, getRadius: function() {
      return e2;
    }, board: this.board, visProp: s.Z.deepCopy(this.visProp, this.visProp.traceattributes, true) };
    return r3.visProp.layer = this.board.options.layer.trace, this.numTraces++, s.Z.clearVisPropOld(r3), r3.visPropCalc = { visible: s.Z.evaluate(r3.visProp.visible) }, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawEllipse(r3), this.board.renderer.enhancedRendering = t2, this.traces[r3.id] = r3.rendNode, this;
  }, addTransform: function(t2) {
    var e2, i3 = s.Z.isArray(t2) ? t2 : [t2], r3 = i3.length;
    for (e2 = 0; e2 < r3; e2++)
      this.center.transformations.push(i3[e2]), "twoPoints" === this.method && this.point2.transformations.push(i3[e2]);
    return this;
  }, snapToGrid: function() {
    var t2 = s.Z.evaluate(this.visProp.snaptogrid);
    return this.center.handleSnapToGrid(t2, true), "twoPoints" === this.method && this.point2.handleSnapToGrid(t2, true), this;
  }, snapToPoints: function() {
    var t2 = s.Z.evaluate(this.visProp.snaptopoints);
    return this.center.handleSnapToPoints(t2), "twoPoints" === this.method && this.point2.handleSnapToPoints(t2), this;
  }, X: function(t2) {
    return this.Radius() * Math.cos(2 * t2 * Math.PI) + this.center.coords.usrCoords[1];
  }, Y: function(t2) {
    return this.Radius() * Math.sin(2 * t2 * Math.PI) + this.center.coords.usrCoords[2];
  }, Z: function(t2) {
    return 1;
  }, minX: function() {
    return 0;
  }, maxX: function() {
    return 1;
  }, Area: function() {
    var t2 = this.Radius();
    return t2 * t2 * Math.PI;
  }, bounds: function() {
    var t2 = this.center.coords.usrCoords, e2 = this.Radius();
    return [t2[1] - e2, t2[2] + e2, t2[1] + e2, t2[2] - e2];
  }, getParents: function() {
    return 1 === this.parents.length ? this.parents.concat(this.radius) : this.parents;
  } }), t.Z.createCircle = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2 = ["center", "point2"];
    if (a2 = [], c2 = e2.select(r3[0]), s.Z.isObject(c2) && c2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE && s.Z.isTransformationOrArray(r3[1]))
      return l2 = s.Z.copyAttributes(o2, e2.options, "circle"), (n2 = t.Z.createEllipse(e2, [c2.center, c2.center, function() {
        return 2 * c2.Radius();
      }], l2)).addTransform(r3[1]), n2;
    for (h2 = 0; h2 < r3.length; h2++)
      if (s.Z.isPointType(e2, r3[h2])) {
        if (false === (a2 = a2.concat(s.Z.providePoints(e2, [r3[h2]], o2, "circle", [d2[h2]])))[a2.length - 1])
          throw new Error("JSXGraph: Can't create circle from this type. Please provide a point type.");
      } else
        a2.push(r3[h2]);
    if (l2 = s.Z.copyAttributes(o2, e2.options, "circle"), 2 === a2.length && s.Z.isPoint(a2[0]) && s.Z.isPoint(a2[1]))
      n2 = new t.Z.Circle(e2, "twoPoints", a2[0], a2[1], l2);
    else if ((s.Z.isNumber(a2[0]) || s.Z.isFunction(a2[0]) || s.Z.isString(a2[0])) && s.Z.isPoint(a2[1]))
      n2 = new t.Z.Circle(e2, "pointRadius", a2[1], a2[0], l2);
    else if ((s.Z.isNumber(a2[1]) || s.Z.isFunction(a2[1]) || s.Z.isString(a2[1])) && s.Z.isPoint(a2[0]))
      n2 = new t.Z.Circle(e2, "pointRadius", a2[0], a2[1], l2);
    else if (a2[0].elementClass === i2.Z.OBJECT_CLASS_CIRCLE && s.Z.isPoint(a2[1]))
      n2 = new t.Z.Circle(e2, "pointCircle", a2[1], a2[0], l2);
    else if (a2[1].elementClass === i2.Z.OBJECT_CLASS_CIRCLE && s.Z.isPoint(a2[0]))
      n2 = new t.Z.Circle(e2, "pointCircle", a2[0], a2[1], l2);
    else if (a2[0].elementClass === i2.Z.OBJECT_CLASS_LINE && s.Z.isPoint(a2[1]))
      n2 = new t.Z.Circle(e2, "pointLine", a2[1], a2[0], l2);
    else if (a2[1].elementClass === i2.Z.OBJECT_CLASS_LINE && s.Z.isPoint(a2[0]))
      n2 = new t.Z.Circle(e2, "pointLine", a2[0], a2[1], l2);
    else {
      if (!(3 === r3.length && s.Z.isPoint(a2[0]) && s.Z.isPoint(a2[1]) && s.Z.isPoint(a2[2])))
        throw new Error("JSXGraph: Can't create circle with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'.\nPossible parent types: [point,point], [point,number], [point,function], [point,circle], [point,point,point], [circle,transformation]");
      if (!t.Z.elements.circumcircle)
        throw new Error("JSXGraph: Can't create circle with three points. Please include the circumcircle element (element/composition).");
      n2 = t.Z.elements.circumcircle(e2, a2, l2);
    }
    for (n2.isDraggable = true, n2.setParents(a2), n2.elType = "circle", h2 = 0; h2 < a2.length; h2++)
      s.Z.isPoint(a2[h2]) && n2.inherits.push(a2[h2]);
    return n2;
  }, t.Z.registerElement("circle", t.Z.createCircle);
  const H = t.Z.Circle;
  t.Z.createEllipse = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, d2, u2, p2 = [], _2 = s.Z.copyAttributes(r3, t2.options, "conic", "foci"), f2 = s.Z.copyAttributes(r3, t2.options, "conic", "center"), b2 = s.Z.copyAttributes(r3, t2.options, "conic");
    for (d2 = 0; d2 < 2; d2++)
      if (e2[d2].length > 1)
        p2[d2] = t2.create("point", e2[d2], _2);
      else if (s.Z.isPoint(e2[d2]))
        p2[d2] = t2.select(e2[d2]);
      else if (s.Z.isFunction(e2[d2]) && s.Z.isPoint(e2[d2]()))
        p2[d2] = e2[d2]();
      else {
        if (!s.Z.isString(e2[d2]))
          throw new Error("JSXGraph: Can't create Ellipse with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
        p2[d2] = t2.select(e2[d2]);
      }
    if (s.Z.isNumber(e2[2]))
      l2 = s.Z.createFunction(e2[2], t2);
    else if (s.Z.isFunction(e2[2]) && s.Z.isNumber(e2[2]()))
      l2 = e2[2];
    else {
      if (s.Z.isPoint(e2[2]))
        h2 = t2.select(e2[2]);
      else if (e2[2].length > 1)
        h2 = t2.create("point", e2[2], _2);
      else if (s.Z.isFunction(e2[2]) && s.Z.isPoint(e2[2]()))
        h2 = e2[2]();
      else {
        if (!s.Z.isString(e2[2]))
          throw new Error("JSXGraph: Can't create Ellipse with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
        h2 = t2.select(e2[2]);
      }
      l2 = function() {
        return h2.Dist(p2[0]) + h2.Dist(p2[1]);
      };
    }
    for (s.Z.exists(e2[4]) || (e2[4] = 2 * Math.PI), s.Z.exists(e2[3]) || (e2[3] = 0), a2 = t2.create("point", [function() {
      return 0.5 * (p2[0].X() + p2[1].X());
    }, function() {
      return 0.5 * (p2[0].Y() + p2[1].Y());
    }], f2), (n2 = t2.create("curve", [function(t3) {
      return 0;
    }, function(t3) {
      return 0;
    }, e2[3], e2[4]], b2)).majorAxis = l2, u2 = n2.hasPoint, o2 = function(t3, e3) {
      var i3, s2, r4, o3, a3, h3, c2, d3, u3;
      e3 || (s2 = (i3 = l2()) * i3, r4 = p2[0].X(), o3 = p2[0].Y(), c2 = r4 - (a3 = p2[1].X()), d3 = o3 - (h3 = p2[1].Y()), u3 = (s2 - r4 * r4 - o3 * o3 + a3 * a3 + h3 * h3) / (2 * i3), n2.quadraticform = [[u3 * u3 - a3 * a3 - h3 * h3, u3 * c2 / i3 + a3, u3 * d3 / i3 + h3], [u3 * c2 / i3 + a3, c2 * c2 / s2 - 1, c2 * d3 / s2], [u3 * d3 / i3 + h3, c2 * d3 / s2, d3 * d3 / s2 - 1]]);
    }, n2.X = function(t3, e3) {
      var i3 = l2(), s2 = p2[1].Dist(p2[0]), r4 = 0.5 * (s2 * s2 - i3 * i3) / (s2 * Math.cos(t3) - i3), n3 = Math.atan2(p2[1].Y() - p2[0].Y(), p2[1].X() - p2[0].X());
      return e3 || o2(0, e3), p2[0].X() + Math.cos(n3 + t3) * r4;
    }, n2.Y = function(t3, e3) {
      var i3 = l2(), s2 = p2[1].Dist(p2[0]), r4 = 0.5 * (s2 * s2 - i3 * i3) / (s2 * Math.cos(t3) - i3), o3 = Math.atan2(p2[1].Y() - p2[0].Y(), p2[1].X() - p2[0].X());
      return p2[0].Y() + Math.sin(o3 + t3) * r4;
    }, n2.midpoint = n2.center = a2, n2.type = i2.Z.OBJECT_TYPE_CONIC, n2.subs = { center: n2.center }, n2.inherits.push(n2.center, p2[0], p2[1]), s.Z.isPoint(h2) && n2.inherits.push(h2), n2.hasPoint = function(t3, e3) {
      var r4, o3, n3, a3;
      return s.Z.evaluate(this.visProp.hasinnerpoints) ? (r4 = p2[0].coords, o3 = p2[1].coords, n3 = this.majorAxis(), (a3 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t3, e3], this.board)).distance(i2.Z.COORDS_BY_USER, r4) + a3.distance(i2.Z.COORDS_BY_USER, o3) <= n3) : u2.apply(this, arguments);
    }, a2.addChild(n2), d2 = 0; d2 < 2; d2++)
      s.Z.isPoint(p2[d2]) && p2[d2].addChild(n2);
    return s.Z.isPoint(h2) && h2.addChild(n2), n2.setParents(e2), n2;
  }, t.Z.createHyperbola = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, c2, d2 = [], u2 = s.Z.copyAttributes(r3, t2.options, "conic", "foci"), p2 = s.Z.copyAttributes(r3, t2.options, "conic", "center"), _2 = s.Z.copyAttributes(r3, t2.options, "conic");
    for (c2 = 0; c2 < 2; c2++)
      if (e2[c2].length > 1)
        d2[c2] = t2.create("point", e2[c2], u2);
      else if (s.Z.isPoint(e2[c2]))
        d2[c2] = t2.select(e2[c2]);
      else if (s.Z.isFunction(e2[c2]) && s.Z.isPoint(e2[c2]()))
        d2[c2] = e2[c2]();
      else {
        if (!s.Z.isString(e2[c2]))
          throw new Error("JSXGraph: Can't create Hyperbola with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
        d2[c2] = t2.select(e2[c2]);
      }
    if (s.Z.isNumber(e2[2]))
      l2 = s.Z.createFunction(e2[2], t2);
    else if (s.Z.isFunction(e2[2]) && s.Z.isNumber(e2[2]()))
      l2 = e2[2];
    else {
      if (s.Z.isPoint(e2[2]))
        h2 = t2.select(e2[2]);
      else if (e2[2].length > 1)
        h2 = t2.create("point", e2[2], u2);
      else if (s.Z.isFunction(e2[2]) && s.Z.isPoint(e2[2]()))
        h2 = e2[2]();
      else {
        if (!s.Z.isString(e2[2]))
          throw new Error("JSXGraph: Can't create Hyperbola with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
        h2 = t2.select(e2[2]);
      }
      l2 = function() {
        return h2.Dist(d2[0]) - h2.Dist(d2[1]);
      };
    }
    for (s.Z.exists(e2[4]) || (e2[4] = 1.0001 * Math.PI), s.Z.exists(e2[3]) || (e2[3] = -1.0001 * Math.PI), a2 = t2.create("point", [function() {
      return 0.5 * (d2[0].X() + d2[1].X());
    }, function() {
      return 0.5 * (d2[0].Y() + d2[1].Y());
    }], p2), (n2 = t2.create("curve", [function(t3) {
      return 0;
    }, function(t3) {
      return 0;
    }, e2[3], e2[4]], _2)).majorAxis = l2, o2 = function(t3, e3) {
      var i3, s2, r4, o3, a3, h3, c3, u3, p3;
      e3 || (s2 = (i3 = l2()) * i3, r4 = d2[0].X(), o3 = d2[0].Y(), c3 = r4 - (a3 = d2[1].X()), u3 = o3 - (h3 = d2[1].Y()), p3 = (s2 - r4 * r4 - o3 * o3 + a3 * a3 + h3 * h3) / (2 * i3), n2.quadraticform = [[p3 * p3 - a3 * a3 - h3 * h3, p3 * c3 / i3 + a3, p3 * u3 / i3 + h3], [p3 * c3 / i3 + a3, c3 * c3 / s2 - 1, c3 * u3 / s2], [p3 * u3 / i3 + h3, c3 * u3 / s2, u3 * u3 / s2 - 1]]);
    }, n2.X = function(t3, e3) {
      var i3 = l2(), s2 = d2[1].Dist(d2[0]), r4 = 0.5 * (s2 * s2 - i3 * i3) / (s2 * Math.cos(t3) + i3), n3 = Math.atan2(d2[1].Y() - d2[0].Y(), d2[1].X() - d2[0].X());
      return e3 || o2(0, e3), d2[0].X() + Math.cos(n3 + t3) * r4;
    }, n2.Y = function(t3, e3) {
      var i3 = l2(), s2 = d2[1].Dist(d2[0]), r4 = 0.5 * (s2 * s2 - i3 * i3) / (s2 * Math.cos(t3) + i3), o3 = Math.atan2(d2[1].Y() - d2[0].Y(), d2[1].X() - d2[0].X());
      return d2[0].Y() + Math.sin(o3 + t3) * r4;
    }, n2.midpoint = n2.center = a2, n2.subs = { center: n2.center }, n2.inherits.push(n2.center, d2[0], d2[1]), s.Z.isPoint(h2) && n2.inherits.push(h2), n2.type = i2.Z.OBJECT_TYPE_CONIC, a2.addChild(n2), c2 = 0; c2 < 2; c2++)
      s.Z.isPoint(d2[c2]) && d2[c2].addChild(n2);
    return s.Z.isPoint(h2) && h2.addChild(n2), n2.setParents(e2), n2;
  }, t.Z.createParabola = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = e2[0], c2 = e2[1], d2 = s.Z.copyAttributes(r3, t2.options, "conic", "foci"), p2 = s.Z.copyAttributes(r3, t2.options, "conic", "center"), _2 = s.Z.copyAttributes(r3, t2.options, "conic");
    if (e2[0].length > 1)
      l2 = t2.create("point", e2[0], d2);
    else if (s.Z.isPoint(e2[0]))
      l2 = t2.select(e2[0]);
    else if (s.Z.isFunction(e2[0]) && s.Z.isPoint(e2[0]()))
      l2 = e2[0]();
    else {
      if (!s.Z.isString(e2[0]))
        throw new Error("JSXGraph: Can't create Parabola with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line]");
      l2 = t2.select(e2[0]);
    }
    return s.Z.isArray(c2) && 2 === c2.length && (h2 = s.Z.copyAttributes(r3, t2.options, "conic", "line"), c2 = t2.create("line", c2, h2)), s.Z.exists(e2[3]) || (e2[3] = 2 * Math.PI), s.Z.exists(e2[2]) || (e2[2] = 0), a2 = t2.create("point", [function() {
      return u.Z.projectPointToLine(l2, c2, t2).usrCoords;
    }], p2), (n2 = t2.create("curve", [function(t3) {
      return 0;
    }, function(t3) {
      return 0;
    }, e2[2], e2[3]], _2)).midpoint = n2.center = a2, n2.subs = { center: n2.center }, n2.inherits.push(n2.center), o2 = function(t3, e3) {
      var i3, s2, r4, o3, a3, h3;
      e3 || (i3 = c2.stdform[1], s2 = c2.stdform[2], r4 = c2.stdform[0], o3 = i3 * i3 + s2 * s2, a3 = l2.X(), h3 = l2.Y(), n2.quadraticform = [[r4 * r4 - o3 * (a3 * a3 + h3 * h3), r4 * i3 + o3 * a3, r4 * s2 + o3 * h3], [r4 * i3 + o3 * a3, -s2 * s2, i3 * s2], [r4 * s2 + o3 * h3, i3 * s2, -i3 * i3]]);
    }, n2.X = function(t3, e3) {
      var i3, s2 = c2.getAngle(), r4 = u.Z.distPointLine(l2.coords.usrCoords, c2.stdform), n3 = c2.point1.coords.usrCoords, a3 = c2.point2.coords.usrCoords, h3 = l2.coords.usrCoords;
      return 0 === n3[0] ? n3 = [1, a3[1] + c2.stdform[2], a3[2] - c2.stdform[1]] : 0 === a3[0] && (a3 = [1, n3[1] + c2.stdform[2], n3[2] - c2.stdform[1]]), i3 = ((a3[1] - n3[1]) * (h3[2] - n3[2]) - (a3[2] - n3[2]) * (h3[1] - n3[1]) >= 0 ? 1 : -1) * r4 / (1 - Math.sin(t3)), e3 || o2(0, e3), l2.X() + Math.cos(t3 + s2) * i3;
    }, n2.Y = function(t3, e3) {
      var i3, s2 = c2.getAngle(), r4 = u.Z.distPointLine(l2.coords.usrCoords, c2.stdform), o3 = c2.point1.coords.usrCoords, n3 = c2.point2.coords.usrCoords, a3 = l2.coords.usrCoords;
      return 0 === o3[0] ? o3 = [1, n3[1] + c2.stdform[2], n3[2] - c2.stdform[1]] : 0 === n3[0] && (n3 = [1, o3[1] + c2.stdform[2], o3[2] - c2.stdform[1]]), i3 = ((n3[1] - o3[1]) * (a3[2] - o3[2]) - (n3[2] - o3[2]) * (a3[1] - o3[1]) >= 0 ? 1 : -1) * r4 / (1 - Math.sin(t3)), l2.Y() + Math.sin(t3 + s2) * i3;
    }, n2.type = i2.Z.OBJECT_TYPE_CONIC, a2.addChild(n2), s.Z.isPoint(l2) && (l2.addChild(n2), n2.inherits.push(l2)), c2.addChild(n2), n2.setParents(e2), n2;
  }, t.Z.createConic = function(t2, e2, r3) {
    var n2, a2, h2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], y2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], P2 = [], E2 = [], O2 = s.Z.copyAttributes(r3, t2.options, "conic", "point"), x2 = s.Z.copyAttributes(r3, t2.options, "conic", "center"), w2 = s.Z.copyAttributes(r3, t2.options, "conic");
    if (5 === e2.length)
      Z2 = true;
    else {
      if (6 !== e2.length)
        throw new Error("JSXGraph: Can't create generic Conic with " + e2.length + " parameters.");
      Z2 = false;
    }
    if (Z2)
      for (m2 = 0; m2 < 5; m2++)
        if (e2[m2].length > 1)
          P2[m2] = t2.create("point", e2[m2], O2);
        else if (s.Z.isPoint(e2[m2]))
          P2[m2] = t2.select(e2[m2]);
        else if (s.Z.isFunction(e2[m2]) && s.Z.isPoint(e2[m2]()))
          P2[m2] = e2[m2]();
        else {
          if (!s.Z.isString(e2[m2]))
            throw new Error("JSXGraph: Can't create Conic section with parent types '" + typeof e2[m2] + "'.\nPossible parent types: [point,point,point,point,point], [a00,a11,a22,a01,a02,a12]");
          P2[m2] = t2.select(e2[m2]);
        }
    else
      (v2 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]])[0][0] = s.Z.isFunction(e2[2]) ? function() {
        return e2[2]();
      } : function() {
        return e2[2];
      }, v2[0][1] = s.Z.isFunction(e2[4]) ? function() {
        return e2[4]();
      } : function() {
        return e2[4];
      }, v2[0][2] = s.Z.isFunction(e2[5]) ? function() {
        return e2[5]();
      } : function() {
        return e2[5];
      }, v2[1][1] = s.Z.isFunction(e2[0]) ? function() {
        return e2[0]();
      } : function() {
        return e2[0];
      }, v2[1][2] = s.Z.isFunction(e2[3]) ? function() {
        return e2[3]();
      } : function() {
        return e2[3];
      }, v2[2][2] = s.Z.isFunction(e2[1]) ? function() {
        return e2[1]();
      } : function() {
        return e2[1];
      };
    if (d2 = function(t3) {
      var e3, i3;
      for (e3 = 0; e3 < 3; e3++)
        for (i3 = e3; i3 < 3; i3++)
          t3[e3][i3] += t3[i3][e3];
      for (e3 = 0; e3 < 3; e3++)
        for (i3 = 0; i3 < e3; i3++)
          t3[e3][i3] = t3[i3][e3];
      return t3;
    }, c2 = function(t3, e3) {
      var i3, s2, r4 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
      for (i3 = 0; i3 < 3; i3++)
        for (s2 = 0; s2 < 3; s2++)
          r4[i3][s2] = t3[i3] * e3[s2];
      return d2(r4);
    }, h2 = function(t3, e3, i3) {
      var s2, r4, n3, a3, h3, l2 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
      for (h3 = o.Z.matVecMult(e3, i3), n3 = o.Z.innerProduct(i3, h3), h3 = o.Z.matVecMult(t3, i3), a3 = o.Z.innerProduct(i3, h3), s2 = 0; s2 < 3; s2++)
        for (r4 = 0; r4 < 3; r4++)
          l2[s2][r4] = n3 * t3[s2][r4] - a3 * e3[s2][r4];
      return l2;
    }, a2 = t2.create("curve", [function(t3) {
      return 0;
    }, function(t3) {
      return 0;
    }, 0, 2 * Math.PI], w2), n2 = function(t3, e3) {
      var i3, r4, n3, d3;
      if (!e3) {
        if (Z2) {
          for (i3 = 0; i3 < 5; i3++)
            E2[i3] = P2[i3].coords.usrCoords;
          b2 = c2(o.Z.crossProduct(E2[0], E2[1]), o.Z.crossProduct(E2[2], E2[3])), g2 = c2(o.Z.crossProduct(E2[0], E2[2]), o.Z.crossProduct(E2[1], E2[3])), y2 = h2(b2, g2, E2[4]);
        } else
          for (i3 = 0; i3 < 3; i3++)
            for (r4 = i3; r4 < 3; r4++)
              y2[i3][r4] = v2[i3][r4](), r4 > i3 && (y2[r4][i3] = y2[i3][r4]);
        for (a2.quadraticform = y2, (u2 = l.Z.Jacobi(y2))[0][0][0] < 0 && (u2[0][0][0] *= -1, u2[0][1][1] *= -1, u2[0][2][2] *= -1), i3 = 0; i3 < 3; i3++) {
          for (n3 = 0, r4 = 0; r4 < 3; r4++)
            n3 += u2[1][r4][i3] * u2[1][r4][i3];
          n3 = Math.sqrt(n3);
        }
        C2 = u2[1], f2 = Math.sqrt(Math.abs(u2[0][0][0])), p2 = Math.sqrt(Math.abs(u2[0][1][1])), _2 = Math.sqrt(Math.abs(u2[0][2][2]));
      }
      return u2[0][1][1] <= 0 && u2[0][2][2] <= 0 ? d3 = o.Z.matVecMult(C2, [1 / f2, Math.cos(t3) / p2, Math.sin(t3) / _2]) : u2[0][1][1] <= 0 && u2[0][2][2] > 0 ? d3 = o.Z.matVecMult(C2, [Math.cos(t3) / f2, 1 / p2, Math.sin(t3) / _2]) : u2[0][2][2] < 0 && (d3 = o.Z.matVecMult(C2, [Math.sin(t3) / f2, Math.cos(t3) / p2, 1 / _2])), s.Z.exists(d3) ? (d3[1] /= d3[0], d3[2] /= d3[0], d3[0] = 1) : d3 = [1, NaN, NaN], d3;
    }, a2.X = function(t3, e3) {
      return n2(t3, e3)[1];
    }, a2.Y = function(t3, e3) {
      return n2(t3, e3)[2];
    }, a2.midpoint = t2.create("point", [function() {
      var t3 = a2.quadraticform;
      return [t3[1][1] * t3[2][2] - t3[1][2] * t3[1][2], t3[1][2] * t3[0][2] - t3[2][2] * t3[0][1], t3[0][1] * t3[1][2] - t3[1][1] * t3[0][2]];
    }], x2), a2.type = i2.Z.OBJECT_TYPE_CONIC, a2.center = a2.midpoint, a2.subs = { center: a2.center }, a2.inherits.push(a2.center), a2.inherits = a2.inherits.concat(P2), Z2) {
      for (m2 = 0; m2 < 5; m2++)
        s.Z.isPoint(P2[m2]) && P2[m2].addChild(a2);
      a2.setParents(e2);
    }
    return a2.addChild(a2.center), a2;
  }, t.Z.registerElement("ellipse", t.Z.createEllipse), t.Z.registerElement("hyperbola", t.Z.createHyperbola), t.Z.registerElement("parabola", t.Z.createParabola), t.Z.registerElement("conic", t.Z.createConic), t.Z.Polygon = function(e2, r3, o2) {
    this.constructor(e2, o2, i2.Z.OBJECT_TYPE_POLYGON, i2.Z.OBJECT_CLASS_AREA);
    var n2, a2, h2, l2, c2, d2 = s.Z.copyAttributes(o2, e2.options, "polygon", "borders");
    for (this.withLines = o2.withlines, this.attr_line = d2, this.vertices = [], n2 = 0; n2 < r3.length; n2++)
      this.vertices[n2] = this.board.select(r3[n2]), this.vertices[n2]._is_new && (delete this.vertices[n2]._is_new, this.vertices[n2]._is_new_pol = true);
    if (this.vertices.length > 0 && this.vertices[this.vertices.length - 1].id !== this.vertices[0].id && this.vertices.push(this.vertices[0]), this.borders = [], this.withLines)
      for (h2 = this.vertices.length - 1, l2 = 0; l2 < h2; l2++)
        n2 = (l2 + 1) % h2, d2.id = d2.ids && d2.ids[n2], d2.name = d2.names && d2.names[n2], d2.strokecolor = s.Z.isArray(d2.colors) && d2.colors[n2 % d2.colors.length] || d2.strokecolor, d2.visible = s.Z.exists(o2.borders.visible) ? o2.borders.visible : o2.visible, false === d2.strokecolor && (d2.strokecolor = "none"), (a2 = e2.create("segment", [this.vertices[n2], this.vertices[n2 + 1]], d2)).dump = false, this.borders[n2] = a2, a2.parentPolygon = this;
    for (this.inherits.push(this.vertices, this.borders), this.id = this.board.setId(this, "Py"), n2 = 0; n2 < this.vertices.length - 1; n2++)
      c2 = this.board.select(this.vertices[n2]), s.Z.exists(c2._is_new_pol) ? (this.addChild(c2), delete c2._is_new_pol) : c2.addChild(this);
    this.board.renderer.drawPolygon(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "polygon", this.createLabel(), this.methodMap = t.Z.deepCopy(this.methodMap, { borders: "borders", vertices: "vertices", A: "Area", Area: "Area", Perimeter: "Perimeter", L: "Perimeter", Length: "Perimeter", boundingBox: "boundingBox", bounds: "bounds", addPoints: "addPoints", insertPoints: "insertPoints", removePoints: "removePoints" });
  }, t.Z.Polygon.prototype = new J.Z(), t.Z.extend(t.Z.Polygon.prototype, { pnpoly: function(t2, e2, i3) {
    return u.Z.pnpoly(t2, e2, this.vertices, i3);
  }, hasPoint: function(t2, e2) {
    var i3, r3;
    if (s.Z.evaluate(this.visProp.hasinnerpoints) && this.pnpoly(t2, e2))
      return true;
    for (r3 = this.borders.length, i3 = 0; i3 < r3; i3++)
      if (this.borders[i3].hasPoint(t2, e2))
        return true;
    return false;
  }, updateRenderer: function() {
    var t2, e2;
    if (!this.needsUpdate)
      return this;
    if (this.visPropCalc.visible) {
      for (e2 = this.vertices.length, this.isReal = true, t2 = 0; t2 < e2; ++t2)
        if (!this.vertices[t2].isReal) {
          this.isReal = false;
          break;
        }
      this.isReal || this.updateVisibility(false);
    }
    return this.visPropCalc.visible && this.board.renderer.updatePolygon(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this;
  }, getTextAnchor: function() {
    var t2, e2, s2, r3, o2;
    if (0 === this.vertices.length)
      return new c.Z(i2.Z.COORDS_BY_USER, [1, 0, 0], this.board);
    for (s2 = t2 = this.vertices[0].X(), r3 = e2 = this.vertices[0].Y(), o2 = 0; o2 < this.vertices.length; o2++)
      this.vertices[o2].X() < t2 && (t2 = this.vertices[o2].X()), this.vertices[o2].X() > s2 && (s2 = this.vertices[o2].X()), this.vertices[o2].Y() > e2 && (e2 = this.vertices[o2].Y()), this.vertices[o2].Y() < r3 && (r3 = this.vertices[o2].Y());
    return new c.Z(i2.Z.COORDS_BY_USER, [0.5 * (t2 + s2), 0.5 * (e2 + r3)], this.board);
  }, getLabelAnchor: t.Z.shortcut(t.Z.Polygon.prototype, "getTextAnchor"), cloneToBackground: function() {
    var t2, e2 = {};
    return e2.id = this.id + "T" + this.numTraces, this.numTraces++, e2.vertices = this.vertices, e2.visProp = s.Z.deepCopy(this.visProp, this.visProp.traceattributes, true), e2.visProp.layer = this.board.options.layer.trace, e2.board = this.board, s.Z.clearVisPropOld(e2), e2.visPropCalc = { visible: s.Z.evaluate(e2.visProp.visible) }, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawPolygon(e2), this.board.renderer.enhancedRendering = t2, this.traces[e2.id] = e2.rendNode, this;
  }, hideElement: function(e2) {
    var i3;
    if (t.Z.deprecated("Element.hideElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = false, this.board.renderer.display(this, false), !e2)
      for (i3 = 0; i3 < this.borders.length; i3++)
        this.borders[i3].hideElement();
    this.hasLabel && s.Z.exists(this.label) && (this.label.hiddenByParent = true, this.label.visPropCalc.visible && this.label.hideElement());
  }, showElement: function(e2) {
    var i3;
    if (t.Z.deprecated("Element.showElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = true, this.board.renderer.display(this, true), !e2)
      for (i3 = 0; i3 < this.borders.length; i3++)
        this.borders[i3].showElement().updateRenderer();
    return s.Z.exists(this.label) && this.hasLabel && this.label.hiddenByParent && (this.label.hiddenByParent = false, this.label.visPropCalc.visible || this.label.showElement().updateRenderer()), this;
  }, Area: function() {
    return Math.abs(u.Z.signedPolygon(this.vertices, true));
  }, Perimeter: function() {
    var t2, e2 = this.vertices.length, i3 = 0;
    for (t2 = 1; t2 < e2; ++t2)
      i3 += this.vertices[t2].Dist(this.vertices[t2 - 1]);
    return i3;
  }, boundingBox: function() {
    var t2, e2, i3 = [0, 0, 0, 0], s2 = this.vertices.length - 1;
    if (0 === s2)
      return i3;
    for (i3[0] = this.vertices[0].X(), i3[2] = i3[0], i3[1] = this.vertices[0].Y(), i3[3] = i3[1], t2 = 1; t2 < s2; ++t2)
      (e2 = this.vertices[t2].X()) < i3[0] ? i3[0] = e2 : e2 > i3[2] && (i3[2] = e2), (e2 = this.vertices[t2].Y()) > i3[1] ? i3[1] = e2 : e2 < i3[3] && (i3[3] = e2);
    return i3;
  }, bounds: function() {
    return this.boundingBox();
  }, remove: function() {
    var t2;
    for (t2 = 0; t2 < this.borders.length; t2++)
      this.board.removeObject(this.borders[t2]);
    J.Z.prototype.remove.call(this);
  }, findPoint: function(t2) {
    var e2;
    if (!s.Z.isPoint(t2))
      return -1;
    for (e2 = 0; e2 < this.vertices.length; e2++)
      if (this.vertices[e2].id === t2.id)
        return e2;
    return -1;
  }, addPoints: function(t2) {
    var e2, i3 = Array.prototype.slice.call(arguments);
    return e2 = "polygonalchain" === this.elType ? this.vertices.length - 1 : this.vertices.length - 2, this.insertPoints.apply(this, [e2].concat(i3));
  }, insertPoints: function(t2, e2) {
    var i3, r3, o2, n2, a2;
    if (0 === arguments.length)
      return this;
    if (o2 = this.vertices.length - 1, "polygon" === this.elType && o2--, t2 < -1 || t2 > o2)
      return this;
    for (r3 = arguments.length - 1, i3 = 1; i3 < r3 + 1; i3++)
      (a2 = s.Z.providePoints(this.board, [arguments[i3]], {}, "polygon", ["vertices"])[0])._is_new && (this.addChild(a2), delete a2._is_new), this.vertices.splice(t2 + i3, 0, a2);
    if (this.withLines)
      for (n2 = t2 + 1, "polygon" === this.elType ? t2 < 0 ? (this.vertices[this.vertices.length - 1] = this.vertices[0], this.borders[this.borders.length - 1].point2 = this.vertices[this.vertices.length - 1]) : this.borders[t2].point2 = this.vertices[n2] : t2 >= 0 && (t2 < this.borders.length ? this.borders[t2].point2 = this.vertices[n2] : n2 = t2), i3 = n2; i3 < n2 + r3; i3++)
        this.borders.splice(i3, 0, this.board.create("segment", [this.vertices[i3], this.vertices[i3 + 1]], this.attr_line));
    return this.inherits = [], this.inherits.push(this.vertices, this.borders), this.board.update(), this;
  }, removePoints: function(t2) {
    var e2, i3, r3, o2, n2 = [], a2 = [], h2 = [], l2 = [];
    for ("polygon" === this.elType && (o2 = this.vertices.pop()), e2 = 0; e2 < arguments.length; e2++)
      r3 = arguments[e2], s.Z.isPoint(r3) && (r3 = this.findPoint(r3)), s.Z.isNumber(r3) && r3 > -1 && r3 < this.vertices.length && -1 === s.Z.indexOf(h2, r3) && h2.push(r3);
    if (0 === h2.length)
      return "polygon" === this.elType && this.vertices.push(o2), this;
    for (e2 = 0; e2 < h2.length; e2++)
      this.vertices[h2[e2]].removeChild(this);
    for (h2 = h2.sort(), n2 = this.vertices.slice(), a2 = this.borders.slice(), this.withLines && l2.push([h2[h2.length - 1]]), e2 = h2.length - 1; e2 > -1; e2--)
      n2[h2[e2]] = -1, this.withLines && h2.length > 1 && h2[e2] - 1 > h2[e2 - 1] && (l2[l2.length - 1][1] = h2[e2], l2.push([h2[e2 - 1]]));
    for (this.withLines && (l2[l2.length - 1][1] = h2[0]), this.vertices = [], e2 = 0; e2 < n2.length; e2++)
      s.Z.isPoint(n2[e2]) && this.vertices.push(n2[e2]);
    if ("polygon" === this.elType && this.vertices.length > 1 && this.vertices[this.vertices.length - 1].id !== this.vertices[0].id && this.vertices.push(this.vertices[0]), this.withLines) {
      for (e2 = 0; e2 < l2.length; e2++) {
        for (i3 = l2[e2][1] - 1; i3 < l2[e2][0] + 1; i3++)
          i3 < 0 ? "polygon" === this.elType && (this.board.removeObject(this.borders[a2.length - 1]), a2[a2.length - 1] = -1) : i3 < a2.length && (this.board.removeObject(this.borders[i3]), a2[i3] = -1);
        0 !== l2[e2][1] && l2[e2][0] !== n2.length - 1 && (a2[l2[e2][0] - 1] = this.board.create("segment", [n2[l2[e2][1] - 1], n2[l2[e2][0] + 1]], this.attr_line));
      }
      for (this.borders = [], e2 = 0; e2 < a2.length; e2++)
        -1 !== a2[e2] && this.borders.push(a2[e2]);
      "polygon" === this.elType && this.vertices.length > 2 && (l2[0][1] === this.vertices.length - 1 || 0 === l2[l2.length - 1][1]) && this.borders.push(this.board.create("segment", [this.vertices[this.vertices.length - 2], this.vertices[0]], this.attr_line));
    }
    return this.inherits = [], this.inherits.push(this.vertices, this.borders), this.board.update(), this;
  }, getParents: function() {
    return this.setParents(this.vertices), this.parents;
  }, getAttributes: function() {
    var t2, e2 = J.Z.prototype.getAttributes.call(this);
    if (this.withLines)
      for (e2.lines = e2.lines || {}, e2.lines.ids = [], e2.lines.colors = [], t2 = 0; t2 < this.borders.length; t2++)
        e2.lines.ids.push(this.borders[t2].id), e2.lines.colors.push(this.borders[t2].visProp.strokecolor);
    return e2;
  }, snapToGrid: function() {
    var t2, e2;
    for (e2 = !!s.Z.evaluate(this.visProp.snaptogrid), t2 = 0; t2 < this.vertices.length; t2++)
      this.vertices[t2].handleSnapToGrid(e2, true);
  }, setPositionDirectly: function(t2, e2, i3) {
    var s2, r3, o2, n2 = new c.Z(t2, e2, this.board), a2 = new c.Z(t2, i3, this.board);
    for (o2 = this.vertices.length - 1, r3 = 0; r3 < o2; r3++)
      if (!this.vertices[r3].draggable())
        return this;
    return s2 = d.Z.subtract(n2.usrCoords, a2.usrCoords), this.board.create("transform", s2.slice(1), { type: "translate" }).applyOnce(this.vertices.slice(0, -1)), this;
  }, sutherlandHodgman: function(e2) {
    var i3, s2, r3, o2, n2, a2, h2, l2 = t.Z.Math.Geometry.sortVertices(this.vertices), c2 = t.Z.Math.Geometry.sortVertices(e2.vertices), d2 = l2.length - 1, u2 = c2.length - 1, p2 = [], _2 = function(t2, e3, i4) {
      return (e3[1] - t2[1]) * (i4[2] - t2[2]) - (e3[2] - t2[2]) * (i4[1] - t2[1]) >= 0;
    };
    for (r3 = 0; r3 < u2; r3++)
      p2.push(c2[r3]);
    for (r3 = 0; r3 < d2; r3++)
      for (s2 = p2.slice(0), p2 = [], n2 = s2[(i3 = s2.length) - 1], o2 = 0; o2 < i3; o2++)
        a2 = s2[o2], _2(l2[r3], l2[r3 + 1], a2) ? (_2(l2[r3], l2[r3 + 1], n2) || ((h2 = t.Z.Math.Geometry.meetSegmentSegment(n2, a2, l2[r3], l2[r3 + 1]))[0][1] /= h2[0][0], h2[0][2] /= h2[0][0], h2[0][0] = 1, p2.push(h2[0])), p2.push(a2)) : _2(l2[r3], l2[r3 + 1], n2) && ((h2 = t.Z.Math.Geometry.meetSegmentSegment(n2, a2, l2[r3], l2[r3 + 1]))[0][1] /= h2[0][0], h2[0][2] /= h2[0][0], h2[0][0] = 1, p2.push(h2[0])), n2 = a2;
    return p2;
  }, intersect: function(t2) {
    return this.sutherlandHodgman(t2);
  } }), t.Z.createPolygon = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2 = [], p2 = false;
    if (s.Z.copyAttributes(o2, e2.options, "polygon"), null === (l2 = e2.select(r3[0])) && (l2 = r3[0]), s.Z.isObject(l2) && l2.type === i2.Z.OBJECT_TYPE_POLYGON && s.Z.isTransformationOrArray(r3[1]))
      for (p2 = true, h2 = l2.vertices.length - 1, d2 = s.Z.copyAttributes(o2, e2.options, "polygon", "vertices"), a2 = 0; a2 < h2; a2++)
        d2.withlabel && (d2.name = "" === l2.vertices[a2].name ? "" : l2.vertices[a2].name + "'"), u2.push(e2.create("point", [l2.vertices[a2], r3[1]], d2));
    else if (false === (u2 = s.Z.providePoints(e2, r3, o2, "polygon", ["vertices"])))
      throw new Error("JSXGraph: Can't create polygon / polygonalchain with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates. Alternatively, a polygon and a transformation can be supplied");
    if (c2 = s.Z.copyAttributes(o2, e2.options, "polygon"), (n2 = new t.Z.Polygon(e2, u2, c2)).isDraggable = true, p2)
      for (n2.prepareUpdate().update().updateVisibility().updateRenderer(), h2 = l2.vertices.length - 1, a2 = 0; a2 < h2; a2++)
        u2[a2].prepareUpdate().update().updateVisibility().updateRenderer();
    return n2;
  }, t.Z.createRegularPolygon = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2 = [];
    if (a2 = e2[(l2 = e2.length) - 1], s.Z.isNumber(a2) && (3 !== e2.length || a2 < 3))
      throw new Error("JSXGraph: A regular polygon needs two point types and a number > 2 as input.");
    if (s.Z.isNumber(t2.select(a2)) ? (l2--, c2 = false) : (a2 = l2, c2 = true), false === (u2 = s.Z.providePoints(t2, e2.slice(0, l2), r3, "regularpolygon", ["vertices"])))
      throw new Error("JSXGraph: Can't create regular polygon with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates");
    for (d2 = s.Z.copyAttributes(r3, t2.options, "regularpolygon", "vertices"), n2 = 2; n2 < a2; n2++)
      h2 = t2.create("transform", [Math.PI * (2 - (a2 - 2) / a2), u2[n2 - 1]], { type: "rotate" }), c2 ? (u2[n2].addTransform(u2[n2 - 2], h2), u2[n2].fullUpdate()) : (s.Z.isArray(d2.ids) && d2.ids.length >= a2 - 2 && (d2.id = d2.ids[n2 - 2]), u2[n2] = t2.create("point", [u2[n2 - 2], h2], d2), u2[n2].type = i2.Z.OBJECT_TYPE_CAS, u2[n2].isDraggable = true, u2[n2].visProp.fixed = false);
    return d2 = s.Z.copyAttributes(r3, t2.options, "regularpolygon"), (o2 = t2.create("polygon", u2, d2)).elType = "regularpolygon", o2;
  }, t.Z.createPolygonalChain = function(t2, e2, i3) {
    var r3, o2;
    return r3 = s.Z.copyAttributes(i3, t2.options, "polygonalchain"), (o2 = t2.create("polygon", e2, r3)).elType = "polygonalchain", o2.vertices.pop(), t2.removeObject(o2.borders[o2.borders.length - 1]), o2.borders.pop(), o2;
  }, t.Z.registerElement("polygon", t.Z.createPolygon), t.Z.registerElement("regularpolygon", t.Z.createRegularPolygon), t.Z.registerElement("polygonalchain", t.Z.createPolygonalChain);
  const W = t.Z.Polygon;
  t.Z.Curve = function(t2, e2, r3) {
    this.constructor(t2, r3, i2.Z.OBJECT_TYPE_CURVE, i2.Z.OBJECT_CLASS_CURVE), this.points = [], this.numberPoints = s.Z.evaluate(this.visProp.numberpointshigh), this.bezierDegree = 1, this.dataX = null, this.dataY = null, this.ticks = [], this.qdt = null, s.Z.exists(e2[0]) ? this.varname = e2[0] : this.varname = "x", this.xterm = e2[1], this.yterm = e2[2], this.generateTerm(this.varname, this.xterm, this.yterm, e2[3], e2[4]), this.updateCurve(), this.id = this.board.setId(this, "G"), this.board.renderer.drawCurve(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "curve", this.createLabel(), s.Z.isString(this.xterm) && this.notifyParents(this.xterm), s.Z.isString(this.yterm) && this.notifyParents(this.yterm), this.methodMap = s.Z.deepCopy(this.methodMap, { generateTerm: "generateTerm", setTerm: "generateTerm", move: "moveTo", moveTo: "moveTo" });
  }, t.Z.Curve.prototype = new J.Z(), t.Z.extend(t.Z.Curve.prototype, { minX: function() {
    return "polar" === s.Z.evaluate(this.visProp.curvetype) ? 0 : new c.Z(i2.Z.COORDS_BY_SCREEN, [0.1 * -this.board.canvasWidth, 0], this.board, false).usrCoords[1];
  }, maxX: function() {
    return "polar" === s.Z.evaluate(this.visProp.curvetype) ? 2 * Math.PI : new c.Z(i2.Z.COORDS_BY_SCREEN, [1.1 * this.board.canvasWidth, 0], this.board, false).usrCoords[1];
  }, X: function(t2) {
    return NaN;
  }, Y: function(t2) {
    return NaN;
  }, Z: function(t2) {
    return 1;
  }, hasPoint: function(t2, e2, r3) {
    var n2, a2, h2, l2, d2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2 = [], O2 = s.Z.evaluate(this.visProp.numberpointslow), x2 = (this.maxX() - this.minX()) / O2, w2 = 1 / 0;
    if (s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (v2 = this.board._inputDevice, m2 = s.Z.evaluate(this.visProp.precision[v2])) : m2 = this.board.options.precision.hasPoint, t2 = (a2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e2], this.board, false)).usrCoords[1], e2 = a2.usrCoords[2], 1 === this.bezierDegree && s.Z.evaluate(this.visProp.hasinnerpoints) && 0 !== u.Z.windingNumber([1, t2, e2], this.points, true))
      return true;
    if (m2 += 0.5 * s.Z.evaluate(this.visProp.strokewidth), m2 *= m2, Z2 = this.board.unitX * this.board.unitX, C2 = this.board.unitY * this.board.unitY, P2 = this.minX(), this.maxX(), s.Z.exists(this._visibleArea) && (P2 = this._visibleArea[0], x2 = (this._visibleArea[1] - P2) / O2), "parameter" === (y2 = s.Z.evaluate(this.visProp.curvetype)) || "polar" === y2)
      for (this.transformations.length > 0 && (this.updateTransformMatrix(), l2 = o.Z.inverse(this.transformMat), t2 = (d2 = o.Z.matVecMult(l2, [1, t2, e2]))[1], e2 = d2[2]), p2 = 0, n2 = P2; p2 < O2; p2++) {
        if ((w2 = (t2 - (_2 = this.X(n2, true))) * (t2 - _2) * Z2 + (e2 - (f2 = this.Y(n2, true))) * (e2 - f2) * C2) <= m2)
          return true;
        n2 += x2;
      }
    else if ("plot" === y2 || "functiongraph" === y2) {
      for ((!s.Z.exists(r3) || r3 < 0) && (r3 = 0), s.Z.exists(this.qdt) && s.Z.evaluate(this.visProp.useqdt) && 3 !== this.bezierDegree ? h2 = (b2 = (g2 = this.qdt.query(new c.Z(i2.Z.COORDS_BY_USER, [t2, e2], this.board))).points).length : (b2 = this.points, h2 = this.numberPoints - 1), p2 = r3; p2 < h2; p2++)
        if (3 === this.bezierDegree ? E2 = u.Z.projectCoordsToBeziersegment([1, t2, e2], this, p2) : g2 ? (b2[p2].prev && (E2 = u.Z.projectCoordsToSegment([1, t2, e2], b2[p2].prev.usrCoords, b2[p2].usrCoords)), b2[p2].next && b2[p2 + 1] !== b2[p2].next && (E2 = u.Z.projectCoordsToSegment([1, t2, e2], b2[p2].usrCoords, b2[p2].next.usrCoords))) : E2 = u.Z.projectCoordsToSegment([1, t2, e2], b2[p2].usrCoords, b2[p2 + 1].usrCoords), E2[1] >= 0 && E2[1] <= 1 && (t2 - E2[0][1]) * (t2 - E2[0][1]) * Z2 + (e2 - E2[0][2]) * (e2 - E2[0][2]) * C2 <= m2)
          return true;
      return false;
    }
    return w2 < m2;
  }, allocatePoints: function() {
    var t2, e2;
    if (e2 = this.numberPoints, this.points.length < this.numberPoints)
      for (t2 = this.points.length; t2 < e2; t2++)
        this.points[t2] = new c.Z(i2.Z.COORDS_BY_USER, [0, 0], this.board, false);
  }, update: function() {
    return this.needsUpdate && (s.Z.evaluate(this.visProp.trace) && this.cloneToBackground(true), this.updateCurve()), this;
  }, updateRenderer: function() {
    return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = p.checkReal(this.points), this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateCurve(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
  }, updateDataArray: function() {
  }, updateCurve: function() {
    var t2, e2, r3, o2, n2, a2, c2 = this.visProp.plotversion, d2 = false;
    if (this.updateTransformMatrix(), this.updateDataArray(), e2 = this.minX(), r3 = this.maxX(), s.Z.exists(this.dataX))
      for (this.numberPoints = this.dataX.length, t2 = this.numberPoints, this.allocatePoints(), a2 = 0; a2 < t2; a2++)
        o2 = a2, s.Z.exists(this.dataY) ? (n2 = a2, this.points[a2].setCoordinates(i2.Z.COORDS_BY_USER, [this.dataX[a2], this.dataY[a2]], false)) : (n2 = this.X(o2), this.points[a2].setCoordinates(i2.Z.COORDS_BY_USER, [this.dataX[a2], this.Y(n2, d2)], false)), this.points[a2]._t = a2, d2 = true;
    else if (s.Z.evaluate(this.visProp.doadvancedplot) ? 1 === c2 || s.Z.evaluate(this.visProp.doadvancedplotold) ? p.updateParametricCurveOld(this, e2, r3) : 2 === c2 ? p.updateParametricCurve_v2(this, e2, r3) : 3 === c2 ? p.updateParametricCurve_v3(this, e2, r3) : 4 === c2 ? p.updateParametricCurve_v4(this, e2, r3) : p.updateParametricCurve_v2(this, e2, r3) : (this.board.updateQuality === this.board.BOARD_QUALITY_HIGH ? this.numberPoints = s.Z.evaluate(this.visProp.numberpointshigh) : this.numberPoints = s.Z.evaluate(this.visProp.numberpointslow), this.allocatePoints(), p.updateParametricCurveNaive(this, e2, r3, this.numberPoints)), t2 = this.numberPoints, s.Z.evaluate(this.visProp.useqdt) && this.board.updateQuality === this.board.BOARD_QUALITY_HIGH)
      for (this.qdt = new h(this.board.getBoundingBox()), a2 = 0; a2 < this.points.length; a2++)
        this.qdt.insert(this.points[a2]), a2 > 0 && (this.points[a2].prev = this.points[a2 - 1]), a2 < t2 - 1 && (this.points[a2].next = this.points[a2 + 1]);
    for ("plot" !== s.Z.evaluate(this.visProp.curvetype) && s.Z.evaluate(this.visProp.rdpsmoothing) && (this.points = l.Z.RamerDouglasPeucker(this.points, 0.2), this.numberPoints = this.points.length), t2 = this.numberPoints, a2 = 0; a2 < t2; a2++)
      this.updateTransform(this.points[a2]);
    return this;
  }, updateTransformMatrix: function() {
    var t2, e2, i3 = this.transformations.length;
    for (this.transformMat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], e2 = 0; e2 < i3; e2++)
      (t2 = this.transformations[e2]).update(), this.transformMat = o.Z.matMatMult(t2.matrix, this.transformMat);
    return this;
  }, updateTransform: function(t2) {
    var e2;
    return this.transformations.length > 0 && (e2 = o.Z.matVecMult(this.transformMat, t2.usrCoords), t2.setCoordinates(i2.Z.COORDS_BY_USER, e2, false, true)), t2;
  }, addTransform: function(t2) {
    var e2, i3 = s.Z.isArray(t2) ? t2 : [t2], r3 = i3.length;
    for (e2 = 0; e2 < r3; e2++)
      this.transformations.push(i3[e2]);
    return this;
  }, interpolationFunctionFromArray: function(t2) {
    var e2 = "data" + t2, i3 = this;
    return function(t3, r3) {
      var o2, n2, a2, h2, l2 = i3[e2], c2 = l2.length, d2 = [];
      if (isNaN(t3))
        return NaN;
      if (t3 < 0)
        return s.Z.isFunction(l2[0]) ? l2[0]() : l2[0];
      if (3 === i3.bezierDegree) {
        if (t3 >= (c2 - 1) / 3)
          return s.Z.isFunction(l2[l2.length - 1]) ? l2[l2.length - 1]() : l2[l2.length - 1];
        for (o2 = 3 * Math.floor(t3), h2 = 1 - (a2 = t3 % 1), n2 = 0; n2 < 4; n2++)
          s.Z.isFunction(l2[o2 + n2]) ? d2[n2] = l2[o2 + n2]() : d2[n2] = l2[o2 + n2];
        return h2 * h2 * (h2 * d2[0] + 3 * a2 * d2[1]) + (3 * h2 * d2[2] + a2 * d2[3]) * a2 * a2;
      }
      if ((o2 = t3 > c2 - 2 ? c2 - 2 : parseInt(Math.floor(t3), 10)) === t3)
        return s.Z.isFunction(l2[o2]) ? l2[o2]() : l2[o2];
      for (n2 = 0; n2 < 2; n2++)
        s.Z.isFunction(l2[o2 + n2]) ? d2[n2] = l2[o2 + n2]() : d2[n2] = l2[o2 + n2];
      return d2[0] + (d2[1] - d2[0]) * (t3 - o2);
    };
  }, generateTerm: function(t2, e2, i3, r3, o2) {
    var n2, a2;
    s.Z.isArray(e2) ? (this.dataX = e2, this.numberPoints = this.dataX.length, this.X = this.interpolationFunctionFromArray.apply(this, ["X"]), this.visProp.curvetype = "plot", this.isDraggable = true) : (this.X = s.Z.createFunction(e2, this.board, t2), s.Z.isString(e2) ? this.visProp.curvetype = "functiongraph" : (s.Z.isFunction(e2) || s.Z.isNumber(e2)) && (this.visProp.curvetype = "parameter"), this.isDraggable = true), s.Z.isArray(i3) ? (this.dataY = i3, this.Y = this.interpolationFunctionFromArray.apply(this, ["Y"])) : this.Y = s.Z.createFunction(i3, this.board, t2), s.Z.isFunction(e2) && s.Z.isArray(i3) && (n2 = s.Z.createFunction(i3[0], this.board, ""), a2 = s.Z.createFunction(i3[1], this.board, ""), this.X = function(t3) {
      return e2(t3) * Math.cos(t3) + n2();
    }, this.X.deps = n2.deps, this.Y = function(t3) {
      return e2(t3) * Math.sin(t3) + a2();
    }, this.Y.deps = a2.deps, this.visProp.curvetype = "polar"), s.Z.exists(r3) && (this.minX = s.Z.createFunction(r3, this.board, "")), s.Z.exists(o2) && (this.maxX = s.Z.createFunction(o2, this.board, "")), this.addParentsFromJCFunctions([this.X, this.Y, this.minX, this.maxX]);
  }, notifyParents: function(t2) {
    var e2, i3, s2, r3 = false;
    for (e2 in s2 = { xterm: 1, yterm: 1 })
      if (s2.hasOwnProperty(e2) && this.hasOwnProperty(e2) && this[e2].origin)
        for (i3 in r3 = true, this[e2].origin.deps)
          this[e2].origin.deps.hasOwnProperty(i3) && this[e2].origin.deps[i3].addChild(this);
    r3 || k.Z.findDependencies(this, t2, this.board);
  }, getLabelAnchor: function() {
    var t2, e2, r3, o2 = 0.05 * this.board.canvasWidth, n2 = 0.05 * this.board.canvasHeight, a2 = 0.95 * this.board.canvasWidth, h2 = 0.95 * this.board.canvasHeight;
    switch (s.Z.evaluate(this.visProp.label.position)) {
      case "ulft":
        e2 = o2, r3 = n2;
        break;
      case "llft":
        e2 = o2, r3 = h2;
        break;
      case "rt":
        e2 = a2, r3 = 0.5 * h2;
        break;
      case "lrt":
        e2 = a2, r3 = h2;
        break;
      case "urt":
        e2 = a2, r3 = n2;
        break;
      case "top":
        e2 = 0.5 * a2, r3 = n2;
        break;
      case "bot":
        e2 = 0.5 * a2, r3 = h2;
        break;
      default:
        e2 = o2, r3 = 0.5 * h2;
    }
    return t2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [e2, r3], this.board, false), u.Z.projectCoordsToCurve(t2.usrCoords[1], t2.usrCoords[2], 0, this, this.board)[0];
  }, cloneToBackground: function() {
    var t2, e2 = { id: this.id + "T" + this.numTraces, elementClass: i2.Z.OBJECT_CLASS_CURVE, points: this.points.slice(0), bezierDegree: this.bezierDegree, numberPoints: this.numberPoints, board: this.board, visProp: s.Z.deepCopy(this.visProp, this.visProp.traceattributes, true) };
    return e2.visProp.layer = this.board.options.layer.trace, e2.visProp.curvetype = this.visProp.curvetype, this.numTraces++, s.Z.clearVisPropOld(e2), e2.visPropCalc = { visible: s.Z.evaluate(e2.visProp.visible) }, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawCurve(e2), this.board.renderer.enhancedRendering = t2, this.traces[e2.id] = e2.rendNode, this;
  }, bounds: function() {
    var t2, e2, i3, r3 = 1 / 0, o2 = -1 / 0, n2 = 1 / 0, a2 = -1 / 0, h2 = this.points.length;
    if (3 === this.bezierDegree) {
      for (t2 = 0; t2 < h2; t2++)
        this.points[t2].X = s.Z.bind(function() {
          return this.usrCoords[1];
        }, this.points[t2]), this.points[t2].Y = s.Z.bind(function() {
          return this.usrCoords[2];
        }, this.points[t2]);
      return i3 = (e2 = l.Z.bezier(this.points))[3](), r3 = l.Z.fminbr(function(t3) {
        return e2[0](t3);
      }, [0, i3]), o2 = l.Z.fminbr(function(t3) {
        return -e2[0](t3);
      }, [0, i3]), n2 = l.Z.fminbr(function(t3) {
        return e2[1](t3);
      }, [0, i3]), a2 = l.Z.fminbr(function(t3) {
        return -e2[1](t3);
      }, [0, i3]), r3 = e2[0](r3), o2 = e2[0](o2), n2 = e2[1](n2), [r3, a2 = e2[1](a2), o2, n2];
    }
    for (t2 = 0; t2 < h2; t2++)
      r3 > this.points[t2].usrCoords[1] && (r3 = this.points[t2].usrCoords[1]), o2 < this.points[t2].usrCoords[1] && (o2 = this.points[t2].usrCoords[1]), n2 > this.points[t2].usrCoords[2] && (n2 = this.points[t2].usrCoords[2]), a2 < this.points[t2].usrCoords[2] && (a2 = this.points[t2].usrCoords[2]);
    return [r3, a2, o2, n2];
  }, getParents: function() {
    var t2 = [this.xterm, this.yterm, this.minX(), this.maxX()];
    return 0 !== this.parents.length && (t2 = this.parents), t2;
  }, moveTo: function(t2) {
    var e2, r3 = [];
    return this.points.length > 0 && !s.Z.evaluate(this.visProp.fixed) && (e2 = this.points[0], r3 = 3 === t2.length ? [t2[0] - e2.usrCoords[0], t2[1] - e2.usrCoords[1], t2[2] - e2.usrCoords[2]] : [t2[0] - e2.usrCoords[1], t2[1] - e2.usrCoords[2]], this.setPosition(i2.Z.COORDS_BY_USER, r3)), this;
  }, getTransformationSource: function() {
    var t2, e2;
    return s.Z.exists(this._transformationSource) && (e2 = this._transformationSource).elementClass === i2.Z.OBJECT_CLASS_CURVE && (t2 = true), [t2, e2];
  }, pnpoly: function(t2, e2, s2) {
    var r3, o2, n2, a2, h2, l2, d2 = this.points, u2 = false;
    for (s2 === i2.Z.COORDS_BY_USER ? (a2 = (l2 = new c.Z(i2.Z.COORDS_BY_USER, [t2, e2], this.board)).scrCoords[1], h2 = l2.scrCoords[2]) : (a2 = t2, h2 = e2), r3 = 0, o2 = (n2 = this.points.length) - 2; r3 < n2 - 1; o2 = r3++)
      d2[r3].scrCoords[2] > h2 != d2[o2].scrCoords[2] > h2 && a2 < (d2[o2].scrCoords[1] - d2[r3].scrCoords[1]) * (h2 - d2[r3].scrCoords[2]) / (d2[o2].scrCoords[2] - d2[r3].scrCoords[2]) + d2[r3].scrCoords[1] && (u2 = !u2);
    return u2;
  } }), t.Z.createCurve = function(e2, r3, o2) {
    var n2, a2, h2 = s.Z.copyAttributes(o2, e2.options, "curve");
    return n2 = e2.select(r3[0], true), s.Z.isTransformationOrArray(r3[1]) && s.Z.isObject(n2) && (n2.type === i2.Z.OBJECT_TYPE_CURVE || n2.type === i2.Z.OBJECT_TYPE_ANGLE || n2.type === i2.Z.OBJECT_TYPE_ARC || n2.type === i2.Z.OBJECT_TYPE_CONIC || n2.type === i2.Z.OBJECT_TYPE_SECTOR) ? (n2.type === i2.Z.OBJECT_TYPE_SECTOR ? h2 = s.Z.copyAttributes(o2, e2.options, "sector") : n2.type === i2.Z.OBJECT_TYPE_ARC ? h2 = s.Z.copyAttributes(o2, e2.options, "arc") : n2.type === i2.Z.OBJECT_TYPE_ANGLE ? (s.Z.exists(o2.withLabel) || (o2.withLabel = false), h2 = s.Z.copyAttributes(o2, e2.options, "angle")) : h2 = s.Z.copyAttributes(o2, e2.options, "curve"), h2 = s.Z.copyAttributes(h2, e2.options, "curve"), (a2 = new t.Z.Curve(e2, ["x", [], []], h2)).updateDataArray = function() {
      var t2, e3 = n2.numberPoints;
      for (this.bezierDegree = n2.bezierDegree, this.dataX = [], this.dataY = [], t2 = 0; t2 < e3; t2++)
        this.dataX.push(n2.points[t2].usrCoords[1]), this.dataY.push(n2.points[t2].usrCoords[2]);
      return this;
    }, a2.addTransform(r3[1]), n2.addChild(a2), a2.setParents([n2]), a2._transformationSource = n2, a2) : (h2 = s.Z.copyAttributes(o2, e2.options, "curve"), new t.Z.Curve(e2, ["x"].concat(r3), h2));
  }, t.Z.registerElement("curve", t.Z.createCurve), t.Z.createFunctiongraph = function(e2, i3, r3) {
    var o2, n2 = ["x", "x"].concat(i3);
    return (o2 = s.Z.copyAttributes(r3, e2.options, "curve")).curvetype = "functiongraph", new t.Z.Curve(e2, n2, o2);
  }, t.Z.registerElement("functiongraph", t.Z.createFunctiongraph), t.Z.registerElement("plot", t.Z.createFunctiongraph), t.Z.createSpline = function(e2, i3, r3) {
    var o2, n2, a2;
    return n2 = function() {
      var t2, e3 = [], r4 = [];
      return [function(o3, n3) {
        var a3, h2, c2;
        if (!n3) {
          if (e3 = [], r4 = [], 2 === i3.length && s.Z.isArray(i3[0]) && s.Z.isArray(i3[1]) && i3[0].length === i3[1].length)
            for (a3 = 0; a3 < i3[0].length; a3++)
              s.Z.isFunction(i3[0][a3]) ? e3.push(i3[0][a3]()) : e3.push(i3[0][a3]), s.Z.isFunction(i3[1][a3]) ? r4.push(i3[1][a3]()) : r4.push(i3[1][a3]);
          else
            for (a3 = 0; a3 < i3.length; a3++)
              if (s.Z.isPoint(i3[a3]))
                e3.push(i3[a3].X()), r4.push(i3[a3].Y());
              else if (s.Z.isArray(i3[a3]) && 2 === i3[a3].length)
                for (h2 = 0; h2 < i3.length; h2++)
                  s.Z.isFunction(i3[h2][0]) ? e3.push(i3[h2][0]()) : e3.push(i3[h2][0]), s.Z.isFunction(i3[h2][1]) ? r4.push(i3[h2][1]()) : r4.push(i3[h2][1]);
              else
                s.Z.isFunction(i3[a3]) && 2 === i3[a3]().length && (c2 = i3[a3](), e3.push(c2[0]), r4.push(c2[1]));
          t2 = l.Z.splineDef(e3, r4);
        }
        return l.Z.splineEval(o3, e3, r4, t2);
      }, function() {
        return e3[0];
      }, function() {
        return e3[e3.length - 1];
      }];
    }, (r3 = s.Z.copyAttributes(r3, e2.options, "curve")).curvetype = "functiongraph", a2 = n2(), (o2 = new t.Z.Curve(e2, ["x", "x", a2[0], a2[1], a2[2]], r3)).setParents(i3), o2.elType = "spline", o2;
  }, t.Z.registerElement("spline", t.Z.createSpline), t.Z.createCardinalSpline = function(e2, i3, r3) {
    var o2, n2, a2, h2, c2, d2, u2, p2, _2, f2, b2 = "\nPossible parent types: [points:array, tau:number|function, type:string]";
    if (!s.Z.exists(i3[0]) || !s.Z.isArray(i3[0]))
      throw new Error("JSXGraph: JXG.createCardinalSpline: argument 1 'points' has to be array of points or coordinate pairs" + b2);
    if (!s.Z.exists(i3[1]) || !s.Z.isNumber(i3[1]) && !s.Z.isFunction(i3[1]))
      throw new Error("JSXGraph: JXG.createCardinalSpline: argument 2 'tau' has to be number between [0,1] or function'" + b2);
    if (!s.Z.exists(i3[2]) || !s.Z.isString(i3[2]))
      throw new Error("JSXGraph: JXG.createCardinalSpline: argument 3 'type' has to be string 'uniform' or 'centripetal'" + b2);
    if (r3 = s.Z.copyAttributes(r3, e2.options, "curve"), (r3 = s.Z.copyAttributes(r3, e2.options, "cardinalspline")).curvetype = "parameter", d2 = i3[0], u2 = [], !r3.isarrayofcoordinates && 2 === d2.length && s.Z.isArray(d2[0]) && s.Z.isArray(d2[1]) && d2[0].length === d2[1].length)
      for (p2 = 0; p2 < d2[0].length; p2++)
        u2[p2] = [], s.Z.isFunction(d2[0][p2]) ? u2[p2].push(d2[0][p2]()) : u2[p2].push(d2[0][p2]), s.Z.isFunction(d2[1][p2]) ? u2[p2].push(d2[1][p2]()) : u2[p2].push(d2[1][p2]);
    else
      for (p2 = 0; p2 < d2.length; p2++)
        s.Z.isString(d2[p2]) ? u2.push(e2.select(d2[p2])) : s.Z.isPoint(d2[p2]) ? u2.push(d2[p2]) : s.Z.isArray(d2[p2]) && 2 === d2[p2].length ? (u2[p2] = [], s.Z.isFunction(d2[p2][0]) ? u2[p2].push(d2[p2][0]()) : u2[p2].push(d2[p2][0]), s.Z.isFunction(d2[p2][1]) ? u2[p2].push(d2[p2][1]()) : u2[p2].push(d2[p2][1])) : s.Z.isFunction(d2[p2]) && 2 === d2[p2]().length && u2.push(i3[p2]());
    if (true === r3.createpoints)
      a2 = s.Z.providePoints(e2, u2, r3, "cardinalspline", ["points"]);
    else
      for (a2 = [], n2 = function(t2) {
        return { X: function() {
          return u2[t2][0];
        }, Y: function() {
          return u2[t2][1];
        }, Dist: function(t3) {
          var e3 = this.X() - t3.X(), i4 = this.Y() - t3.Y();
          return Math.sqrt(e3 * e3 + i4 * i4);
        } };
      }, p2 = 0; p2 < u2.length; p2++)
        s.Z.isPoint(u2[p2]) ? a2.push(u2[p2]) : a2.push(n2(p2));
    for (h2 = i3[1], c2 = i3[2], f2 = ["x"].concat(l.Z.CardinalSpline(a2, h2, c2)), o2 = new t.Z.Curve(e2, f2, r3), _2 = a2.length, o2.setParents(a2), p2 = 0; p2 < _2; p2++)
      d2 = a2[p2], s.Z.isPoint(d2) && (s.Z.exists(d2._is_new) ? (o2.addChild(d2), delete d2._is_new) : d2.addChild(o2));
    return o2.elType = "cardinalspline", o2;
  }, t.Z.registerElement("cardinalspline", t.Z.createCardinalSpline), t.Z.createMetapostSpline = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2 = "\nPossible parent types: [points:array, controls:object";
    if (!s.Z.exists(i3[0]) || !s.Z.isArray(i3[0]))
      throw new Error("JSXGraph: JXG.createMetapostSpline: argument 1 'points' has to be array of points or coordinate pairs" + p2);
    if (!s.Z.exists(i3[1]) || !s.Z.isObject(i3[1]))
      throw new Error("JSXGraph: JXG.createMetapostSpline: argument 2 'controls' has to be a JavaScript object'" + p2);
    if (r3 = s.Z.copyAttributes(r3, e2.options, "curve"), (r3 = s.Z.copyAttributes(r3, e2.options, "metapostspline")).curvetype = "parameter", l2 = i3[0], c2 = [], !r3.isarrayofcoordinates && 2 === l2.length && s.Z.isArray(l2[0]) && s.Z.isArray(l2[1]) && l2[0].length === l2[1].length)
      for (d2 = 0; d2 < l2[0].length; d2++)
        c2[d2] = [], s.Z.isFunction(l2[0][d2]) ? c2[d2].push(l2[0][d2]()) : c2[d2].push(l2[0][d2]), s.Z.isFunction(l2[1][d2]) ? c2[d2].push(l2[1][d2]()) : c2[d2].push(l2[1][d2]);
    else
      for (d2 = 0; d2 < l2.length; d2++)
        s.Z.isString(l2[d2]) ? c2.push(e2.select(l2[d2])) : s.Z.isPoint(l2[d2]) ? c2.push(l2[d2]) : s.Z.isArray(l2[d2]) && 2 === l2[d2].length ? (c2[d2] = [], s.Z.isFunction(l2[d2][0]) ? c2[d2].push(l2[d2][0]()) : c2[d2].push(l2[d2][0]), s.Z.isFunction(l2[d2][1]) ? c2[d2].push(l2[d2][1]()) : c2[d2].push(l2[d2][1])) : s.Z.isFunction(l2[d2]) && 2 === l2[d2]().length && c2.push(i3[d2]());
    if (true === r3.createpoints)
      a2 = s.Z.providePoints(e2, c2, r3, "metapostspline", ["points"]);
    else
      for (a2 = [], n2 = function(t2) {
        return { X: function() {
          return c2[t2][0];
        }, Y: function() {
          return c2[t2][1];
        } };
      }, d2 = 0; d2 < c2.length; d2++)
        s.Z.isPoint(c2[d2]) ? a2.push(c2[d2]) : a2.push(n2);
    for (h2 = i3[1], (o2 = new t.Z.Curve(e2, ["t", [], [], 0, l2.length - 1], r3)).updateDataArray = function() {
      var e3, i4, s2 = a2.length, r4 = [];
      for (i4 = 0; i4 < s2; i4++)
        r4.push([a2[i4].X(), a2[i4].Y()]);
      e3 = t.Z.Math.Metapost.curve(r4, h2), this.dataX = e3[0], this.dataY = e3[1];
    }, o2.bezierDegree = 3, u2 = a2.length, o2.setParents(a2), d2 = 0; d2 < u2; d2++)
      s.Z.isPoint(a2[d2]) && a2[d2].addChild(o2);
    return o2.elType = "metapostspline", o2;
  }, t.Z.registerElement("metapostspline", t.Z.createMetapostSpline), t.Z.createRiemannsum = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, c2;
    if ((c2 = s.Z.copyAttributes(i3, t2.options, "riemannsum")).curvetype = "plot", n2 = e2[0], r3 = s.Z.createFunction(e2[1], t2, ""), !s.Z.exists(r3))
      throw new Error("JSXGraph: JXG.createRiemannsum: argument '2' n has to be number or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");
    if (o2 = s.Z.createFunction(e2[2], t2, "", false), !s.Z.exists(o2))
      throw new Error("JSXGraph: JXG.createRiemannsum: argument 3 'type' has to be string or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");
    return a2 = [[0], [0]].concat(e2.slice(3)), (h2 = t2.create("curve", a2, c2)).sum = 0, h2.Value = function() {
      return this.sum;
    }, h2.updateDataArray = function() {
      var t3 = l.Z.riemann(n2, r3(), o2(), this.minX(), this.maxX());
      this.dataX = t3[0], this.dataY = t3[1], this.sum = t3[2];
    }, h2.addParentsFromJCFunctions([r3, o2]), h2;
  }, t.Z.registerElement("riemannsum", t.Z.createRiemannsum), t.Z.createTracecurve = function(t2, e2, r3) {
    var o2, n2, a2, h2;
    if (2 !== e2.length)
      throw new Error("JSXGraph: Can't create trace curve with given parent'\nPossible parent types: [glider, point]");
    if (n2 = t2.select(e2[0]), a2 = t2.select(e2[1]), n2.type !== i2.Z.OBJECT_TYPE_GLIDER || !s.Z.isPoint(a2))
      throw new Error("JSXGraph: Can't create trace curve with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [glider, point]");
    return (h2 = s.Z.copyAttributes(r3, t2.options, "tracecurve")).curvetype = "plot", (o2 = t2.create("curve", [[0], [0]], h2)).updateDataArray = function() {
      var t3, e3, s2, r4, o3, l2, c2, d2, u2, p2 = h2.numberpoints, _2 = n2.position, f2 = n2.slideObject, b2 = f2.minX();
      for (e3 = (f2.maxX() - b2) / p2, this.dataX = [], this.dataY = [], f2.elementClass !== i2.Z.OBJECT_CLASS_CURVE && p2++, t3 = 0; t3 < p2; t3++) {
        for (r4 in s2 = b2 + t3 * e3, l2 = f2.X(s2) / f2.Z(s2), c2 = f2.Y(s2) / f2.Z(s2), n2.setPositionDirectly(i2.Z.COORDS_BY_USER, [l2, c2]), d2 = false, this.board.objects)
          if (this.board.objects.hasOwnProperty(r4) && ((o3 = this.board.objects[r4]) === n2 && (d2 = true), d2 && o3.needsRegularUpdate && (u2 = o3.visProp.trace, o3.visProp.trace = false, o3.needsUpdate = true, o3.update(true), o3.visProp.trace = u2, o3 === a2)))
            break;
        this.dataX[t3] = a2.X(), this.dataY[t3] = a2.Y();
      }
      for (r4 in n2.position = _2, d2 = false, this.board.objects)
        if (this.board.objects.hasOwnProperty(r4) && ((o3 = this.board.objects[r4]) === n2 && (d2 = true), d2 && o3.needsRegularUpdate && (u2 = o3.visProp.trace, o3.visProp.trace = false, o3.needsUpdate = true, o3.update(true), o3.visProp.trace = u2, o3 === a2)))
          break;
    }, o2;
  }, t.Z.registerElement("tracecurve", t.Z.createTracecurve), t.Z.createStepfunction = function(t2, e2, i3) {
    var r3, o2;
    if (2 !== e2.length)
      throw new Error("JSXGraph: Can't create step function with given parent'\nPossible parent types: [array, array|function]");
    return o2 = s.Z.copyAttributes(i3, t2.options, "stepfunction"), (r3 = t2.create("curve", e2, o2)).updateDataArray = function() {
      var t3, e3 = 0, i4 = this.xterm.length;
      if (this.dataX = [], this.dataY = [], 0 !== i4)
        for (this.dataX[e3] = this.xterm[0], this.dataY[e3] = this.yterm[0], ++e3, t3 = 1; t3 < i4; ++t3)
          this.dataX[e3] = this.xterm[t3], this.dataY[e3] = this.dataY[e3 - 1], ++e3, this.dataX[e3] = this.xterm[t3], this.dataY[e3] = this.yterm[t3], ++e3;
    }, r3;
  }, t.Z.registerElement("stepfunction", t.Z.createStepfunction), t.Z.createDerivative = function(t2, e2, r3) {
    var o2, n2, a2, h2, c2;
    if (1 !== e2.length && e2[0].class !== i2.Z.OBJECT_CLASS_CURVE)
      throw new Error("JSXGraph: Can't create derivative curve with given parent'\nPossible parent types: [curve]");
    return c2 = s.Z.copyAttributes(r3, t2.options, "curve"), n2 = e2[0], a2 = l.Z.D(n2.X), h2 = l.Z.D(n2.Y), (o2 = t2.create("curve", [function(t3) {
      return n2.X(t3);
    }, function(t3) {
      return h2(t3) / a2(t3);
    }, n2.minX(), n2.maxX()], c2)).setParents(n2), o2;
  }, t.Z.registerElement("derivative", t.Z.createDerivative), t.Z.createCurveIntersection = function(e2, i3, s2) {
    var r3;
    if (2 !== i3.length)
      throw new Error("JSXGraph: Can't create curve intersection with given parent'\nPossible parent types: [array, array|function]");
    return (r3 = e2.create("curve", [[], []], s2)).updateDataArray = function() {
      var e3 = t.Z.Math.Clip.intersection(i3[0], i3[1], this.board);
      this.dataX = e3[0], this.dataY = e3[1];
    }, r3;
  }, t.Z.createCurveUnion = function(e2, i3, s2) {
    var r3;
    if (2 !== i3.length)
      throw new Error("JSXGraph: Can't create curve union with given parent'\nPossible parent types: [array, array|function]");
    return (r3 = e2.create("curve", [[], []], s2)).updateDataArray = function() {
      var e3 = t.Z.Math.Clip.union(i3[0], i3[1], this.board);
      this.dataX = e3[0], this.dataY = e3[1];
    }, r3;
  }, t.Z.createCurveDifference = function(e2, i3, s2) {
    var r3;
    if (2 !== i3.length)
      throw new Error("JSXGraph: Can't create curve difference with given parent'\nPossible parent types: [array, array|function]");
    return (r3 = e2.create("curve", [[], []], s2)).updateDataArray = function() {
      var e3 = t.Z.Math.Clip.difference(i3[0], i3[1], this.board);
      this.dataX = e3[0], this.dataY = e3[1];
    }, r3;
  }, t.Z.registerElement("curvedifference", t.Z.createCurveDifference), t.Z.registerElement("curveintersection", t.Z.createCurveIntersection), t.Z.registerElement("curveunion", t.Z.createCurveUnion), t.Z.createBoxPlot = function(t2, e2, i3) {
    var r3, o2, n2, a2 = s.Z.copyAttributes(i3, t2.options, "boxplot");
    if (3 !== e2.length)
      throw new Error("JSXGraph: Can't create box plot with given parent'\nPossible parent types: [array, number|function, number|function] containing quantiles, axis, width");
    if (e2[0].length < 5)
      throw new Error("JSXGraph: Can't create box plot with given parent[0]'\nparent[0] has to conatin at least 5 quantiles.");
    for (r3 = t2.create("curve", [[], []], a2), n2 = e2[0].length, r3.Q = [], o2 = 0; o2 < n2; o2++)
      r3.Q[o2] = s.Z.createFunction(e2[0][o2], t2, null, true);
    return r3.x = s.Z.createFunction(e2[1], t2, null, true), r3.w = s.Z.createFunction(e2[2], t2, null, true), r3.updateDataArray = function() {
      var t3, e3, i4, r4, o3, n3, a3, h2, l2;
      a3 = s.Z.evaluate(this.visProp.smallwidth), h2 = s.Z.evaluate(this.visProp.dir), i4 = (l2 = this.x()) - 0.5 * this.w(), r4 = l2 - 0.5 * this.w() * a3, o3 = l2 + 0.5 * this.w(), t3 = [l2, r4, n3 = l2 + 0.5 * this.w() * a3, l2, l2, i4, i4, o3, o3, l2, NaN, i4, o3, NaN, l2, l2, r4, n3, l2], e3 = [this.Q[0](), this.Q[0](), this.Q[0](), this.Q[0](), this.Q[1](), this.Q[1](), this.Q[3](), this.Q[3](), this.Q[1](), this.Q[1](), NaN, this.Q[2](), this.Q[2](), NaN, this.Q[3](), this.Q[4](), this.Q[4](), this.Q[4](), this.Q[4]()], "vertical" === h2 ? (this.dataX = t3, this.dataY = e3) : (this.dataX = e3, this.dataY = t3);
    }, r3.addParentsFromJCFunctions([r3.Q, r3.x, r3.w]), r3;
  }, t.Z.registerElement("boxplot", t.Z.createBoxPlot);
  t.Z.Curve;
  t.Z.createArc = function(e2, r3, n2) {
    var a2, h2, l2;
    if (false === (l2 = s.Z.providePoints(e2, r3, n2, "arc", ["center", "radiusPoint", "anglePoint"])) || l2.length < 3)
      throw new Error("JSXGraph: Can't create Arc with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "' and '" + typeof r3[2] + "'.\nPossible parent types: [point,point,point], [arc, transformation]");
    return h2 = s.Z.copyAttributes(n2, e2.options, "arc"), (a2 = e2.create("curve", [[0], [0]], h2)).elType = "arc", a2.setParents(l2), a2.type = i2.Z.OBJECT_TYPE_ARC, a2.center = l2[0], a2.radiuspoint = l2[1], a2.point2 = a2.radiuspoint, a2.anglepoint = l2[2], a2.point3 = a2.anglepoint, s.Z.exists(a2.center._is_new) ? (a2.addChild(a2.center), delete a2.center._is_new) : a2.center.addChild(a2), s.Z.exists(a2.radiuspoint._is_new) ? (a2.addChild(a2.radiuspoint), delete a2.radiuspoint._is_new) : a2.radiuspoint.addChild(a2), s.Z.exists(a2.anglepoint._is_new) ? (a2.addChild(a2.anglepoint), delete a2.anglepoint._is_new) : a2.anglepoint.addChild(a2), a2.useDirection = h2.usedirection, a2.updateDataArray = function() {
      var t2, e3, i3, r4, o2, n3 = 1, a3 = this.radiuspoint, h3 = this.center, c2 = this.anglepoint, d2 = s.Z.evaluate(this.visProp.selection);
      e3 = u.Z.rad(a3, h3, c2), ("minor" === d2 && e3 > Math.PI || "major" === d2 && e3 < Math.PI) && (n3 = -1), this.useDirection && (i3 = l2[1].coords.usrCoords, r4 = l2[3].coords.usrCoords, o2 = l2[2].coords.usrCoords, (i3[1] - o2[1]) * (i3[2] - r4[2]) - (i3[2] - o2[2]) * (i3[1] - r4[1]) < 0 ? (this.radiuspoint = l2[1], this.anglepoint = l2[2]) : (this.radiuspoint = l2[2], this.anglepoint = l2[1])), a3 = a3.coords.usrCoords, h3 = h3.coords.usrCoords, c2 = c2.coords.usrCoords, t2 = u.Z.bezierArc(a3, h3, c2, false, n3), this.dataX = t2[0], this.dataY = t2[1], this.bezierDegree = 3, this.updateStdform(), this.updateQuadraticform();
    }, a2.Radius = function() {
      return this.radiuspoint.Dist(this.center);
    }, a2.getRadius = function() {
      return t.Z.deprecated("Arc.getRadius()", "Arc.Radius()"), this.Radius();
    }, a2.Value = function() {
      return this.Radius() * u.Z.rad(this.radiuspoint, this.center, this.anglepoint);
    }, a2.hasPoint = function(t2, e3) {
      var r4, n3, a3, h3, l3, d2, p2, _2 = this.Radius();
      return s.Z.evaluate(this.visProp.hasinnerpoints) ? this.hasPointSector(t2, e3) : (s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (p2 = this.board._inputDevice, d2 = s.Z.evaluate(this.visProp.precision[p2])) : d2 = this.board.options.precision.hasPoint, d2 /= Math.min(this.board.unitX, this.board.unitY), n3 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e3], this.board), this.transformations.length > 0 && (this.updateTransformMatrix(), h3 = o.Z.inverse(this.transformMat), l3 = o.Z.matVecMult(h3, n3.usrCoords), n3 = new c.Z(i2.Z.COORDS_BY_USER, l3, this.board)), r4 = this.center.coords.distance(i2.Z.COORDS_BY_USER, n3), (a3 = Math.abs(r4 - _2) < d2) && (a3 = u.Z.coordsOnArc(this, n3)), a3);
    }, a2.hasPointSector = function(t2, e3) {
      var s2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e3], this.board), r4 = this.Radius(), o2 = this.center.coords.distance(i2.Z.COORDS_BY_USER, s2) < r4;
      return o2 && (o2 = u.Z.coordsOnArc(this, s2)), o2;
    }, a2.getTextAnchor = function() {
      return this.center.coords;
    }, a2.getLabelAnchor = function() {
      var t2, e3, r4, o2, n3, a3 = u.Z.rad(this.radiuspoint, this.center, this.anglepoint), h3 = 10 / this.board.unitX, l3 = 10 / this.board.unitY, d2 = this.point2.coords.usrCoords, p2 = this.center.coords.usrCoords, _2 = d2[1] - p2[1], f2 = d2[2] - p2[2], b2 = s.Z.evaluate(this.visProp.selection), g2 = this.label ? this.label.visProp : this.visProp.label;
      return ("minor" === b2 && a3 > Math.PI || "major" === b2 && a3 < Math.PI) && (a3 = -(2 * Math.PI - a3)), r4 = (t2 = new c.Z(i2.Z.COORDS_BY_USER, [p2[1] + Math.cos(0.5 * a3) * _2 - Math.sin(0.5 * a3) * f2, p2[2] + Math.sin(0.5 * a3) * _2 + Math.cos(0.5 * a3) * f2], this.board)).usrCoords[1] - p2[1], o2 = t2.usrCoords[2] - p2[2], r4 = r4 * ((n3 = Math.sqrt(r4 * r4 + o2 * o2)) + h3) / n3, o2 = o2 * (n3 + l3) / n3, e3 = [p2[1] + r4, p2[2] + o2], g2.position = u.Z.calcLabelQuadrant(u.Z.rad([1, 0], [0, 0], e3)), new c.Z(i2.Z.COORDS_BY_USER, e3, this.board);
    }, a2.updateQuadraticform = H.prototype.updateQuadraticform, a2.updateStdform = H.prototype.updateStdform, a2.methodMap = t.Z.deepCopy(a2.methodMap, { getRadius: "getRadius", radius: "Radius", center: "center", radiuspoint: "radiuspoint", anglepoint: "anglepoint", Value: "Value" }), a2.prepareUpdate().update(), a2;
  }, t.Z.registerElement("arc", t.Z.createArc), t.Z.createSemicircle = function(t2, e2, i3) {
    var r3, o2, n2, a2;
    if (false === (a2 = s.Z.providePoints(t2, e2, i3, "point")) || 2 !== a2.length)
      throw new Error("JSXGraph: Can't create Semicircle with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,point]");
    return n2 = s.Z.copyAttributes(i3, t2.options, "semicircle", "center"), (o2 = t2.create("midpoint", a2, n2)).dump = false, n2 = s.Z.copyAttributes(i3, t2.options, "semicircle"), (r3 = t2.create("arc", [o2, a2[1], a2[0]], n2)).elType = "semicircle", r3.setParents([a2[0].id, a2[1].id]), r3.subs = { midpoint: o2 }, r3.inherits.push(o2), r3.midpoint = r3.center = o2, r3;
  }, t.Z.registerElement("semicircle", t.Z.createSemicircle), t.Z.createCircumcircleArc = function(t2, e2, i3) {
    var r3, o2, n2, a2;
    if (false === (a2 = s.Z.providePoints(t2, e2, i3, "point")) || 3 !== a2.length)
      throw new Error("JSXGraph: create Circumcircle Arc with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.\nPossible parent types: [point,point,point]");
    return n2 = s.Z.copyAttributes(i3, t2.options, "circumcirclearc", "center"), (o2 = t2.create("circumcenter", a2, n2)).dump = false, (n2 = s.Z.copyAttributes(i3, t2.options, "circumcirclearc")).usedirection = true, (r3 = t2.create("arc", [o2, a2[0], a2[2], a2[1]], n2)).elType = "circumcirclearc", r3.setParents([a2[0].id, a2[1].id, a2[2].id]), r3.subs = { center: o2 }, r3.inherits.push(o2), r3.center = o2, r3;
  }, t.Z.registerElement("circumcirclearc", t.Z.createCircumcircleArc), t.Z.createMinorArc = function(e2, i3, s2) {
    return s2.selection = "minor", t.Z.createArc(e2, i3, s2);
  }, t.Z.registerElement("minorarc", t.Z.createMinorArc), t.Z.createMajorArc = function(e2, i3, s2) {
    return s2.selection = "major", t.Z.createArc(e2, i3, s2);
  }, t.Z.registerElement("majorarc", t.Z.createMajorArc), t.Z.createSector = function(e2, r3, n2) {
    var a2, h2, l2, p2, _2, f2, b2 = "invalid";
    if (r3[0].elementClass === i2.Z.OBJECT_CLASS_LINE && r3[1].elementClass === i2.Z.OBJECT_CLASS_LINE && (s.Z.isArray(r3[2]) || s.Z.isNumber(r3[2])) && (s.Z.isArray(r3[3]) || s.Z.isNumber(r3[3])) && (s.Z.isNumber(r3[4]) || s.Z.isFunction(r3[4]) || s.Z.isString(r3[4])))
      b2 = "2lines";
    else {
      if (false === (f2 = s.Z.providePoints(e2, r3, n2, "sector", ["center", "radiusPoint", "anglePoint"])))
        throw new Error("JSXGraph: Can't create Sector with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "' and '" + typeof r3[2] + "'.");
      b2 = "3points";
    }
    if (h2 = s.Z.copyAttributes(n2, e2.options, "sector"), (a2 = e2.create("curve", [[0], [0]], h2)).type = i2.Z.OBJECT_TYPE_SECTOR, a2.elType = "sector", a2.autoRadius = function() {
      var t2 = 20 / a2.board.unitX, e3 = 1 / 0, i3 = 50 / a2.board.unitX;
      return s.Z.isPoint(a2.center) && (e3 = 0.3333 * a2.center.Dist(a2.point2)), Math.max(t2, Math.min(e3, i3));
    }, "2lines" === b2)
      a2.Radius = function() {
        var t2 = s.Z.evaluate(r3[4]);
        return "auto" === t2 ? this.autoRadius() : t2;
      }, a2.line1 = e2.select(r3[0]), a2.line2 = e2.select(r3[1]), a2.line1.addChild(a2), a2.line2.addChild(a2), a2.setParents(r3), a2.point1 = { visProp: {} }, a2.point2 = { visProp: {} }, a2.point3 = { visProp: {} }, p2 = u.Z.meetLineLine(a2.line1.stdform, a2.line2.stdform, 0, e2), s.Z.isArray(r3[2]) ? (2 === r3[2].length && (r3[2] = [1].concat(r3[2])), _2 = u.Z.projectPointToLine({ coords: { usrCoords: r3[2] } }, a2.line1, e2), _2 = d.Z.subtract(_2.usrCoords, p2.usrCoords), a2.direction1 = o.Z.innerProduct(_2, [0, a2.line1.stdform[2], -a2.line1.stdform[1]], 3) >= 0 ? 1 : -1) : a2.direction1 = r3[2] >= 0 ? 1 : -1, s.Z.isArray(r3[3]) ? (2 === r3[3].length && (r3[3] = [1].concat(r3[3])), _2 = u.Z.projectPointToLine({ coords: { usrCoords: r3[3] } }, a2.line2, e2), _2 = d.Z.subtract(_2.usrCoords, p2.usrCoords), a2.direction2 = o.Z.innerProduct(_2, [0, a2.line2.stdform[2], -a2.line2.stdform[1]], 3) >= 0 ? 1 : -1) : a2.direction2 = r3[3] >= 0 ? 1 : -1, a2.updateDataArray = function() {
        var t2, e3, s2, r4, n3, h3, l3 = [0, 0, 0];
        if (e3 = this.line1, s2 = this.line2, l3 = o.Z.crossProduct(e3.stdform, s2.stdform), Math.abs(l3[0]) > o.Z.eps * o.Z.eps && (l3[1] /= l3[0], l3[2] /= l3[0], l3[0] /= l3[0]), t2 = this.direction1 * this.Radius(), r4 = d.Z.add(l3, [0, t2 * e3.stdform[2], -t2 * e3.stdform[1]]), t2 = this.direction2 * this.Radius(), n3 = d.Z.add(l3, [0, t2 * s2.stdform[2], -t2 * s2.stdform[1]]), this.point2.coords = new c.Z(i2.Z.COORDS_BY_USER, r4, a2.board), this.point1.coords = new c.Z(i2.Z.COORDS_BY_USER, l3, a2.board), this.point3.coords = new c.Z(i2.Z.COORDS_BY_USER, n3, a2.board), Math.abs(r4[0]) < o.Z.eps || Math.abs(l3[0]) < o.Z.eps || Math.abs(n3[0]) < o.Z.eps)
          return this.dataX = [NaN], void (this.dataY = [NaN]);
        h3 = u.Z.bezierArc(r4, l3, n3, true, 1), this.dataX = h3[0], this.dataY = h3[1], this.bezierDegree = 3;
      }, a2.methodMap = t.Z.deepCopy(a2.methodMap, { radius: "Radius", getRadius: "Radius", setRadius: "setRadius" });
    else if ("3points" === b2) {
      for (a2.point1 = f2[0], a2.point2 = f2[1], a2.point3 = f2[2], l2 = 0; l2 < 3; l2++)
        s.Z.exists(f2[l2]._is_new) ? (a2.addChild(f2[l2]), delete f2[l2]._is_new) : f2[l2].addChild(a2);
      a2.useDirection = n2.usedirection, a2.setParents(f2), s.Z.exists(f2[3]) && (a2.point4 = f2[3], a2.point4.addChild(a2)), a2.methodMap = t.Z.deepCopy(a2.methodMap, { arc: "arc", center: "center", radiuspoint: "radiuspoint", anglepoint: "anglepoint", radius: "Radius", getRadius: "Radius", setRadius: "setRadius" }), a2.updateDataArray = function() {
        var t2, e3, i3, r4, o2, n3 = this.point2, a3 = this.point1, h3 = this.point3, l3 = 1, c2 = s.Z.evaluate(this.visProp.selection);
        if (!n3.isReal || !a3.isReal || !h3.isReal)
          return this.dataX = [NaN], void (this.dataY = [NaN]);
        o2 = u.Z.rad(n3, a3, h3), ("minor" === c2 && o2 > Math.PI || "major" === c2 && o2 < Math.PI) && (l3 = -1), this.useDirection && s.Z.exists(this.point4) && (e3 = this.point2.coords.usrCoords, i3 = this.point4.coords.usrCoords, r4 = this.point3.coords.usrCoords, (e3[1] - r4[1]) * (e3[2] - i3[2]) - (e3[2] - r4[2]) * (e3[1] - i3[1]) >= 0 && (h3 = this.point2, n3 = this.point3)), n3 = n3.coords.usrCoords, a3 = a3.coords.usrCoords, h3 = h3.coords.usrCoords, t2 = u.Z.bezierArc(n3, a3, h3, true, l3), this.dataX = t2[0], this.dataY = t2[1], this.bezierDegree = 3;
      }, a2.Radius = function() {
        return this.point2.Dist(this.point1);
      }, (h2 = s.Z.copyAttributes(n2, e2.options, "sector", "arc")).withLabel = false, h2.name += "_arc", a2.arc = e2.create("arc", [a2.point1, a2.point2, a2.point3], h2), a2.addChild(a2.arc);
    }
    return a2.center = a2.point1, a2.radiuspoint = a2.point2, a2.anglepoint = a2.point3, a2.hasPointCurve = function(t2, e3) {
      var r4, o2, n3, a3, h3, l3, d2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e3], this.board), p3 = this.Radius(), _3 = this.center.coords.distance(i2.Z.COORDS_BY_USER, d2), f3 = s.Z.evaluate(this.visProp.selection);
      return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (h3 = this.board._inputDevice, a3 = s.Z.evaluate(this.visProp.precision[h3])) : a3 = this.board.options.precision.hasPoint, a3 /= Math.min(this.board.unitX, this.board.unitY), (l3 = Math.abs(_3 - p3) < a3) && (r4 = u.Z.rad(this.point2, this.center, d2.usrCoords.slice(1)), o2 = 0, n3 = u.Z.rad(this.point2, this.center, this.point3), ("minor" === f3 && n3 > Math.PI || "major" === f3 && n3 < Math.PI) && (o2 = n3, n3 = 2 * Math.PI), (r4 < o2 || r4 > n3) && (l3 = false)), l3;
    }, a2.hasPointSector = function(t2, e3) {
      var r4, o2, n3, a3 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e3], this.board), h3 = this.Radius(), l3 = this.point1.coords.distance(i2.Z.COORDS_BY_USER, a3) < h3, d2 = s.Z.evaluate(this.visProp.selection);
      return l3 && (r4 = u.Z.rad(this.radiuspoint, this.center, a3.usrCoords.slice(1)), o2 = 0, n3 = u.Z.rad(this.radiuspoint, this.center, this.anglepoint), ("minor" === d2 && n3 > Math.PI || "major" === d2 && n3 < Math.PI) && (o2 = n3, n3 = 2 * Math.PI), (r4 < o2 || r4 > n3) && (l3 = false)), l3;
    }, a2.hasPoint = function(t2, e3) {
      return s.Z.evaluate(this.visProp.highlightonsector) || s.Z.evaluate(this.visProp.hasinnerpoints) ? this.hasPointSector(t2, e3) : this.hasPointCurve(t2, e3);
    }, a2.getTextAnchor = function() {
      return this.point1.coords;
    }, a2.getLabelAnchor = function() {
      var t2, e3, r4, o2, n3, a3 = u.Z.rad(this.point2, this.point1, this.point3), h3 = 13 / this.board.unitX, l3 = 13 / this.board.unitY, d2 = this.point2.coords.usrCoords, p3 = this.point1.coords.usrCoords, _3 = d2[1] - p3[1], f3 = d2[2] - p3[2], b3 = s.Z.evaluate(this.visProp.selection), g2 = this.label ? this.label.visProp : this.visProp.label;
      return ("minor" === b3 && a3 > Math.PI || "major" === b3 && a3 < Math.PI) && (a3 = -(2 * Math.PI - a3)), r4 = (t2 = new c.Z(i2.Z.COORDS_BY_USER, [p3[1] + Math.cos(0.5 * a3) * _3 - Math.sin(0.5 * a3) * f3, p3[2] + Math.sin(0.5 * a3) * _3 + Math.cos(0.5 * a3) * f3], this.board)).usrCoords[1] - p3[1], o2 = t2.usrCoords[2] - p3[2], r4 = r4 * ((n3 = Math.sqrt(r4 * r4 + o2 * o2)) + h3) / n3, o2 = o2 * (n3 + l3) / n3, e3 = [p3[1] + r4, p3[2] + o2], g2.position = u.Z.calcLabelQuadrant(u.Z.rad([1, 0], [0, 0], e3)), new c.Z(i2.Z.COORDS_BY_USER, e3, this.board);
    }, a2.setRadius = function(t2) {
      a2.Radius = function() {
        var e3 = s.Z.evaluate(t2);
        return "auto" === e3 ? this.autoRadius() : e3;
      };
    }, a2.getRadius = function() {
      return t.Z.deprecated("Sector.getRadius()", "Sector.Radius()"), this.Radius();
    }, "3points" === b2 && (a2.setPositionDirectly = function(t2, e3, i3) {
      var s2, r4 = new c.Z(t2, e3, this.board), o2 = new c.Z(t2, i3, this.board);
      return a2.point1.draggable() && a2.point2.draggable() && a2.point3.draggable() ? (s2 = d.Z.subtract(r4.usrCoords, o2.usrCoords), this.board.create("transform", s2.slice(1), { type: "translate" }).applyOnce([a2.point1, a2.point2, a2.point3]), this) : this;
    }), a2.prepareUpdate().update(), a2;
  }, t.Z.registerElement("sector", t.Z.createSector), t.Z.createCircumcircleSector = function(t2, e2, i3) {
    var r3, o2, n2, a2;
    if (false === (a2 = s.Z.providePoints(t2, e2, i3, "point")))
      throw new Error("JSXGraph: Can't create circumcircle sector with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.");
    return (o2 = t2.create("circumcenter", a2.slice(0, 3), n2)).dump = false, n2 = s.Z.copyAttributes(i3, t2.options, "circumcirclesector"), (r3 = t2.create("sector", [o2, a2[0], a2[2], a2[1]], n2)).elType = "circumcirclesector", r3.setParents(a2), r3.center = o2, r3.subs = { center: o2 }, r3;
  }, t.Z.registerElement("circumcirclesector", t.Z.createCircumcircleSector), t.Z.createMinorSector = function(e2, i3, s2) {
    return s2.selection = "minor", t.Z.createSector(e2, i3, s2);
  }, t.Z.registerElement("minorsector", t.Z.createMinorSector), t.Z.createMajorSector = function(e2, i3, s2) {
    return s2.selection = "major", t.Z.createSector(e2, i3, s2);
  }, t.Z.registerElement("majorsector", t.Z.createMajorSector), t.Z.createAngle = function(t2, e2, r3) {
    var n2, a2, h2, l2, d2, p2, _2 = "invalid";
    if (e2[0].elementClass === i2.Z.OBJECT_CLASS_LINE && e2[1].elementClass === i2.Z.OBJECT_CLASS_LINE && (s.Z.isArray(e2[2]) || s.Z.isNumber(e2[2])) && (s.Z.isArray(e2[3]) || s.Z.isNumber(e2[3])))
      _2 = "2lines";
    else {
      if (false === (p2 = s.Z.providePoints(t2, e2, r3, "point")))
        throw new Error("JSXGraph: Can't create angle with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.");
      _2 = "3points";
    }
    if (h2 = s.Z.copyAttributes(r3, t2.options, "angle"), s.Z.exists(h2.name) && "" !== h2.name || (h2.name = t2.generateName({ type: i2.Z.OBJECT_TYPE_ANGLE })), a2 = s.Z.exists(h2.radius) ? h2.radius : 0, "2lines" === _2 ? (e2.push(a2), (n2 = t2.create("sector", e2, h2)).updateDataArraySector = n2.updateDataArray, n2.setAngle = function(t3) {
    }, n2.free = function(t3) {
    }) : ((n2 = t2.create("sector", [p2[1], p2[0], p2[2]], h2)).arc.visProp.priv = true, n2.point = n2.point2 = n2.radiuspoint = p2[0], n2.pointsquare = n2.point3 = n2.anglepoint = p2[2], n2.Radius = function() {
      var t3 = s.Z.evaluate(a2);
      return "auto" === t3 ? n2.autoRadius() : t3;
    }, n2.updateDataArraySector = function() {
      var t3, e3, i3 = this.point2, r4 = this.point1, o2 = this.point3, n3 = this.Radius(), a3 = r4.Dist(i3), h3 = 1, l3 = s.Z.evaluate(this.visProp.selection);
      e3 = u.Z.rad(i3, r4, o2), ("minor" === l3 && e3 > Math.PI || "major" === l3 && e3 < Math.PI) && (h3 = -1), i3 = i3.coords.usrCoords, r4 = r4.coords.usrCoords, o2 = o2.coords.usrCoords, i3 = [1, r4[1] + (i3[1] - r4[1]) * n3 / a3, r4[2] + (i3[2] - r4[2]) * n3 / a3], o2 = [1, r4[1] + (o2[1] - r4[1]) * n3 / a3, r4[2] + (o2[2] - r4[2]) * n3 / a3], t3 = u.Z.bezierArc(i3, r4, o2, true, h3), this.dataX = t3[0], this.dataY = t3[1], this.bezierDegree = 3;
    }, n2.setAngle = function(t3) {
      var e3, i3, r4, n3 = this.anglepoint, a3 = this.radiuspoint;
      return n3.draggable() && (e3 = this.board.create("transform", [t3, this.center], { type: "rotate" }), n3.addTransform(a3, e3), e3.update(), n3.moveTo(o.Z.matVecMult(e3.matrix, a3.coords.usrCoords)), r4 = s.Z.isFunction(t3) ? function() {
        return 2 * Math.PI - t3();
      } : function() {
        return 2 * Math.PI - t3;
      }, i3 = this.board.create("transform", [r4, this.center], { type: "rotate" }), n3.coords.on("update", function() {
        i3.update(), a3.moveTo(o.Z.matVecMult(i3.matrix, n3.coords.usrCoords));
      }), n3.setParents(a3)), this;
    }, n2.free = function() {
      var t3 = this.anglepoint;
      return t3.transformations.length > 0 && (t3.transformations.pop(), t3.isDraggable = true, t3.parents = [], t3.coords.off("update")), this;
    }, n2.setParents(p2)), s.Z.exists(n2.visProp.text) && n2.label.setText(s.Z.evaluate(n2.visProp.text)), n2.elType = "angle", n2.type = i2.Z.OBJECT_TYPE_ANGLE, n2.subs = {}, n2.updateDataArraySquare = function() {
      var t3, e3, i3, s2, r4, n3, a3, h3, l3 = this.Radius();
      "2lines" === _2 && this.updateDataArraySector(), t3 = this.point2, e3 = this.point1, i3 = this.point3, t3 = t3.coords.usrCoords, e3 = e3.coords.usrCoords, i3 = i3.coords.usrCoords, s2 = u.Z.distance(t3, e3, 3), r4 = u.Z.distance(i3, e3, 3), t3 = [1, e3[1] + (t3[1] - e3[1]) * l3 / s2, e3[2] + (t3[2] - e3[2]) * l3 / s2], i3 = [1, e3[1] + (i3[1] - e3[1]) * l3 / r4, e3[2] + (i3[2] - e3[2]) * l3 / r4], n3 = o.Z.crossProduct(i3, e3), a3 = [-t3[1] * n3[1] - t3[2] * n3[2], t3[0] * n3[1], t3[0] * n3[2]], n3 = o.Z.crossProduct(t3, e3), h3 = [-i3[1] * n3[1] - i3[2] * n3[2], i3[0] * n3[1], i3[0] * n3[2]], (n3 = o.Z.crossProduct(a3, h3))[1] /= n3[0], n3[2] /= n3[0], this.dataX = [e3[1], t3[1], n3[1], i3[1], e3[1]], this.dataY = [e3[2], t3[2], n3[2], i3[2], e3[2]], this.bezierDegree = 1;
    }, n2.updateDataArrayNone = function() {
      this.dataX = [NaN], this.dataY = [NaN], this.bezierDegree = 1;
    }, n2.updateDataArray = function() {
      var t3 = s.Z.evaluate(this.visProp.type), e3 = u.Z.trueAngle(this.point2, this.point1, this.point3), i3 = s.Z.evaluate(this.visProp.selection);
      ("minor" === i3 && e3 > 180 || "major" === i3 && e3 < 180) && (e3 = 360 - e3), Math.abs(e3 - 90) < s.Z.evaluate(this.visProp.orthosensitivity) + o.Z.eps && (t3 = s.Z.evaluate(this.visProp.orthotype)), "none" === t3 ? this.updateDataArrayNone() : "square" === t3 ? this.updateDataArraySquare() : "sector" === t3 ? this.updateDataArraySector() : "sectordot" === t3 && (this.updateDataArraySector(), this.dot.visProp.visible || this.dot.setAttribute({ visible: true })), (!this.visProp.visible || "sectordot" !== t3 && this.dot.visProp.visible) && this.dot.setAttribute({ visible: false });
    }, l2 = s.Z.copyAttributes(r3, t2.options, "angle", "dot"), n2.dot = t2.create("point", [function() {
      var t3, e3, i3, r4, a3, h3, l3, c2, d3;
      return s.Z.exists(n2.dot) && !n2.dot.visProp.visible ? [0, 0] : (t3 = n2.point2.coords.usrCoords, e3 = n2.point1.coords.usrCoords, i3 = n2.Radius(), r4 = u.Z.distance(t3, e3, 3), a3 = u.Z.rad(n2.point2, n2.point1, n2.point3), ("minor" === (d3 = s.Z.evaluate(n2.visProp.selection)) && a3 > Math.PI || "major" === d3 && a3 < Math.PI) && (a3 = -(2 * Math.PI - a3)), a3 *= 0.5, h3 = Math.cos(a3), l3 = Math.sin(a3), t3 = [1, e3[1] + (t3[1] - e3[1]) * i3 / r4, e3[2] + (t3[2] - e3[2]) * i3 / r4], c2 = [[1, 0, 0], [e3[1] - 0.5 * e3[1] * h3 + 0.5 * e3[2] * l3, 0.5 * h3, 0.5 * -l3], [e3[2] - 0.5 * e3[1] * l3 - 0.5 * e3[2] * h3, 0.5 * l3, 0.5 * h3]], o.Z.matVecMult(c2, t3));
    }], l2), n2.dot.dump = false, n2.subs.dot = n2.dot, "2lines" === _2)
      for (d2 = 0; d2 < 2; d2++)
        t2.select(e2[d2]).addChild(n2.dot);
    else
      for (d2 = 0; d2 < 3; d2++)
        t2.select(p2[d2]).addChild(n2.dot);
    return n2.getLabelAnchor = function() {
      var t3, e3, r4, a3, h3, l3, d3, p3, _3, f2 = 12, b2 = s.Z.evaluate(n2.visProp.selection), g2 = this.label ? this.label.visProp : this.visProp.label;
      return s.Z.exists(this.label.visProp.fontSize) && (f2 = s.Z.evaluate(this.label.visProp.fontSize)), f2 /= this.board.unitX, e3 = n2.point2.coords.usrCoords, r4 = n2.point1.coords.usrCoords, a3 = n2.Radius(), h3 = u.Z.distance(e3, r4, 3), l3 = u.Z.rad(n2.point2, n2.point1, n2.point3), ("minor" === b2 && l3 > Math.PI || "major" === b2 && l3 < Math.PI) && (l3 = -(2 * Math.PI - l3)), l3 *= 0.5, d3 = Math.cos(l3), p3 = Math.sin(l3), e3 = [1, r4[1] + (e3[1] - r4[1]) * a3 / h3, r4[2] + (e3[2] - r4[2]) * a3 / h3], _3 = [[1, 0, 0], [r4[1] - 0.5 * r4[1] * d3 + 0.5 * r4[2] * p3, 0.5 * d3, 0.5 * -p3], [r4[2] - 0.5 * r4[1] * p3 - 0.5 * r4[2] * d3, 0.5 * p3, 0.5 * d3]], (t3 = o.Z.matVecMult(_3, e3))[1] /= t3[0], t3[2] /= t3[0], t3[0] /= t3[0], h3 = u.Z.distance(t3, r4, 3), t3 = [t3[0], r4[1] + (t3[1] - r4[1]) * (a3 + f2) / h3, r4[2] + (t3[2] - r4[2]) * (a3 + f2) / h3], g2.position = u.Z.calcLabelQuadrant(u.Z.rad([1, 0], [0, 0], t3)), new c.Z(i2.Z.COORDS_BY_USER, t3, this.board);
    }, n2.Value = function() {
      return u.Z.rad(this.point2, this.point1, this.point3);
    }, n2.methodMap = s.Z.deepCopy(n2.methodMap, { Value: "Value", setAngle: "setAngle", free: "free" }), n2;
  }, t.Z.registerElement("angle", t.Z.createAngle), t.Z.createNonreflexAngle = function(e2, i3, s2) {
    var r3;
    return s2.selection = "minor", (r3 = t.Z.createAngle(e2, i3, s2)).Value = function() {
      var t2 = u.Z.rad(this.point2, this.point1, this.point3);
      return t2 < Math.PI ? t2 : 2 * Math.PI - t2;
    }, r3;
  }, t.Z.registerElement("nonreflexangle", t.Z.createNonreflexAngle), t.Z.createReflexAngle = function(e2, i3, s2) {
    var r3;
    return s2.selection = "major", (r3 = t.Z.createAngle(e2, i3, s2)).Value = function() {
      var t2 = u.Z.rad(this.point2, this.point1, this.point3);
      return t2 >= Math.PI ? t2 : 2 * Math.PI - t2;
    }, r3;
  }, t.Z.registerElement("reflexangle", t.Z.createReflexAngle), t.Z.createOrthogonalProjection = function(t2, e2, r3) {
    var o2, n2, a2, h2;
    if (e2[0] = t2.select(e2[0]), e2[1] = t2.select(e2[1]), s.Z.isPointType(t2, e2[0]) && e2[1].elementClass === i2.Z.OBJECT_CLASS_LINE)
      n2 = s.Z.providePoints(t2, [e2[0]], r3, "point")[0], o2 = e2[1];
    else {
      if (!s.Z.isPointType(t2, e2[1]) || e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create perpendicular point with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line]");
      n2 = s.Z.providePoints(t2, [e2[1]], r3, "point")[0], o2 = e2[0];
    }
    return h2 = s.Z.copyAttributes(r3, t2.options, "orthogonalprojection"), a2 = t2.create("point", [function() {
      return u.Z.projectPointToLine(n2, o2, t2);
    }], h2), s.Z.exists(n2._is_new) ? (a2.addChild(n2), delete n2._is_new) : n2.addChild(a2), o2.addChild(a2), a2.elType = "orthogonalprojection", a2.setParents([n2.id, a2.id]), a2.update(), a2.generatePolynomial = function() {
      var t3 = o2.point1.symbolic.x, e3 = o2.point1.symbolic.y, i3 = o2.point2.symbolic.x, s2 = o2.point2.symbolic.y, r4 = n2.symbolic.x, h3 = n2.symbolic.y, l2 = a2.symbolic.x, c2 = a2.symbolic.y;
      return ["(" + e3 + ")*(" + l2 + ")-(" + e3 + ")*(" + i3 + ")+(" + c2 + ")*(" + i3 + ")-(" + t3 + ")*(" + c2 + ")+(" + t3 + ")*(" + s2 + ")-(" + l2 + ")*(" + s2 + ")", "(" + h3 + ")*(" + e3 + ")-(" + h3 + ")*(" + s2 + ")-(" + c2 + ")*(" + e3 + ")+(" + c2 + ")*(" + s2 + ")+(" + r4 + ")*(" + t3 + ")-(" + r4 + ")*(" + i3 + ")-(" + l2 + ")*(" + t3 + ")+(" + l2 + ")*(" + i3 + ")"];
    }, a2;
  }, t.Z.createPerpendicular = function(e2, r3, o2) {
    var n2, a2, h2, l2;
    if (r3[0] = e2.select(r3[0]), r3[1] = e2.select(r3[1]), s.Z.isPointType(e2, r3[0]) && r3[1].elementClass === i2.Z.OBJECT_CLASS_LINE)
      a2 = r3[1], n2 = s.Z.providePoints(e2, [r3[0]], o2, "point")[0];
    else {
      if (!s.Z.isPointType(e2, r3[1]) || r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create perpendicular with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'.\nPossible parent types: [line,point]");
      a2 = r3[0], n2 = s.Z.providePoints(e2, [r3[1]], o2, "point")[0];
    }
    return l2 = s.Z.copyAttributes(o2, e2.options, "perpendicular"), (h2 = t.Z.createLine(e2, [function() {
      return a2.stdform[2] * n2.X() - a2.stdform[1] * n2.Y();
    }, function() {
      return -a2.stdform[2] * n2.Z();
    }, function() {
      return a2.stdform[1] * n2.Z();
    }], l2)).elType = "perpendicular", h2.setParents([a2.id, n2.id]), s.Z.exists(n2._is_new) ? (h2.addChild(n2), delete n2._is_new) : n2.addChild(h2), a2.addChild(h2), h2;
  }, t.Z.createPerpendicularPoint = function(t2, e2, r3) {
    var o2, n2, a2;
    if (e2[0] = t2.select(e2[0]), e2[1] = t2.select(e2[1]), s.Z.isPointType(t2, e2[0]) && e2[1].elementClass === i2.Z.OBJECT_CLASS_LINE)
      n2 = s.Z.providePoints(t2, [e2[0]], r3, "point")[0], o2 = e2[1];
    else {
      if (!s.Z.isPointType(t2, e2[1]) || e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create perpendicular point with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line]");
      n2 = s.Z.providePoints(t2, [e2[1]], r3, "point")[0], o2 = e2[0];
    }
    return a2 = t2.create("point", [function() {
      return u.Z.perpendicular(o2, n2, t2)[0];
    }], r3), s.Z.exists(n2._is_new) ? (a2.addChild(n2), delete n2._is_new) : n2.addChild(a2), o2.addChild(a2), a2.elType = "perpendicularpoint", a2.setParents([n2.id, o2.id]), a2.update(), a2.generatePolynomial = function() {
      var t3 = o2.point1.symbolic.x, e3 = o2.point1.symbolic.y, i3 = o2.point2.symbolic.x, s2 = o2.point2.symbolic.y, r4 = n2.symbolic.x, h2 = n2.symbolic.y, l2 = a2.symbolic.x, c2 = a2.symbolic.y;
      return ["(" + e3 + ")*(" + l2 + ")-(" + e3 + ")*(" + i3 + ")+(" + c2 + ")*(" + i3 + ")-(" + t3 + ")*(" + c2 + ")+(" + t3 + ")*(" + s2 + ")-(" + l2 + ")*(" + s2 + ")", "(" + h2 + ")*(" + e3 + ")-(" + h2 + ")*(" + s2 + ")-(" + c2 + ")*(" + e3 + ")+(" + c2 + ")*(" + s2 + ")+(" + r4 + ")*(" + t3 + ")-(" + r4 + ")*(" + i3 + ")-(" + l2 + ")*(" + t3 + ")+(" + l2 + ")*(" + i3 + ")"];
    }, a2;
  }, t.Z.createPerpendicularSegment = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2;
    if (r3[0] = e2.select(r3[0]), r3[1] = e2.select(r3[1]), s.Z.isPointType(e2, r3[0]) && r3[1].elementClass === i2.Z.OBJECT_CLASS_LINE)
      a2 = r3[1], n2 = s.Z.providePoints(e2, [r3[0]], o2, "point")[0];
    else {
      if (!s.Z.isPointType(e2, r3[1]) || r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create perpendicular with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'.\nPossible parent types: [line,point]");
      a2 = r3[0], n2 = s.Z.providePoints(e2, [r3[1]], o2, "point")[0];
    }
    return c2 = s.Z.copyAttributes(o2, e2.options, "perpendicularsegment", "point"), (l2 = t.Z.createPerpendicularPoint(e2, [a2, n2], c2)).dump = false, s.Z.exists(o2.layer) || (o2.layer = e2.options.layer.line), c2 = s.Z.copyAttributes(o2, e2.options, "perpendicularsegment"), (h2 = t.Z.createLine(e2, [function() {
      return u.Z.perpendicular(a2, n2, e2)[1] ? [l2, n2] : [n2, l2];
    }], c2)).point = l2, s.Z.exists(n2._is_new) ? (h2.addChild(n2), delete n2._is_new) : n2.addChild(h2), a2.addChild(h2), h2.elType = "perpendicularsegment", h2.setParents([n2.id, a2.id]), h2.subs = { point: l2 }, h2.inherits.push(l2), h2;
  }, t.Z.createMidpoint = function(t2, e2, r3) {
    var n2, a2, h2, l2, c2;
    for (l2 = 0; l2 < e2.length; ++l2)
      e2[l2] = t2.select(e2[l2]);
    if (2 === e2.length && s.Z.isPointType(t2, e2[0]) && s.Z.isPointType(t2, e2[1]))
      e2 = s.Z.providePoints(t2, e2, r3, "point"), n2 = e2[0], a2 = e2[1];
    else {
      if (1 !== e2.length || e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create midpoint.\nPossible parent types: [point,point], [line]");
      n2 = e2[0].point1, a2 = e2[0].point2;
    }
    return c2 = s.Z.copyAttributes(r3, t2.options, "midpoint"), h2 = t2.create("point", [function() {
      var t3 = n2.coords.usrCoords[1] + a2.coords.usrCoords[1];
      return isNaN(t3) || Math.abs(n2.coords.usrCoords[0]) < o.Z.eps || Math.abs(a2.coords.usrCoords[0]) < o.Z.eps ? NaN : 0.5 * t3;
    }, function() {
      var t3 = n2.coords.usrCoords[2] + a2.coords.usrCoords[2];
      return isNaN(t3) || Math.abs(n2.coords.usrCoords[0]) < o.Z.eps || Math.abs(a2.coords.usrCoords[0]) < o.Z.eps ? NaN : 0.5 * t3;
    }], c2), s.Z.exists(n2._is_new) ? (h2.addChild(n2), delete n2._is_new) : n2.addChild(h2), s.Z.exists(a2._is_new) ? (h2.addChild(a2), delete a2._is_new) : a2.addChild(h2), h2.elType = "midpoint", h2.setParents([n2.id, a2.id]), h2.prepareUpdate().update(), h2.generatePolynomial = function() {
      var t3 = n2.symbolic.x, e3 = n2.symbolic.y, i3 = a2.symbolic.x, s2 = a2.symbolic.y, r4 = h2.symbolic.x, o2 = h2.symbolic.y;
      return ["(" + e3 + ")*(" + r4 + ")-(" + e3 + ")*(" + i3 + ")+(" + o2 + ")*(" + i3 + ")-(" + t3 + ")*(" + o2 + ")+(" + t3 + ")*(" + s2 + ")-(" + r4 + ")*(" + s2 + ")", "(" + t3 + ")^2 - 2*(" + t3 + ")*(" + r4 + ")+(" + e3 + ")^2-2*(" + e3 + ")*(" + o2 + ")-(" + i3 + ")^2+2*(" + i3 + ")*(" + r4 + ")-(" + s2 + ")^2+2*(" + s2 + ")*(" + o2 + ")"];
    }, h2;
  }, t.Z.createParallelPoint = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2;
    for (l2 = 0; l2 < e2.length; ++l2)
      e2[l2] = t2.select(e2[l2]);
    if (3 === e2.length && s.Z.isPointType(t2, e2[0]) && s.Z.isPointType(t2, e2[1]) && s.Z.isPointType(t2, e2[2]))
      e2 = s.Z.providePoints(t2, e2, r3, "point"), o2 = e2[0], n2 = e2[1], a2 = e2[2];
    else if (s.Z.isPointType(t2, e2[0]) && e2[1].elementClass === i2.Z.OBJECT_CLASS_LINE)
      a2 = s.Z.providePoints(t2, [e2[0]], r3, "point")[0], o2 = e2[1].point1, n2 = e2[1].point2;
    else {
      if (!s.Z.isPointType(t2, e2[1]) || e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE)
        throw new Error("JSXGraph: Can't create parallel point with parent types '" + typeof e2[0] + "', '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.\nPossible parent types: [line,point], [point,point,point]");
      a2 = s.Z.providePoints(t2, [e2[1]], r3, "point")[0], o2 = e2[0].point1, n2 = e2[0].point2;
    }
    return h2 = t2.create("point", [function() {
      return a2.coords.usrCoords[1] + n2.coords.usrCoords[1] - o2.coords.usrCoords[1];
    }, function() {
      return a2.coords.usrCoords[2] + n2.coords.usrCoords[2] - o2.coords.usrCoords[2];
    }], r3), s.Z.exists(o2._is_new) ? (h2.addChild(o2), delete o2._is_new) : o2.addChild(h2), s.Z.exists(n2._is_new) ? (h2.addChild(n2), delete n2._is_new) : n2.addChild(h2), s.Z.exists(a2._is_new) ? (h2.addChild(a2), delete a2._is_new) : a2.addChild(h2), h2.elType = "parallelpoint", h2.setParents([o2.id, n2.id, a2.id]), h2.prepareUpdate().update(), h2.generatePolynomial = function() {
      var t3 = o2.symbolic.x, e3 = o2.symbolic.y, i3 = n2.symbolic.x, s2 = n2.symbolic.y, r4 = a2.symbolic.x, l3 = a2.symbolic.y, c2 = h2.symbolic.x, d2 = h2.symbolic.y;
      return ["(" + s2 + ")*(" + c2 + ")-(" + s2 + ")*(" + r4 + ")-(" + e3 + ")*(" + c2 + ")+(" + e3 + ")*(" + r4 + ")-(" + d2 + ")*(" + i3 + ")+(" + d2 + ")*(" + t3 + ")+(" + l3 + ")*(" + i3 + ")-(" + l3 + ")*(" + t3 + ")", "(" + d2 + ")*(" + t3 + ")-(" + d2 + ")*(" + r4 + ")-(" + s2 + ")*(" + t3 + ")+(" + s2 + ")*(" + r4 + ")-(" + c2 + ")*(" + e3 + ")+(" + c2 + ")*(" + l3 + ")+(" + i3 + ")*(" + e3 + ")-(" + i3 + ")*(" + l3 + ")"];
    }, h2;
  }, t.Z.createParallel = function(t2, e2, i3) {
    var r3, n2, a2, h2, l2, c2, d2 = 1;
    for (l2 = 0; l2 < e2.length; ++l2)
      e2[l2] = t2.select(e2[l2]);
    return r3 = null, 3 === e2.length ? (r3 = (e2 = s.Z.providePoints(t2, e2, i3, "point"))[2], d2 = 0) : s.Z.isPointType(t2, e2[0]) ? (r3 = s.Z.providePoints(t2, [e2[0]], i3, "point")[0], h2 = function() {
      return e2[1].stdform;
    }) : s.Z.isPointType(t2, e2[1]) && (r3 = s.Z.providePoints(t2, [e2[1]], i3, "point")[0], h2 = function() {
      return e2[0].stdform;
    }), s.Z.exists(i3.layer) || (i3.layer = t2.options.layer.line), c2 = s.Z.copyAttributes(i3, t2.options, "parallel", "point"), (n2 = 1 === d2 ? t2.create("point", [function() {
      return o.Z.crossProduct([1, 0, 0], h2());
    }], c2) : t2.create("parallelpoint", e2, c2)).isDraggable = true, c2 = s.Z.copyAttributes(i3, t2.options, "parallel"), (a2 = t2.create("line", [r3, n2], c2)).elType = "parallel", a2.subs = { point: n2 }, a2.inherits.push(n2), a2.setParents([e2[0].id, e2[1].id]), 3 === e2.length && a2.addParents(e2[2].id), a2.point = n2, a2;
  }, t.Z.createArrowParallel = function(e2, i3, s2) {
    var r3;
    try {
      return s2.firstArrow = false, s2.lastArrow = true, (r3 = t.Z.createParallel(e2, i3, s2).setAttribute({ straightFirst: false, straightLast: false })).elType = "arrowparallel", r3;
    } catch (t2) {
      throw new Error("JSXGraph: Can't create arrowparallel with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [line,point], [point,point,point]");
    }
  }, t.Z.createNormal = function(t2, e2, r3) {
    var n2, a2, h2, c2, d2, u2, p2, _2, f2;
    for (c2 = 0; c2 < e2.length; ++c2)
      e2[c2] = t2.select(e2[c2]);
    if (1 === e2.length)
      n2 = e2[0], a2 = n2.slideObject;
    else {
      if (2 !== e2.length)
        throw new Error("JSXGraph: Can't create normal with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
      if (s.Z.isPointType(t2, e2[0]))
        n2 = s.Z.providePoints(t2, [e2[0]], r3, "point")[0], a2 = e2[1];
      else {
        if (!s.Z.isPointType(t2, e2[1]))
          throw new Error("JSXGraph: Can't create normal with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
        a2 = e2[0], n2 = s.Z.providePoints(t2, [e2[1]], r3, "point")[0];
      }
    }
    if (p2 = s.Z.copyAttributes(r3, t2.options, "normal"), a2.elementClass === i2.Z.OBJECT_CLASS_LINE)
      f2 = s.Z.copyAttributes(r3, t2.options, "normal", "point"), _2 = t2.create("point", [function() {
        var t3 = o.Z.crossProduct([1, 0, 0], a2.stdform);
        return [t3[0], -t3[2], t3[1]];
      }], f2), _2.isDraggable = true, (h2 = t2.create("line", [n2, _2], p2)).point = _2, h2.subs = { point: _2 }, h2.inherits.push(_2);
    else if (a2.elementClass === i2.Z.OBJECT_CLASS_CIRCLE)
      h2 = t2.create("line", [a2.midpoint, n2], p2);
    else if (a2.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      "plot" !== s.Z.evaluate(a2.visProp.curvetype) ? (d2 = a2.X, u2 = a2.Y, h2 = t2.create("line", [function() {
        return -n2.X() * l.Z.D(d2)(n2.position) - n2.Y() * l.Z.D(u2)(n2.position);
      }, function() {
        return l.Z.D(d2)(n2.position);
      }, function() {
        return l.Z.D(u2)(n2.position);
      }], p2)) : h2 = t2.create("line", [function() {
        var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3, u3 = Math.floor(n2.position), p3 = n2.position - u3;
        if (1 === a2.bezierdegree)
          u3 === a2.numberPoints - 1 && (u3 -= 1, p3 = 1);
        else {
          if (3 !== a2.bezierDegree)
            return 0;
          u3 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), i3 = (n2.position * (a2.numberPoints - 1) - u3) / 3, u3 >= a2.numberPoints - 1 && (u3 = a2.numberPoints - 4, i3 = 1);
        }
        return u3 < 0 ? 1 : 1 === a2.bezierDegree ? (a2.Y(u3) + p3 * (a2.Y(u3 + 1) - a2.Y(u3))) * (a2.Y(u3) - a2.Y(u3 + 1)) - (a2.X(u3) + p3 * (a2.X(u3 + 1) - a2.X(u3))) * (a2.X(u3 + 1) - a2.X(u3)) : (s2 = a2.points[u3].usrCoords, r4 = a2.points[u3 + 1].usrCoords, o2 = a2.points[u3 + 2].usrCoords, h3 = a2.points[u3 + 3].usrCoords, l2 = (1 - i3) * (1 - i3) * (r4[1] - s2[1]) + 2 * (1 - i3) * i3 * (o2[1] - r4[1]) + i3 * i3 * (h3[1] - o2[1]), c3 = (1 - i3) * (1 - i3) * (r4[2] - s2[2]) + 2 * (1 - i3) * i3 * (o2[2] - r4[2]) + i3 * i3 * (h3[2] - o2[2]), l2 /= d3 = Math.sqrt(l2 * l2 + c3 * c3), c3 /= d3, e3 = [1, (t3 = n2.coords.usrCoords)[1] - c3, t3[2] + l2], t3[2] * e3[1] - t3[1] * e3[2]);
      }, function() {
        var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3 = Math.floor(n2.position);
        if (1 === a2.bezierdegree)
          d3 === a2.numberPoints - 1 && (d3 -= 1);
        else {
          if (3 !== a2.bezierDegree)
            return 0;
          d3 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), e3 = (n2.position * (a2.numberPoints - 1) - d3) / 3, d3 >= a2.numberPoints - 1 && (d3 = a2.numberPoints - 4, e3 = 1);
        }
        return d3 < 0 ? 0 : 1 === a2.bezierDegree ? a2.X(d3 + 1) - a2.X(d3) : (i3 = a2.points[d3].usrCoords, s2 = a2.points[d3 + 1].usrCoords, r4 = a2.points[d3 + 2].usrCoords, o2 = a2.points[d3 + 3].usrCoords, h3 = (1 - e3) * (1 - e3) * (s2[1] - i3[1]) + 2 * (1 - e3) * e3 * (r4[1] - s2[1]) + e3 * e3 * (o2[1] - r4[1]), l2 = (1 - e3) * (1 - e3) * (s2[2] - i3[2]) + 2 * (1 - e3) * e3 * (r4[2] - s2[2]) + e3 * e3 * (o2[2] - r4[2]), h3 /= c3 = Math.sqrt(h3 * h3 + l2 * l2), l2 /= c3, [1, (t3 = n2.coords.usrCoords)[1] - l2, t3[2] + h3][2] - t3[2]);
      }, function() {
        var t3, e3, i3, s2, r4, o2, h3, l2, c3, d3, u3 = Math.floor(n2.position);
        if (1 === a2.bezierdegree)
          u3 === a2.numberPoints - 1 && (u3 -= 1);
        else {
          if (3 !== a2.bezierDegree)
            return 0;
          u3 = 3 * Math.floor(n2.position * (a2.numberPoints - 1) / 3), i3 = (n2.position * (a2.numberPoints - 1) - u3) / 3, u3 >= a2.numberPoints - 1 && (u3 = a2.numberPoints - 4, i3 = 1);
        }
        return u3 < 0 ? 0 : 1 === a2.bezierDegree ? a2.Y(u3 + 1) - a2.Y(u3) : (s2 = a2.points[u3].usrCoords, r4 = a2.points[u3 + 1].usrCoords, o2 = a2.points[u3 + 2].usrCoords, h3 = a2.points[u3 + 3].usrCoords, l2 = (1 - i3) * (1 - i3) * (r4[1] - s2[1]) + 2 * (1 - i3) * i3 * (o2[1] - r4[1]) + i3 * i3 * (h3[1] - o2[1]), c3 = (1 - i3) * (1 - i3) * (r4[2] - s2[2]) + 2 * (1 - i3) * i3 * (o2[2] - r4[2]) + i3 * i3 * (h3[2] - o2[2]), l2 /= d3 = Math.sqrt(l2 * l2 + c3 * c3), c3 /= d3, e3 = [1, (t3 = n2.coords.usrCoords)[1] - c3, t3[2] + l2], t3[1] - e3[1]);
      }], p2);
    else {
      if (a2.type !== i2.Z.OBJECT_TYPE_TURTLE)
        throw new Error("JSXGraph: Can't create normal with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
      h2 = t2.create("line", [function() {
        var t3, e3, s2 = Math.floor(n2.position), r4 = n2.position - s2;
        for (e3 = 0; e3 < a2.objects.length; e3++)
          if ((t3 = a2.objects[e3]).type === i2.Z.OBJECT_TYPE_CURVE) {
            if (s2 < t3.numberPoints)
              break;
            s2 -= t3.numberPoints;
          }
        return s2 === t3.numberPoints - 1 && (s2 -= 1, r4 = 1), s2 < 0 ? 1 : (t3.Y(s2) + r4 * (t3.Y(s2 + 1) - t3.Y(s2))) * (t3.Y(s2) - t3.Y(s2 + 1)) - (t3.X(s2) + r4 * (t3.X(s2 + 1) - t3.X(s2))) * (t3.X(s2 + 1) - t3.X(s2));
      }, function() {
        var t3, e3, s2 = Math.floor(n2.position);
        for (e3 = 0; e3 < a2.objects.length; e3++)
          if ((t3 = a2.objects[e3]).type === i2.Z.OBJECT_TYPE_CURVE) {
            if (s2 < t3.numberPoints)
              break;
            s2 -= t3.numberPoints;
          }
        return s2 === t3.numberPoints - 1 && (s2 -= 1), s2 < 0 ? 0 : t3.X(s2 + 1) - t3.X(s2);
      }, function() {
        var t3, e3, s2 = Math.floor(n2.position);
        for (e3 = 0; e3 < a2.objects.length; e3++)
          if ((t3 = a2.objects[e3]).type === i2.Z.OBJECT_TYPE_CURVE) {
            if (s2 < t3.numberPoints)
              break;
            s2 -= t3.numberPoints;
          }
        return s2 === t3.numberPoints - 1 && (s2 -= 1), s2 < 0 ? 0 : t3.Y(s2 + 1) - t3.Y(s2);
      }], p2);
    }
    return h2.elType = "normal", h2.setParents(e2), s.Z.exists(n2._is_new) ? (h2.addChild(n2), delete n2._is_new) : n2.addChild(h2), a2.addChild(h2), h2;
  }, t.Z.createBisector = function(e2, i3, r3) {
    var o2, n2, a2, h2;
    if (i3 = s.Z.providePoints(e2, i3, r3, "point"), s.Z.isPoint(i3[0]) && s.Z.isPoint(i3[1]) && s.Z.isPoint(i3[2])) {
      for ((h2 = s.Z.copyAttributes(r3, e2.options, "bisector", "point")).snapToGrid = false, (o2 = e2.create("point", [function() {
        return u.Z.angleBisector(i3[0], i3[1], i3[2], e2);
      }], h2)).dump = false, a2 = 0; a2 < 3; a2++)
        s.Z.exists(i3[a2]._is_new) ? (o2.addChild(i3[a2]), delete i3[a2]._is_new) : i3[a2].addChild(o2);
      return s.Z.exists(r3.layer) || (r3.layer = e2.options.layer.line), h2 = s.Z.copyAttributes(r3, e2.options, "bisector"), (n2 = t.Z.createLine(e2, [i3[1], o2], h2)).point = o2, n2.elType = "bisector", n2.setParents(i3), n2.subs = { point: o2 }, n2.inherits.push(o2), n2;
    }
    throw new Error("JSXGraph: Can't create angle bisector with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point,point]");
  }, t.Z.createAngularBisectorsOfTwoLines = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2 = t2.select(e2[0]), c2 = t2.select(e2[1]);
    if (l2.elementClass !== i2.Z.OBJECT_CLASS_LINE || c2.elementClass !== i2.Z.OBJECT_CLASS_LINE)
      throw new Error("JSXGraph: Can't create angle bisectors of two lines with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + "'.\nPossible parent types: [line,line]");
    return s.Z.exists(r3.layer) || (r3.layer = t2.options.layer.line), a2 = s.Z.copyAttributes(r3, t2.options, "bisectorlines", "line1"), o2 = t2.create("line", [function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[0] / t3 - c2.stdform[0] / e3;
    }, function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[1] / t3 - c2.stdform[1] / e3;
    }, function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[2] / t3 - c2.stdform[2] / e3;
    }], a2), s.Z.exists(r3.layer) || (r3.layer = t2.options.layer.line), a2 = s.Z.copyAttributes(r3, t2.options, "bisectorlines", "line2"), n2 = t2.create("line", [function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[0] / t3 + c2.stdform[0] / e3;
    }, function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[1] / t3 + c2.stdform[1] / e3;
    }, function() {
      var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e3 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
      return l2.stdform[2] / t3 + c2.stdform[2] / e3;
    }], a2), h2 = new L({ line1: o2, line2: n2 }), o2.dump = false, n2.dump = false, h2.elType = "bisectorlines", h2.setParents([l2.id, c2.id]), h2.subs = { line1: o2, line2: n2 }, h2;
  }, t.Z.createCircumcenter = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2;
    if (i3 = s.Z.providePoints(e2, i3, r3, "point"), s.Z.isPoint(i3[0]) && s.Z.isPoint(i3[1]) && s.Z.isPoint(i3[2])) {
      for (a2 = i3[0], h2 = i3[1], l2 = i3[2], o2 = t.Z.createPoint(e2, [function() {
        return u.Z.circumcenter(a2, h2, l2, e2);
      }], r3), n2 = 0; n2 < 3; n2++)
        s.Z.exists(i3[n2]._is_new) ? (o2.addChild(i3[n2]), delete i3[n2]._is_new) : i3[n2].addChild(o2);
      return o2.elType = "circumcenter", o2.setParents(i3), o2.generatePolynomial = function() {
        var t2 = a2.symbolic.x, e3 = a2.symbolic.y, i4 = h2.symbolic.x, s2 = h2.symbolic.y, r4 = l2.symbolic.x, n3 = l2.symbolic.y, c2 = o2.symbolic.x, d2 = o2.symbolic.y;
        return [["((", c2, ")-(", t2, "))^2+((", d2, ")-(", e3, "))^2-((", c2, ")-(", i4, "))^2-((", d2, ")-(", s2, "))^2"].join(""), ["((", c2, ")-(", t2, "))^2+((", d2, ")-(", e3, "))^2-((", c2, ")-(", r4, "))^2-((", d2, ")-(", n3, "))^2"].join("")];
      }, o2;
    }
    throw new Error("JSXGraph: Can't create circumcircle midpoint with parent types '" + typeof i3[0] + "', '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point,point]");
  }, t.Z.createIncenter = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2;
    if (!((e2 = s.Z.providePoints(t2, e2, r3, "point")).length >= 3 && s.Z.isPoint(e2[0]) && s.Z.isPoint(e2[1]) && s.Z.isPoint(e2[2])))
      throw new Error("JSXGraph: Can't create incenter with parent types '" + typeof e2[0] + "', '" + typeof e2[1] + "' and '" + typeof e2[2] + "'.\nPossible parent types: [point,point,point]");
    for (n2 = e2[0], a2 = e2[1], h2 = e2[2], o2 = t2.create("point", [function() {
      var e3, s2, r4;
      return e3 = Math.sqrt((a2.X() - h2.X()) * (a2.X() - h2.X()) + (a2.Y() - h2.Y()) * (a2.Y() - h2.Y())), s2 = Math.sqrt((n2.X() - h2.X()) * (n2.X() - h2.X()) + (n2.Y() - h2.Y()) * (n2.Y() - h2.Y())), r4 = Math.sqrt((a2.X() - n2.X()) * (a2.X() - n2.X()) + (a2.Y() - n2.Y()) * (a2.Y() - n2.Y())), new c.Z(i2.Z.COORDS_BY_USER, [(e3 * n2.X() + s2 * a2.X() + r4 * h2.X()) / (e3 + s2 + r4), (e3 * n2.Y() + s2 * a2.Y() + r4 * h2.Y()) / (e3 + s2 + r4)], t2);
    }], r3), l2 = 0; l2 < 3; l2++)
      s.Z.exists(e2[l2]._is_new) ? (o2.addChild(e2[l2]), delete e2[l2]._is_new) : e2[l2].addChild(o2);
    return o2.elType = "incenter", o2.setParents(e2), o2;
  }, t.Z.createCircumcircle = function(e2, i3, r3) {
    var o2, n2, a2, h2;
    if (false === (i3 = s.Z.providePoints(e2, i3, r3, "point")))
      throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i3[0] + "', '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point,point]");
    try {
      for (a2 = s.Z.copyAttributes(r3, e2.options, "circumcircle", "center"), (o2 = t.Z.createCircumcenter(e2, i3, a2)).dump = false, s.Z.exists(r3.layer) || (r3.layer = e2.options.layer.circle), a2 = s.Z.copyAttributes(r3, e2.options, "circumcircle"), (n2 = t.Z.createCircle(e2, [o2, i3[0]], a2)).elType = "circumcircle", n2.setParents(i3), n2.subs = { center: o2 }, n2.inherits.push(n2), h2 = 0; h2 < 3; h2++)
        s.Z.exists(i3[h2]._is_new) ? (n2.addChild(i3[h2]), delete i3[h2]._is_new) : i3[h2].addChild(n2);
    } catch (t2) {
      throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i3[0] + "', '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point,point]");
    }
    return n2;
  }, t.Z.createIncircle = function(e2, i3, r3) {
    var o2, n2, a2, h2;
    if (false === (i3 = s.Z.providePoints(e2, i3, r3, "point")))
      throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i3[0] + "', '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point,point]");
    try {
      for (h2 = s.Z.copyAttributes(r3, e2.options, "incircle", "center"), (n2 = t.Z.createIncenter(e2, i3, h2)).dump = false, s.Z.exists(r3.layer) || (r3.layer = e2.options.layer.circle), h2 = s.Z.copyAttributes(r3, e2.options, "incircle"), (a2 = t.Z.createCircle(e2, [n2, function() {
        var t2 = Math.sqrt((i3[1].X() - i3[2].X()) * (i3[1].X() - i3[2].X()) + (i3[1].Y() - i3[2].Y()) * (i3[1].Y() - i3[2].Y())), e3 = Math.sqrt((i3[0].X() - i3[2].X()) * (i3[0].X() - i3[2].X()) + (i3[0].Y() - i3[2].Y()) * (i3[0].Y() - i3[2].Y())), s2 = Math.sqrt((i3[1].X() - i3[0].X()) * (i3[1].X() - i3[0].X()) + (i3[1].Y() - i3[0].Y()) * (i3[1].Y() - i3[0].Y())), r4 = (t2 + e3 + s2) / 2;
        return Math.sqrt((r4 - t2) * (r4 - e3) * (r4 - s2) / r4);
      }], h2)).elType = "incircle", a2.setParents(i3), o2 = 0; o2 < 3; o2++)
        s.Z.exists(i3[o2]._is_new) ? (a2.addChild(i3[o2]), delete i3[o2]._is_new) : i3[o2].addChild(a2);
      a2.center = n2, a2.subs = { center: a2.center }, a2.inherits.push(n2);
    } catch (t2) {
      throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i3[0] + "', '" + typeof i3[1] + "' and '" + typeof i3[2] + "'.\nPossible parent types: [point,point,point]");
    }
    return a2;
  }, t.Z.createReflection = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2 = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]";
    for (d2 = 0; d2 < r3.length; ++d2)
      r3[d2] = e2.select(r3[d2]);
    if (u2 = s.Z.copyAttributes(o2, e2.options, "reflection"), s.Z.isPoint(r3[0]))
      a2 = s.Z.providePoints(e2, [r3[0]], p2)[0];
    else {
      if (r3[0].elementClass !== i2.Z.OBJECT_CLASS_CURVE && r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE && r3[0].type !== i2.Z.OBJECT_TYPE_POLYGON && r3[0].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
        throw new Error("JSXGraph: Can't create reflection element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
      a2 = r3[0];
    }
    if (r3[1].elementClass !== i2.Z.OBJECT_CLASS_LINE)
      throw new Error("JSXGraph: Can't create reflected element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
    if (n2 = r3[1], c2 = t.Z.createTransform(e2, [n2], { type: "reflect" }), s.Z.isPoint(a2))
      h2 = t.Z.createPoint(e2, [a2, c2], u2);
    else if (a2.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      h2 = t.Z.createCurve(e2, [a2, c2], u2);
    else if (a2.elementClass === i2.Z.OBJECT_CLASS_LINE)
      h2 = t.Z.createLine(e2, [a2, c2], u2);
    else if (a2.type === i2.Z.OBJECT_TYPE_POLYGON)
      h2 = t.Z.createPolygon(e2, [a2, c2], u2);
    else {
      if (a2.elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
        throw new Error("JSXGraph: Can't create reflected element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
      "euclidean" === u2.type.toLowerCase() ? (p2 = s.Z.copyAttributes(o2, e2.options, "reflection", "center"), (l2 = t.Z.createPoint(e2, [a2.center, c2], p2)).prepareUpdate().update().updateVisibility(s.Z.evaluate(l2.visProp.visible)).updateRenderer(), h2 = t.Z.createCircle(e2, [l2, function() {
        return a2.Radius();
      }], u2)) : h2 = t.Z.createCircle(e2, [a2, c2], u2);
    }
    return s.Z.exists(a2._is_new) && (h2.addChild(a2), delete a2._is_new), n2.addChild(h2), h2.elType = "reflection", h2.addParents(n2), h2.prepareUpdate().update(), s.Z.isPoint(h2) && (h2.generatePolynomial = function() {
      var t2 = n2.point1.symbolic.x, e3 = n2.point1.symbolic.y, i3 = n2.point2.symbolic.x, s2 = n2.point2.symbolic.y, r4 = a2.symbolic.x, o3 = a2.symbolic.y, l3 = h2.symbolic.x, c3 = h2.symbolic.y;
      return [["((", c3, ")-(", o3, "))*((", e3, ")-(", s2, "))+((", t2, ")-(", i3, "))*((", l3, ")-(", r4, "))"].join(""), ["((", l3, ")-(", t2, "))^2+((", c3, ")-(", e3, "))^2-((", r4, ")-(", t2, "))^2-((", o3, ")-(", e3, "))^2"].join("")];
    }), h2;
  }, t.Z.createMirrorElement = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2 = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]";
    for (a2 = 0; a2 < r3.length; ++a2)
      r3[a2] = e2.select(r3[a2]);
    if (u2 = s.Z.copyAttributes(o2, e2.options, "mirrorelement"), s.Z.isPoint(r3[0]))
      n2 = s.Z.providePoints(e2, [r3[0]], u2)[0];
    else {
      if (r3[0].elementClass !== i2.Z.OBJECT_CLASS_CURVE && r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE && r3[0].type !== i2.Z.OBJECT_TYPE_POLYGON && r3[0].elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
        throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
      n2 = r3[0];
    }
    if (!s.Z.isPoint(r3[1]))
      throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
    if (p2 = s.Z.copyAttributes(o2, e2.options, "mirrorelement", "point"), h2 = s.Z.providePoints(e2, [r3[1]], p2)[0], d2 = t.Z.createTransform(e2, [Math.PI, h2], { type: "rotate" }), s.Z.isPoint(n2))
      l2 = t.Z.createPoint(e2, [n2, d2], u2);
    else if (n2.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      l2 = t.Z.createCurve(e2, [n2, d2], u2);
    else if (n2.elementClass === i2.Z.OBJECT_CLASS_LINE)
      l2 = t.Z.createLine(e2, [n2, d2], u2);
    else if (n2.type === i2.Z.OBJECT_TYPE_POLYGON)
      l2 = t.Z.createPolygon(e2, [n2, d2], u2);
    else {
      if (n2.elementClass !== i2.Z.OBJECT_CLASS_CIRCLE)
        throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'." + _2);
      "euclidean" === u2.type.toLowerCase() ? (p2 = s.Z.copyAttributes(o2, e2.options, "mirrorelement", "center"), (c2 = t.Z.createPoint(e2, [n2.center, d2], p2)).prepareUpdate().update().updateVisibility(s.Z.evaluate(c2.visProp.visible)).updateRenderer(), l2 = t.Z.createCircle(e2, [c2, function() {
        return n2.Radius();
      }], u2)) : l2 = t.Z.createCircle(e2, [n2, d2], u2);
    }
    return s.Z.exists(n2._is_new) && (l2.addChild(n2), delete n2._is_new), h2.addChild(l2), l2.elType = "mirrorelement", l2.addParents(h2), l2.prepareUpdate().update(), l2;
  }, t.Z.createMirrorPoint = function(e2, i3, s2) {
    var r3 = t.Z.createMirrorElement(e2, i3, s2);
    return r3.elType = "mirrorpoint", r3;
  }, t.Z.createIntegral = function(e2, r3, o2) {
    var n2, a2, h2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2 = null;
    if (s.Z.isArray(r3[0]) && r3[1].elementClass === i2.Z.OBJECT_CLASS_CURVE)
      n2 = r3[0], a2 = r3[1];
    else {
      if (!s.Z.isArray(r3[1]) || r3[0].elementClass !== i2.Z.OBJECT_CLASS_CURVE)
        throw new Error("JSXGraph: Can't create integral with parent types '" + typeof r3[0] + "' and '" + typeof r3[1] + "'.\nPossible parent types: [[number|function,number|function],curve]");
      n2 = r3[1], a2 = r3[0];
    }
    return (h2 = s.Z.copyAttributes(o2, e2.options, "integral")).withLabel = false, C2 = e2.create("curve", [[0], [0]], h2), d2 = n2[0], u2 = n2[1], s.Z.isFunction(d2) ? (_2 = function() {
      return a2.Y(p2());
    }, d2 = (p2 = d2)()) : (p2 = d2, _2 = a2.Y(d2)), s.Z.isFunction(u2) ? (b2 = function() {
      return a2.Y(f2());
    }, u2 = (f2 = u2)()) : (f2 = u2, b2 = a2.Y(u2)), h2 = s.Z.copyAttributes(o2, e2.options, "integral", "curveLeft"), g2 = e2.create("glider", [p2, _2, a2], h2), s.Z.isFunction(p2) && g2.hideElement(), h2 = s.Z.copyAttributes(o2, e2.options, "integral", "baseLeft"), m2 = e2.create("point", [function() {
      return "y" === s.Z.evaluate(C2.visProp.axis) ? 0 : g2.X();
    }, function() {
      return "y" === s.Z.evaluate(C2.visProp.axis) ? g2.Y() : 0;
    }], h2), h2 = s.Z.copyAttributes(o2, e2.options, "integral", "curveRight"), v2 = e2.create("glider", [f2, b2, a2], h2), s.Z.isFunction(f2) && v2.hideElement(), h2 = s.Z.copyAttributes(o2, e2.options, "integral", "baseRight"), Z2 = e2.create("point", [function() {
      return "y" === s.Z.evaluate(C2.visProp.axis) ? 0 : v2.X();
    }, function() {
      return "y" === s.Z.evaluate(C2.visProp.axis) ? v2.Y() : 0;
    }], h2), false !== (h2 = s.Z.copyAttributes(o2, e2.options, "integral")).withlabel && "y" !== h2.axis && (h2 = s.Z.copyAttributes(o2, e2.options, "integral", "label"), h2 = s.Z.copyAttributes(h2, e2.options, "label"), (y2 = e2.create("text", [function() {
      var t2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [s.Z.evaluate(this.visProp.offset[0]) + this.board.origin.scrCoords[1], 0], this.board, false), e3 = this.board.getBoundingBox(), r4 = 0.1 * (e3[2] - e3[0]), o3 = v2.X();
      return o3 < e3[0] ? o3 = e3[0] + r4 : o3 > e3[2] && (o3 = e3[2] - r4), o3 + t2.usrCoords[1];
    }, function() {
      var t2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [0, s.Z.evaluate(this.visProp.offset[1]) + this.board.origin.scrCoords[2]], this.board, false), e3 = this.board.getBoundingBox(), r4 = 0.1 * (e3[1] - e3[3]), o3 = v2.Y();
      return o3 > e3[1] ? o3 = e3[1] - r4 : o3 < e3[3] && (o3 = e3[3] + r4), o3 + t2.usrCoords[2];
    }, function() {
      var t2 = l.Z.NewtonCotes([m2.X(), Z2.X()], a2.Y);
      return "&int; = " + s.Z.toFixed(t2, 4);
    }], h2)).dump = false, g2.addChild(y2), v2.addChild(y2)), g2.dump = false, m2.dump = false, v2.dump = false, Z2.dump = false, C2.elType = "integral", C2.setParents([a2.id, n2]), C2.subs = { curveLeft: g2, baseLeft: m2, curveRight: v2, baseRight: Z2 }, C2.inherits.push(g2, m2, v2, Z2), h2.withLabel && (C2.subs.label = y2, C2.inherits.push(y2)), C2.Value = function() {
      return l.Z.I([m2.X(), Z2.X()], a2.Y);
    }, C2.updateDataArray = function() {
      var t2, e3, i3, r4, o3, n3, h3, l2, c2;
      if ("y" === s.Z.evaluate(this.visProp.axis)) {
        for (g2.Y() < v2.Y() ? (n3 = g2.X(), l2 = g2.Y(), h3 = v2.X(), c2 = v2.Y()) : (n3 = v2.X(), l2 = v2.Y(), h3 = g2.X(), c2 = g2.Y()), r4 = Math.min(n3, h3), o3 = Math.max(n3, h3), t2 = [0, n3], e3 = [l2, l2], i3 = 0; i3 < a2.numberPoints; i3++)
          l2 <= a2.points[i3].usrCoords[2] && r4 <= a2.points[i3].usrCoords[1] && a2.points[i3].usrCoords[2] <= c2 && a2.points[i3].usrCoords[1] <= o3 && (t2.push(a2.points[i3].usrCoords[1]), e3.push(a2.points[i3].usrCoords[2]));
        t2.push(h3), e3.push(c2), t2.push(0), e3.push(c2), t2.push(0), e3.push(l2);
      } else {
        for (m2.X() < Z2.X() ? (r4 = m2.X(), o3 = Z2.X()) : (r4 = Z2.X(), o3 = m2.X()), t2 = [r4, r4], e3 = [0, a2.Y(r4)], i3 = 0; i3 < a2.numberPoints; i3++)
          r4 <= a2.points[i3].usrCoords[1] && a2.points[i3].usrCoords[1] <= o3 && (t2.push(a2.points[i3].usrCoords[1]), e3.push(a2.points[i3].usrCoords[2]));
        t2.push(o3), e3.push(a2.Y(o3)), t2.push(o3), e3.push(0), t2.push(r4), e3.push(0);
      }
      this.dataX = t2, this.dataY = e3;
    }, g2.addChild(C2), v2.addChild(C2), m2.addChild(C2), Z2.addChild(C2), C2.baseLeft = m2, C2.baseRight = Z2, C2.curveLeft = g2, C2.curveRight = v2, C2.methodMap = t.Z.deepCopy(C2.methodMap, { curveLeft: "curveLeft", baseLeft: "baseLeft", curveRight: "curveRight", baseRight: "baseRight", Value: "Value" }), C2.label = y2, C2;
  }, t.Z.createGrid = function(t2, e2, r3) {
    var o2, n2;
    return n2 = s.Z.copyAttributes(r3, t2.options, "grid"), (o2 = t2.create("curve", [[null], [null]], n2)).elType = "grid", o2.type = i2.Z.OBJECT_TYPE_GRID, o2.updateDataArray = function() {
      var e3, r4, n3, a2, h2, l2 = s.Z.evaluate(this.visProp.gridx), d2 = s.Z.evaluate(this.visProp.gridy);
      for (a2 = s.Z.isArray(this.visProp.topleft) ? new c.Z(s.Z.evaluate(this.visProp.tltype) || i2.Z.COORDS_BY_USER, this.visProp.topleft, t2) : new c.Z(i2.Z.COORDS_BY_SCREEN, [0, 0], t2), h2 = s.Z.isArray(this.visProp.bottomright) ? new c.Z(s.Z.evaluate(this.visProp.brtype) || i2.Z.COORDS_BY_USER, this.visProp.bottomright, t2) : new c.Z(i2.Z.COORDS_BY_SCREEN, [t2.canvasWidth, t2.canvasHeight], t2), t2.options.grid.hasGrid = true, o2.dataX = [], o2.dataY = [], e3 = Math.floor(a2.usrCoords[2] / d2) * d2, r4 = Math.ceil(h2.usrCoords[2] / d2) * d2, a2.usrCoords[2] < h2.usrCoords[2] && (e3 = Math.ceil(h2.usrCoords[2] / d2) * d2, r4 = Math.floor(a2.usrCoords[2] / d2) * d2), n3 = e3; n3 > r4 - d2; n3 -= d2)
        o2.dataX.push(a2.usrCoords[1], h2.usrCoords[1], NaN), o2.dataY.push(n3, n3, NaN);
      for (e3 = Math.ceil(a2.usrCoords[1] / l2) * l2, r4 = Math.floor(h2.usrCoords[1] / l2) * l2, a2.usrCoords[1] > h2.usrCoords[1] && (e3 = Math.floor(h2.usrCoords[1] / l2) * l2, r4 = Math.ceil(a2.usrCoords[1] / l2) * l2), n3 = e3; n3 < r4 + l2; n3 += l2)
        o2.dataX.push(n3, n3, NaN), o2.dataY.push(a2.usrCoords[2], h2.usrCoords[2], NaN);
    }, o2.hasPoint = function() {
      return false;
    }, t2.grids.push(o2), o2;
  }, t.Z.createInequality = function(t2, e2, r3) {
    var n2, a2, h2;
    if (h2 = s.Z.copyAttributes(r3, t2.options, "inequality"), e2[0].elementClass === i2.Z.OBJECT_CLASS_LINE)
      (a2 = t2.create("curve", [[], []], h2)).hasPoint = function() {
        return false;
      }, a2.updateDataArray = function() {
        var s2, r4, n3, a3 = t2.getBoundingBox(), l2 = h2.inverse ? -1 : 1, c2 = 1.5 * Math.max(a3[2] - a3[0], a3[1] - a3[3]), d2 = { coords: { usrCoords: [1, (a3[0] + a3[2]) / 2, h2.inverse ? a3[1] : a3[3]] } }, p2 = e2[0].stdform.slice(1), _2 = p2;
        n3 = 1.5 * Math.max(u.Z.perpendicular(e2[0], d2, t2)[0].distance(i2.Z.COORDS_BY_USER, d2.coords), c2), n3 *= l2, d2 = { coords: { usrCoords: [1, (a3[0] + a3[2]) / 2, (a3[1] + a3[3]) / 2] } }, s2 = [1, (d2 = Math.abs(o.Z.innerProduct(d2.coords.usrCoords, e2[0].stdform, 3)) >= o.Z.eps ? u.Z.perpendicular(e2[0], d2, t2)[0].usrCoords : d2.coords.usrCoords)[1] + p2[1] * c2, d2[2] - p2[0] * c2], r4 = [1, d2[1] - _2[1] * c2, d2[2] + _2[0] * c2], this.dataX = [s2[1], s2[1] + p2[0] * n3, r4[1] + _2[0] * n3, r4[1], s2[1]], this.dataY = [s2[2], s2[2] + p2[1] * n3, r4[2] + _2[1] * n3, r4[2], s2[2]];
      };
    else if (e2[0].elementClass === i2.Z.OBJECT_CLASS_CURVE && "functiongraph" === e2[0].visProp.curvetype)
      (a2 = t2.create("curve", [[], []], h2)).updateDataArray = function() {
        var t3, i3, r4, o2, n3, a3, h3, l2, c2, d2 = this.board.getBoundingBox(), u2 = [], p2 = e2[0].minX(), _2 = e2[0].maxX(), f2 = 0.3 * (d2[1] - d2[3]);
        if (t3 = s.Z.evaluate(this.visProp.inverse) ? 1 : 3, this.dataX = [], this.dataY = [], 0 !== (o2 = e2[0].points.length))
          for (d2[1] += f2, d2[3] -= f2, r4 = -1; r4 < o2 - 1; ) {
            for (n3 = r4 + 1, i3 = o2; n3 < o2; n3++)
              if (e2[0].points[n3].isReal()) {
                i3 = n3;
                break;
              }
            if (i3 >= o2)
              break;
            for (n3 = i3, r4 = o2 - 1; n3 < o2 - 1; n3++)
              if (!e2[0].points[n3 + 1].isReal()) {
                r4 = n3;
                break;
              }
            for (l2 = e2[0].points[i3].usrCoords[1], c2 = e2[0].points[r4].usrCoords[1], a3 = d2[0] < p2 ? p2 : d2[0], h3 = d2[2] > _2 ? _2 : d2[2], a3 = 0 === i3 ? a3 : Math.max(a3, l2), h3 = r4 === o2 - 1 ? h3 : Math.min(h3, c2), h3 = r4 === o2 - 1 ? _2 : c2, (u2 = []).push([1, a3 = 0 === i3 ? p2 : l2, d2[t3]]), u2.push([1, a3, e2[0].points[i3].usrCoords[2]]), n3 = i3; n3 <= r4; n3++)
              u2.push(e2[0].points[n3].usrCoords);
            for (u2.push([1, h3, e2[0].points[r4].usrCoords[2]]), u2.push([1, h3, d2[t3]]), u2.push(u2[0]), n3 = 0; n3 < u2.length; n3++)
              this.dataX.push(u2[n3][1]), this.dataY.push(u2[n3][2]);
            r4 < o2 - 1 && (this.dataX.push(NaN), this.dataY.push(NaN));
          }
      }, a2.hasPoint = function() {
        return false;
      };
    else if (n2 = s.Z.createFunction(e2[0]), a2.addParentsFromJCFunctions([n2]), !s.Z.exists(n2))
      throw new Error("JSXGraph: Can't create area with the given parents.\nPossible parent types: [line], [function]");
    return a2.addParents(e2[0]), a2;
  }, t.Z.registerElement("arrowparallel", t.Z.createArrowParallel), t.Z.registerElement("bisector", t.Z.createBisector), t.Z.registerElement("bisectorlines", t.Z.createAngularBisectorsOfTwoLines), t.Z.registerElement("msector", t.Z.createMsector), t.Z.registerElement("circumcircle", t.Z.createCircumcircle), t.Z.registerElement("circumcirclemidpoint", t.Z.createCircumcenter), t.Z.registerElement("circumcenter", t.Z.createCircumcenter), t.Z.registerElement("incenter", t.Z.createIncenter), t.Z.registerElement("incircle", t.Z.createIncircle), t.Z.registerElement("integral", t.Z.createIntegral), t.Z.registerElement("midpoint", t.Z.createMidpoint), t.Z.registerElement("mirrorelement", t.Z.createMirrorElement), t.Z.registerElement("mirrorpoint", t.Z.createMirrorPoint), t.Z.registerElement("normal", t.Z.createNormal), t.Z.registerElement("orthogonalprojection", t.Z.createOrthogonalProjection), t.Z.registerElement("parallel", t.Z.createParallel), t.Z.registerElement("parallelpoint", t.Z.createParallelPoint), t.Z.registerElement("perpendicular", t.Z.createPerpendicular), t.Z.registerElement("perpendicularpoint", t.Z.createPerpendicularPoint), t.Z.registerElement("perpendicularsegment", t.Z.createPerpendicularSegment), t.Z.registerElement("reflection", t.Z.createReflection), t.Z.registerElement("grid", t.Z.createGrid), t.Z.registerElement("inequality", t.Z.createInequality), t.Z.createLocus = function(t2, e2, i3) {
    var r3, o2;
    if (!s.Z.isArray(e2) || 1 !== e2.length || !s.Z.isPoint(e2[0]))
      throw new Error("JSXGraph: Can't create locus with parent of type other than point.\nPossible parent types: [point]");
    return o2 = e2[0], (r3 = t2.create("curve", [[null], [null]], i3)).dontCallServer = false, r3.elType = "locus", r3.setParents([o2.id]), r3.updateDataArray = function() {
      var e3, i4, s2;
      r3.board.mode > 0 || (e3 = S.generatePolynomials(t2, o2, true).join("|")) !== r3.spe && (r3.spe = e3, i4 = function(t3, e4, i5, s3) {
        var o3;
        r3.dataX = t3, r3.dataY = e4, r3.eq = i5, r3.ctime = s3, r3.generatePolynomial = (o3 = i5, function(t4) {
          var e5, i6 = "(" + t4.symbolic.x + ")", s4 = "(" + t4.symbolic.y + ")", r4 = [];
          for (e5 = 0; e5 < o3.length; e5++)
            r4[e5] = o3[e5].replace(/\*\*/g, "^").replace(/x/g, i6).replace(/y/g, s4);
          return r4;
        });
      }, i4((s2 = S.geometricLocusByGroebnerBase(t2, o2, i4)).datax, s2.datay, s2.polynomial, s2.exectime));
    }, r3;
  }, t.Z.registerElement("locus", t.Z.createLocus);
  __webpack_require__(573);
  t.Z.Image = function(e2, r3, o2, n2, a2) {
    this.constructor(e2, o2, i2.Z.OBJECT_TYPE_IMAGE, i2.Z.OBJECT_CLASS_OTHER), this.element = this.board.select(o2.anchor), this.coordsConstructor(r3), this.W = s.Z.createFunction(a2[0], this.board, ""), this.H = s.Z.createFunction(a2[1], this.board, ""), this.addParentsFromJCFunctions([this.W, this.H]), this.usrSize = [this.W(), this.H()], this.size = [Math.abs(this.usrSize[0] * e2.unitX), Math.abs(this.usrSize[1] * e2.unitY)], this.url = n2, this.elType = "image", this.span = [this.coords.usrCoords.slice(0), [this.coords.usrCoords[0], this.W(), 0], [this.coords.usrCoords[0], 0, this.H()]], this.id = this.board.setId(this, "Im"), this.board.renderer.drawImage(this), this.board.finalizeAdding(this), this.methodMap = t.Z.deepCopy(this.methodMap, { addTransformation: "addTransform", trans: "addTransform" });
  }, t.Z.Image.prototype = new J.Z(), s.Z.copyPrototypeMethods(t.Z.Image, G.Z, "coordsConstructor"), t.Z.extend(t.Z.Image.prototype, { hasPoint: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, u2, p2, _2, f2 = this.transformations.length;
    return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (h2 = this.board._inputDevice, l2 = s.Z.evaluate(this.visProp.precision[h2])) : l2 = this.board.options.precision.hasPoint, 0 === f2 ? (r3 = t2 - this.coords.scrCoords[1], n2 = this.coords.scrCoords[2] - e2, r3 >= -(a2 = l2) && r3 - this.size[0] <= a2 && n2 >= -a2 && n2 - this.size[1] <= a2) : (u2 = [(d2 = (d2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e2], this.board)).usrCoords)[0] - this.span[0][0], d2[1] - this.span[0][1], d2[2] - this.span[0][2]], 0 <= (p2 = (_2 = o.Z.innerProduct)(u2, this.span[1])) && p2 <= _2(this.span[1], this.span[1]) && 0 <= (p2 = _2(u2, this.span[2])) && p2 <= _2(this.span[2], this.span[2]));
  }, update: function(t2) {
    return this.needsUpdate ? (this.updateCoords(t2), this.updateSize(), this.updateSpan(), this) : this;
  }, updateRenderer: function() {
    return this.updateRendererGeneric("updateImage");
  }, updateSize: function() {
    return this.usrSize = [this.W(), this.H()], this.size = [Math.abs(this.usrSize[0] * this.board.unitX), Math.abs(this.usrSize[1] * this.board.unitY)], this;
  }, updateSpan: function() {
    var t2, e2, i3 = this.transformations.length, s2 = [];
    if (0 === i3)
      this.span = [[this.Z(), this.X(), this.Y()], [this.Z(), this.W(), 0], [this.Z(), 0, this.H()]];
    else {
      for (s2[0] = [this.Z(), this.X(), this.Y()], s2[1] = [this.Z(), this.X() + this.W(), this.Y()], s2[2] = [this.Z(), this.X(), this.Y() + this.H()], t2 = 0; t2 < i3; t2++)
        for (e2 = 0; e2 < 3; e2++)
          s2[e2] = o.Z.matVecMult(this.transformations[t2].matrix, s2[e2]);
      for (e2 = 0; e2 < 3; e2++)
        s2[e2][1] /= s2[e2][0], s2[e2][2] /= s2[e2][0], s2[e2][0] /= s2[e2][0];
      for (e2 = 1; e2 < 3; e2++)
        s2[e2][0] -= s2[0][0], s2[e2][1] -= s2[0][1], s2[e2][2] -= s2[0][2];
      this.span = s2;
    }
    return this;
  }, addTransform: function(t2) {
    var e2;
    if (s.Z.isArray(t2))
      for (e2 = 0; e2 < t2.length; e2++)
        this.transformations.push(t2[e2]);
    else
      this.transformations.push(t2);
    return this;
  }, getParents: function() {
    var t2 = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];
    return 0 !== this.parents.length && (t2 = this.parents), t2;
  }, setSize: function(t2, e2) {
    return this.W = s.Z.createFunction(t2, this.board, ""), this.H = s.Z.createFunction(e2, this.board, ""), this.addParentsFromJCFunctions([this.W, this.H]), this;
  }, W: function() {
  }, H: function() {
  } }), t.Z.createImage = function(e2, i3, r3) {
    var o2, n2, a2 = i3[0], h2 = i3[1], l2 = i3[2];
    if (o2 = s.Z.copyAttributes(r3, e2.options, "image"), !(n2 = G.Z.create(t.Z.Image, e2, h2, o2, a2, l2)))
      throw new Error("JSXGraph: Can't create image with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
    return 0 !== o2.rotate && n2.addRotation(o2.rotate), n2;
  }, t.Z.registerElement("image", t.Z.createImage);
  t.Z.Image;
  t.Z.createSlider = function(t2, e2, r3) {
    var n2, a2, h2, l2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2;
    return P2 = (w2 = s.Z.copyAttributes(r3, t2.options, "slider")).withticks, y2 = w2.withlabel, E2 = w2.snapwidth, w2 = s.Z.copyAttributes(r3, t2.options, "slider", "point1"), p2 = t2.create("point", e2[0], w2), w2 = s.Z.copyAttributes(r3, t2.options, "slider", "point2"), _2 = t2.create("point", e2[1], w2), w2 = s.Z.copyAttributes(r3, t2.options, "slider", "baseline"), (b2 = t2.create("segment", [p2, _2], w2)).updateStdform(), n2 = p2.coords.usrCoords.slice(1), a2 = _2.coords.usrCoords.slice(1), h2 = e2[2][0], l2 = e2[2][1], d2 = e2[2][2], u2 = d2 - h2, x2 = -1 === (O2 = s.Z.evaluate(E2)) ? l2 : Math.round(l2 / O2) * O2, Z2 = n2[0] + (a2[0] - n2[0]) * (x2 - h2) / (d2 - h2), C2 = n2[1] + (a2[1] - n2[1]) * (x2 - h2) / (d2 - h2), (w2 = s.Z.copyAttributes(r3, t2.options, "slider")).withLabel = false, (f2 = t2.create("glider", [Z2, C2, b2], w2)).setAttribute({ snapwidth: E2 }), w2 = s.Z.copyAttributes(r3, t2.options, "slider", "highline"), g2 = t2.create("segment", [p2, f2], w2), f2.Value = function() {
      var t3 = this._smax - this._smin, e3 = s.Z.evaluate(this.visProp.snapwidth);
      return -1 === e3 ? this.position * t3 + this._smin : Math.round((this.position * t3 + this._smin) / e3) * e3;
    }, f2.methodMap = s.Z.deepCopy(f2.methodMap, { Value: "Value", setValue: "setValue", smax: "_smax", smin: "_smin", setMax: "setMax", setMin: "setMin" }), f2._smax = d2, f2._smin = h2, f2.setMax = function(t3) {
      return this._smax = t3, this;
    }, f2.setValue = function(t3) {
      var e3 = this._smax - this._smin;
      return Math.abs(e3) > o.Z.eps ? this.position = (t3 - this._smin) / e3 : this.position = 0, this.position = Math.max(0, Math.min(1, this.position)), this;
    }, f2.setMin = function(t3) {
      return this._smin = t3, this;
    }, y2 && (w2 = s.Z.copyAttributes(r3, t2.options, "slider", "label"), v2 = t2.create("text", [function() {
      return 0.05 * (_2.X() - p2.X()) + _2.X();
    }, function() {
      return 0.05 * (_2.Y() - p2.Y()) + _2.Y();
    }, function() {
      var t3, e3 = s.Z.evaluate(f2.visProp.digits), i3 = s.Z.evaluate(f2.visProp.suffixlabel), r4 = s.Z.evaluate(f2.visProp.unitlabel), o2 = s.Z.evaluate(f2.visProp.postlabel);
      return 2 === e3 && 2 !== s.Z.evaluate(f2.visProp.precision) && (e3 = s.Z.evaluate(f2.visProp.precision)), t3 = null !== i3 ? i3 : f2.name && "" !== f2.name ? f2.name + " = " : "", t3 += s.Z.toFixed(f2.Value(), e3), null !== r4 && (t3 += r4), null !== o2 && (t3 += o2), t3;
    }], w2), f2.label = v2, f2.visProp.withlabel = true, f2.hasLabel = true), f2.point1 = p2, f2.point2 = _2, f2.baseline = b2, f2.highline = g2, P2 && (w2 = s.Z.copyAttributes(r3, t2.options, "slider", "ticks"), s.Z.exists(w2.generatelabeltext) || (w2.generateLabelText = function(t3, e3, i3) {
      var s2 = f2.point1.Dist(f2.point2), r4 = f2._smin, n3 = f2._smax, a3 = this.getDistanceFromZero(e3, t3) * (n3 - r4) / s2 + r4;
      return s2 < o.Z.eps || Math.abs(a3) < o.Z.eps ? "0" : this.formatLabelText(a3);
    }), m2 = t2.create("ticks", [f2.baseline, f2.point1.Dist(p2) / 2, function(t3) {
      var e3 = f2.point1.Dist(f2.point2), s2 = f2.point1.coords.distance(i2.Z.COORDS_BY_USER, t3);
      return e3 < o.Z.eps ? 0 : s2 / e3 * u2 + h2;
    }], w2), f2.ticks = m2), f2.remove = function() {
      y2 && t2.removeObject(v2), t2.removeObject(g2), t2.removeObject(b2), t2.removeObject(_2), t2.removeObject(p2), z.prototype.remove.call(f2);
    }, p2.dump = false, _2.dump = false, b2.dump = false, g2.dump = false, y2 && (v2.dump = false), f2.elType = "slider", f2.parents = e2, f2.subs = { point1: p2, point2: _2, baseLine: b2, highLine: g2 }, f2.inherits.push(p2, _2, b2, g2), P2 && (m2.dump = false, f2.subs.ticks = m2, f2.inherits.push(m2)), f2.getParents = function() {
      return [this.point1.coords.usrCoords.slice(1), this.point2.coords.usrCoords.slice(1), [this._smin, this.position * (this._smax - this._smin) + this._smin, this._smax]];
    }, f2.baseline.on("up", function(t3) {
      var e3, r4;
      s.Z.evaluate(f2.visProp.moveonup) && !s.Z.evaluate(f2.visProp.fixed) && (e3 = b2.board.getMousePosition(t3, 0), r4 = new c.Z(i2.Z.COORDS_BY_SCREEN, e3, this.board), f2.moveTo([r4.usrCoords[1], r4.usrCoords[2]]), f2.triggerEventHandlers(["drag"], [t3]));
    }), f2.prepareUpdate().update(), t2.isSuspendedUpdate || (f2.updateVisibility().updateRenderer(), f2.baseline.updateVisibility().updateRenderer(), f2.highline.updateVisibility().updateRenderer(), P2 && f2.ticks.updateVisibility().updateRenderer()), f2;
  }, t.Z.registerElement("slider", t.Z.createSlider), t.Z.createTapemeasure = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2;
    return o2 = i3[0], n2 = i3[1], a2 = s.Z.copyAttributes(r3, e2.options, "tapemeasure", "point1"), u2 = e2.create("point", o2, a2), a2 = s.Z.copyAttributes(r3, e2.options, "tapemeasure", "point2"), p2 = e2.create("point", n2, a2), u2.setAttribute({ ignoredSnapToPoints: [p2] }), p2.setAttribute({ ignoredSnapToPoints: [u2] }), a2 = s.Z.copyAttributes(r3, e2.options, "tapemeasure"), h2 = a2.withticks, l2 = a2.withlabel, 2 === (c2 = a2.digits) && 2 !== a2.precision && (c2 = a2.precision), l2 && (a2.withlabel = true), d2 = e2.create("segment", [u2, p2], a2), l2 && (_2 = r3.name && "" !== r3.name ? r3.name + " = " : "", d2.label.setText(function() {
      return _2 + s.Z.toFixed(u2.Dist(p2), c2);
    })), h2 && (a2 = s.Z.copyAttributes(r3, e2.options, "tapemeasure", "ticks"), f2 = e2.create("ticks", [d2, 0.1], a2), d2.inherits.push(f2)), d2.remove = function() {
      h2 && d2.removeTicks(f2), e2.removeObject(p2), e2.removeObject(u2), J.Z.prototype.remove.call(this);
    }, d2.Value = function() {
      return u2.Dist(p2);
    }, u2.dump = false, p2.dump = false, d2.elType = "tapemeasure", d2.getParents = function() {
      return [[u2.X(), u2.Y()], [p2.X(), p2.Y()]];
    }, d2.subs = { point1: u2, point2: p2 }, h2 && (f2.dump = false), d2.methodMap = t.Z.deepCopy(d2.methodMap, { Value: "Value" }), d2.prepareUpdate().update(), e2.isSuspendedUpdate || (d2.updateVisibility().updateRenderer(), d2.point1.updateVisibility().updateRenderer(), d2.point2.updateVisibility().updateRenderer()), d2;
  }, t.Z.registerElement("tapemeasure", t.Z.createTapemeasure), t.Z.DataSource = function() {
    return this.data = [], this.columnHeaders = [], this.rowHeaders = [], this;
  }, t.Z.extend(t.Z.DataSource.prototype, { loadFromArray: function(t2, e2, i3) {
    var r3, o2, n2;
    if (s.Z.isArray(e2) && (this.columnHeaders = e2, e2 = false), s.Z.isArray(i3) && (this.rowHeaders = i3, i3 = false), this.data = [], e2 && (this.columnHeaders = []), i3 && (this.rowHeaders = []), s.Z.exists(t2)) {
      for (this.data = [], r3 = 0; r3 < t2.length; r3++)
        for (this.data[r3] = [], o2 = 0; o2 < t2[r3].length; o2++)
          n2 = t2[r3][o2], parseFloat(n2).toString() === n2 ? this.data[r3][o2] = parseFloat(n2) : this.data[r3][o2] = "-" !== n2 ? n2 : NaN;
      if (e2 && (this.columnHeaders = this.data[0].slice(1), this.data = this.data.slice(1)), i3)
        for (this.rowHeaders = [], r3 = 0; r3 < this.data.length; r3++)
          this.rowHeaders.push(this.data[r3][0]), this.data[r3] = this.data[r3].slice(1);
    }
    return this;
  }, loadFromTable: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2;
    if (s.Z.isArray(e2) && (this.columnHeaders = e2, e2 = false), s.Z.isArray(i3) && (this.rowHeaders = i3, i3 = false), this.data = [], e2 && (this.columnHeaders = []), i3 && (this.rowHeaders = []), t2 = document.getElementById(t2), s.Z.exists(t2)) {
      for (r3 = t2.getElementsByTagName("tr"), this.data = [], o2 = 0; o2 < r3.length; o2++)
        for (a2 = r3[o2].getElementsByTagName("td"), this.data[o2] = [], n2 = 0; n2 < a2.length; n2++)
          h2 = a2[n2].innerHTML, parseFloat(h2).toString() === h2 ? this.data[o2][n2] = parseFloat(h2) : this.data[o2][n2] = "-" !== h2 ? h2 : NaN;
      if (e2 && (this.columnHeaders = this.data[0].slice(1), this.data = this.data.slice(1)), i3)
        for (this.rowHeaders = [], o2 = 0; o2 < this.data.length; o2++)
          this.rowHeaders.push(this.data[o2][0]), this.data[o2] = this.data[o2].slice(1);
    }
    return this;
  }, addColumn: function(t2, e2, i3) {
    throw new Error("not implemented");
  }, addRow: function(t2, e2, i3) {
    throw new Error("not implemented");
  }, getColumn: function(t2) {
    var e2, i3 = [];
    if (s.Z.isString(t2)) {
      for (e2 = 0; e2 < this.columnHeaders.length; e2++)
        if (t2 === this.columnHeaders[e2]) {
          t2 = e2;
          break;
        }
    }
    for (e2 = 0; e2 < this.data.length; e2++)
      this.data[e2].length > t2 && (i3[e2] = parseFloat(this.data[e2][t2]));
    return i3;
  }, getRow: function(t2) {
    var e2, i3;
    if (s.Z.isString(t2)) {
      for (i3 = 0; i3 < this.rowHeaders.length; i3++)
        if (t2 === this.rowHeaders[i3]) {
          t2 = i3;
          break;
        }
    }
    for (e2 = [], i3 = 0; i3 < this.data[t2].length; i3++)
      e2[i3] = this.data[t2][i3];
    return e2;
  } });
  const V = t.Z.DataSource;
  t.Z.Chart = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2;
    if (this.constructor(t2, i3), !s.Z.isArray(e2) || 0 === e2.length)
      throw new Error("JSXGraph: Can't create a chart without data");
    if (this.elements = [], s.Z.isNumber(e2[0]))
      for (o2 = e2, r3 = [], n2 = 0; n2 < o2.length; n2++)
        r3[n2] = n2 + 1;
    else if (1 === e2.length && s.Z.isArray(e2[0]))
      for (o2 = e2[0], r3 = [], l2 = s.Z.evaluate(o2).length, n2 = 0; n2 < l2; n2++)
        r3[n2] = n2 + 1;
    else
      2 === e2.length && (l2 = Math.min(e2[0].length, e2[1].length), r3 = e2[0].slice(0, l2), o2 = e2[1].slice(0, l2));
    if (s.Z.isArray(o2) && 0 === o2.length)
      throw new Error("JSXGraph: Can't create charts without data.");
    for (h2 = i3.chartstyle.replace(/ /g, "").split(","), n2 = 0; n2 < h2.length; n2++) {
      switch (h2[n2]) {
        case "bar":
          a2 = this.drawBar(t2, r3, o2, i3);
          break;
        case "line":
          a2 = this.drawLine(t2, r3, o2, i3);
          break;
        case "fit":
          a2 = this.drawFit(t2, r3, o2, i3);
          break;
        case "spline":
          a2 = this.drawSpline(t2, r3, o2, i3);
          break;
        case "pie":
          a2 = this.drawPie(t2, o2, i3);
          break;
        case "point":
          a2 = this.drawPoints(t2, r3, o2, i3);
          break;
        case "radar":
          a2 = this.drawRadar(t2, e2, i3);
      }
      this.elements.push(a2);
    }
    return this.id = this.board.setId(this, "Chart"), this.elements;
  }, t.Z.Chart.prototype = new J.Z(), t.Z.extend(t.Z.Chart.prototype, { drawLine: function(t2, e2, i3, s2) {
    return s2.fillcolor = "none", s2.highlightfillcolor = "none", t2.create("curve", [e2, i3], s2);
  }, drawSpline: function(t2, e2, i3, s2) {
    return s2.fillColor = "none", s2.highlightfillcolor = "none", t2.create("spline", [e2, i3], s2);
  }, drawFit: function(t2, e2, i3, s2) {
    var r3 = s2.degree;
    return r3 = Math.max(parseInt(r3, 10), 1) || 1, s2.fillcolor = "none", s2.highlightfillcolor = "none", t2.create("functiongraph", [l.Z.regressionPolynomial(r3, e2, i3)], s2);
  }, drawBar: function(t2, e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2 = [], b2 = [], g2 = function(t3, i4) {
      return function() {
        return e2[t3]() - i4 * a2;
      };
    }, m2 = { fixed: true, withLabel: false, visible: false, name: "" };
    if ((p2 = s.Z.copyAttributes(r3, t2.options, "chart")) && p2.width)
      a2 = p2.width;
    else {
      if (e2.length <= 1)
        a2 = 1;
      else
        for (a2 = e2[1] - e2[0], o2 = 1; o2 < e2.length - 1; o2++)
          a2 = e2[o2 + 1] - e2[o2] < a2 ? e2[o2 + 1] - e2[o2] : a2;
      a2 *= 0.8;
    }
    for (_2 = s.Z.copyAttributes(r3, t2.options, "chart", "label"), o2 = 0; o2 < e2.length; o2++)
      s.Z.isFunction(e2[o2]) ? (h2 = g2(o2, -0.5), l2 = g2(o2, 0), c2 = g2(o2, 0.5)) : (h2 = e2[o2] - 0.5 * a2, l2 = e2[o2], c2 = e2[o2] + 0.5 * a2), d2 = s.Z.isFunction(i3[o2]) ? i3[o2]() : i3[o2], d2 = i3[o2], "horizontal" === p2.dir ? (b2[0] = t2.create("point", [0, h2], m2), b2[1] = t2.create("point", [d2, h2], m2), b2[2] = t2.create("point", [d2, c2], m2), b2[3] = t2.create("point", [0, c2], m2), s.Z.exists(p2.labels) && s.Z.exists(p2.labels[o2]) && (_2.anchorY = "middle", (n2 = t2.create("text", [d2, l2, p2.labels[o2]], _2)).visProp.anchorx = function(t3) {
        return function() {
          return t3.X() >= 0 ? "left" : "right";
        };
      }(n2))) : (b2[0] = t2.create("point", [h2, 0], m2), b2[1] = t2.create("point", [h2, d2], m2), b2[2] = t2.create("point", [c2, d2], m2), b2[3] = t2.create("point", [c2, 0], m2), s.Z.exists(p2.labels) && s.Z.exists(p2.labels[o2]) && (_2.anchorX = "middle", (n2 = t2.create("text", [l2, d2, p2.labels[o2]], _2)).visProp.anchory = function(t3) {
        return function() {
          return t3.Y() >= 0 ? "bottom" : "top";
        };
      }(n2))), s.Z.isArray(p2.colors) && (u2 = p2.colors, p2.fillcolor = u2[o2 % u2.length]), f2[o2] = t2.create("polygon", b2, p2), s.Z.exists(p2.labels) && s.Z.exists(p2.labels[o2]) && (f2[o2].text = n2);
    return f2;
  }, drawPoints: function(t2, e2, i3, s2) {
    var r3, o2 = [], n2 = s2.infoboxarray;
    for (s2.fixed = true, s2.name = "", r3 = 0; r3 < e2.length; r3++)
      s2.infoboxtext = !!n2 && n2[r3 % n2.length], o2[r3] = t2.create("point", [e2[r3], i3[r3]], s2);
    return o2;
  }, drawPie: function(t2, e2, r3) {
    var o2, n2, a2 = [], h2 = [], l2 = (d.Z.sum(e2), r3.colors), u2 = r3.highlightcolors, p2 = r3.labels, _2 = r3.radius || 4, f2 = _2, b2 = r3.center || [0, 0], g2 = b2[0], m2 = b2[1], v2 = function(t3, i3, r4) {
      return function() {
        var o3, n3, a3, h3 = 0;
        for (n3 = 0; n3 <= t3; n3++)
          h3 += parseFloat(s.Z.evaluate(e2[n3]));
        for (o3 = h3, n3 = t3 + 1; n3 < e2.length; n3++)
          o3 += parseFloat(s.Z.evaluate(e2[n3]));
        return a3 = 0 !== o3 ? 2 * Math.PI * h3 / o3 : 0, f2() * Math[i3](a3) + r4;
      };
    }, Z2 = function(t3, e3) {
      var r4 = -this.point1.coords.usrCoords[1] + this.point2.coords.usrCoords[1], o3 = -this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[2];
      s.Z.exists(this.label) && (this.label.rendNode.style.fontSize = e3 * s.Z.evaluate(this.label.visProp.fontsize) + "px", this.label.fullUpdate()), this.point2.coords = new c.Z(i2.Z.COORDS_BY_USER, [this.point1.coords.usrCoords[1] + r4 * t3, this.point1.coords.usrCoords[2] + o3 * t3], this.board), this.fullUpdate();
    }, C2 = function() {
      this.highlighted || (this.highlighted = true, this.board.highlightedObjects[this.id] = this, this.board.renderer.highlight(this), Z2.call(this, 1.1, 2));
    }, y2 = function() {
      this.highlighted && (this.highlighted = false, this.board.renderer.noHighlight(this), Z2.call(this, 0.9090909, 1));
    }, P2 = { fixed: true, withLabel: false, visible: false, name: "" };
    if (!s.Z.isArray(p2))
      for (p2 = [], o2 = 0; o2 < e2.length; o2++)
        p2[o2] = "";
    for (s.Z.isFunction(_2) || (f2 = function() {
      return _2;
    }), r3.highlightonsector = r3.highlightonsector || false, r3.straightfirst = false, r3.straightlast = false, n2 = t2.create("point", [g2, m2], P2), a2[0] = t2.create("point", [function() {
      return f2() + g2;
    }, function() {
      return m2;
    }], P2), o2 = 0; o2 < e2.length; o2++)
      a2[o2 + 1] = t2.create("point", [v2(o2, "cos", g2), v2(o2, "sin", m2)], P2), r3.name = p2[o2], r3.withlabel = "" !== r3.name, r3.fillcolor = l2 && l2[o2 % l2.length], r3.labelcolor = l2 && l2[o2 % l2.length], r3.highlightfillcolor = u2 && u2[o2 % u2.length], h2[o2] = t2.create("sector", [n2, a2[o2], a2[o2 + 1]], r3), r3.highlightonsector && (h2[o2].hasPoint = h2[o2].hasPointSector), r3.highlightbysize && (h2[o2].highlight = C2, h2[o2].noHighlight = y2);
    return { sectors: h2, points: a2, midpoint: n2 };
  }, drawRadar: function(e2, r3, o2) {
    var n2, a2, h2, l2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2, P2, E2, O2, x2, w2, S2, T2, M2, N2, A2, k2, R2, D2, L2, B2, I2, Y2, j2, X2, U2, F2, J2, G2, z2, H2, W2, V2 = r3.length, $2 = function() {
      var t2, e3, r4, o3, n3 = s.Z.evaluate(this.visProp.label.offset).slice(0);
      return t2 = this.point1.X(), e3 = this.point2.X(), r4 = this.point1.Y(), o3 = this.point2.Y(), e3 < t2 && (n3[0] = -n3[0]), o3 < r4 && (n3[1] = -n3[1]), this.setLabelRelativeCoords(n3), new c.Z(i2.Z.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
    }, K2 = function(t2, i3) {
      var s2, r4, o3;
      return s2 = e2.create("transform", [-(C2[i3] - v2[i3]), 0], { type: "translate" }), r4 = e2.create("transform", [O2 / (y2[i3] + Z2[i3] - (C2[i3] - v2[i3])), 1], { type: "scale" }), s2.melt(r4), o3 = e2.create("transform", [t2], { type: "rotate" }), s2.melt(o3), s2;
    };
    if (V2 <= 0)
      throw new Error("JSXGraph radar chart: no data");
    if (h2 = o2.paramarray, !s.Z.exists(h2))
      throw new Error("JSXGraph radar chart: need paramArray attribute");
    if ((l2 = h2.length) <= 1)
      throw new Error("JSXGraph radar chart: need more than one param in paramArray");
    for (n2 = 0; n2 < V2; n2++)
      if (l2 !== r3[n2].length)
        throw new Error("JSXGraph radar chart: use data length equal to number of params (" + r3[n2].length + " != " + l2 + ")");
    for (d2 = [], u2 = [], a2 = 0; a2 < l2; a2++)
      d2[a2] = r3[0][a2], u2[a2] = d2[a2];
    for (n2 = 1; n2 < V2; n2++)
      for (a2 = 0; a2 < l2; a2++)
        r3[n2][a2] > d2[a2] && (d2[a2] = r3[n2][a2]), r3[n2][a2] < u2[a2] && (u2[a2] = r3[n2][a2]);
    for (p2 = [], _2 = [], n2 = 0; n2 < V2; n2++)
      p2[n2] = "", _2[n2] = [];
    for (f2 = [], b2 = [], g2 = o2.startshiftratio || 0, m2 = o2.endshiftratio || 0, n2 = 0; n2 < l2; n2++)
      f2[n2] = (d2[n2] - u2[n2]) * g2, b2[n2] = (d2[n2] - u2[n2]) * m2;
    if (v2 = o2.startshiftarray || f2, Z2 = o2.endshiftarray || b2, C2 = o2.startarray || u2, s.Z.exists(o2.start))
      for (n2 = 0; n2 < l2; n2++)
        C2[n2] = o2.start;
    if (y2 = o2.endarray || d2, s.Z.exists(o2.end))
      for (n2 = 0; n2 < l2; n2++)
        y2[n2] = o2.end;
    if (v2.length !== l2)
      throw new Error("JSXGraph radar chart: start shifts length is not equal to number of parameters");
    if (Z2.length !== l2)
      throw new Error("JSXGraph radar chart: end shifts length is not equal to number of parameters");
    if (C2.length !== l2)
      throw new Error("JSXGraph radar chart: starts length is not equal to number of parameters");
    if (y2.length !== l2)
      throw new Error("JSXGraph radar chart: snds length is not equal to number of parameters");
    for (P2 = o2.labelarray || p2, E2 = o2.colors, o2.highlightcolors, O2 = o2.radius || 10, H2 = o2.strokewidth || 1, s.Z.exists(o2.highlightonsector) || (o2.highlightonsector = false), x2 = { name: o2.name, id: o2.id, strokewidth: H2, polystrokewidth: o2.polystrokewidth || H2, strokecolor: o2.strokecolor || "black", straightfirst: false, straightlast: false, fillcolor: o2.fillColor || "#FFFF88", fillopacity: o2.fillOpacity || 0.4, highlightfillcolor: o2.highlightFillColor || "#FF7400", highlightstrokecolor: o2.highlightStrokeColor || "black", gradient: o2.gradient || "none" }, S2 = (w2 = o2.center || [0, 0])[0], T2 = w2[1], M2 = e2.create("point", [S2, T2], { name: "", fixed: true, withlabel: false, visible: false }), A2 = N2 = o2.startangle || 0, k2 = [], R2 = [], n2 = 0; n2 < l2; n2++)
      for (A2 += 2 * Math.PI / l2, L2 = O2 * Math.cos(A2) + S2, B2 = O2 * Math.sin(A2) + T2, k2[n2] = e2.create("point", [L2, B2], { name: "", fixed: true, withlabel: false, visible: false }), R2[n2] = e2.create("line", [M2, k2[n2]], { name: h2[n2], strokeColor: x2.strokecolor, strokeWidth: x2.strokewidth, strokeOpacity: 1, straightFirst: false, straightLast: false, withLabel: true, highlightStrokeColor: x2.highlightstrokecolor }), R2[n2].getLabelAnchor = $2, D2 = K2(A2, n2), a2 = 0; a2 < r3.length; a2++)
        W2 = r3[a2][n2], _2[a2][n2] = e2.create("point", [W2, 0], { name: "", fixed: true, withlabel: false, visible: false }), _2[a2][n2].addTransform(_2[a2][n2], D2);
    for (I2 = [], n2 = 0; n2 < V2; n2++)
      for (x2.labelcolor = E2 && E2[n2 % E2.length], x2.strokecolor = E2 && E2[n2 % E2.length], x2.fillcolor = E2 && E2[n2 % E2.length], I2[n2] = e2.create("polygon", _2[n2], { withLines: true, withLabel: false, fillColor: x2.fillcolor, fillOpacity: x2.fillopacity, highlightFillColor: x2.highlightfillcolor }), a2 = 0; a2 < l2; a2++)
        I2[n2].borders[a2].setAttribute("strokecolor:" + E2[n2 % E2.length]), I2[n2].borders[a2].setAttribute("strokewidth:" + x2.polystrokewidth);
    switch (o2.legendposition || "none") {
      case "right":
        j2 = o2.legendleftoffset || 2, X2 = o2.legendtopoffset || 1, this.legend = e2.create("legend", [S2 + O2 + j2, T2 + O2 - X2], { labels: P2, colors: E2 });
        break;
      case "none":
        break;
      default:
        t.Z.debug("Unknown legend position");
    }
    if (Y2 = [], o2.showcircles) {
      for (U2 = [], n2 = 0; n2 < 6; n2++)
        U2[n2] = 20 * n2;
      if (U2[0] = "0", (J2 = (F2 = o2.circlelabelarray || U2).length) < 2)
        throw new Error("JSXGraph radar chart: too less circles in circleLabelArray");
      for (G2 = [], D2 = K2(N2 + Math.PI / l2, 0), x2.fillcolor = "none", x2.highlightfillcolor = "none", x2.strokecolor = o2.strokecolor || "black", x2.strokewidth = o2.circlestrokewidth || 0.5, x2.layer = 0, z2 = (y2[0] - C2[0]) / (J2 - 1), n2 = 0; n2 < J2; n2++)
        G2[n2] = e2.create("point", [C2[0] + n2 * z2, 0], { name: F2[n2], size: 0, fixed: true, withLabel: true, visible: true }), G2[n2].addTransform(G2[n2], D2), Y2[n2] = e2.create("circle", [M2, G2[n2]], x2);
    }
    return this.rendNode = I2[0].rendNode, { circles: Y2, lines: R2, points: _2, midpoint: M2, polygons: I2 };
  }, updateRenderer: function() {
    return this;
  }, update: function() {
    return this.needsUpdate && this.updateDataArray(), this;
  }, updateDataArray: function() {
    return this;
  } }), t.Z.createChart = function(i3, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2 = [], P2 = e.Z.isBrowser ? i3.document.getElementById(r3[0]) : null;
    if (1 === r3.length && s.Z.isString(r3[0])) {
      if (s.Z.exists(P2)) {
        if (_2 = s.Z.copyAttributes(o2, i3.options, "chart"), n2 = (P2 = new V().loadFromTable(r3[0], _2.withheaders, _2.withheaders)).data, c2 = P2.columnHeaders, a2 = P2.rowHeaders, f2 = _2.width, b2 = _2.name, g2 = _2.strokecolor, m2 = _2.fillcolor, v2 = _2.highlightstrokecolor, Z2 = _2.highlightfillcolor, i3.suspendUpdate(), C2 = n2.length, p2 = [], _2.rows && s.Z.isArray(_2.rows)) {
          for (h2 = 0; h2 < C2; h2++)
            for (l2 = 0; l2 < _2.rows.length; l2++)
              if (_2.rows[l2] === h2 || _2.withheaders && _2.rows[l2] === a2[h2]) {
                p2.push(n2[h2]);
                break;
              }
        } else
          p2 = n2;
        for (C2 = p2.length, h2 = 0; h2 < C2; h2++) {
          if (u2 = [], _2.chartstyle && -1 !== _2.chartstyle.indexOf("bar")) {
            for (d2 = f2 || 0.8, u2.push(1 - d2 / 2 + (h2 + 0.5) * d2 / C2), l2 = 1; l2 < p2[h2].length; l2++)
              u2.push(u2[l2 - 1] + 1);
            _2.width = d2 / C2;
          }
          b2 && b2.length === C2 ? _2.name = b2[h2] : _2.withheaders && (_2.name = c2[h2]), g2 && g2.length === C2 ? _2.strokecolor = g2[h2] : _2.strokecolor = D.Z.hsv2rgb((h2 + 1) / C2 * 360, 0.9, 0.6), m2 && m2.length === C2 ? _2.fillcolor = m2[h2] : _2.fillcolor = D.Z.hsv2rgb((h2 + 1) / C2 * 360, 0.9, 1), v2 && v2.length === C2 ? _2.highlightstrokecolor = v2[h2] : _2.highlightstrokecolor = D.Z.hsv2rgb((h2 + 1) / C2 * 360, 0.9, 1), Z2 && Z2.length === C2 ? _2.highlightfillcolor = Z2[h2] : _2.highlightfillcolor = D.Z.hsv2rgb((h2 + 1) / C2 * 360, 0.9, 0.6), _2.chartstyle && -1 !== _2.chartstyle.indexOf("bar") ? y2.push(new t.Z.Chart(i3, [u2, p2[h2]], _2)) : y2.push(new t.Z.Chart(i3, [p2[h2]], _2));
        }
        i3.unsuspendUpdate();
      }
      return y2;
    }
    return _2 = s.Z.copyAttributes(o2, i3.options, "chart"), new t.Z.Chart(i3, r3, _2);
  }, t.Z.registerElement("chart", t.Z.createChart), t.Z.Legend = function(t2, e2, r3) {
    var o2;
    if (this.constructor(), o2 = s.Z.copyAttributes(r3, t2.options, "legend"), this.board = t2, this.coords = new c.Z(i2.Z.COORDS_BY_USER, e2, this.board), this.myAtts = {}, this.label_array = o2.labelarray || o2.labels, this.color_array = o2.colorarray || o2.colors, this.lines = [], this.myAtts.strokewidth = o2.strokewidth || 5, this.myAtts.straightfirst = false, this.myAtts.straightlast = false, this.myAtts.withlabel = true, this.myAtts.fixed = true, this.style = o2.legendstyle || o2.style, "vertical" !== this.style)
      throw new Error("JSXGraph: Unknown legend style: " + this.style);
    this.drawVerticalLegend(t2, o2);
  }, t.Z.Legend.prototype = new J.Z(), t.Z.Legend.prototype.drawVerticalLegend = function(t2, e2) {
    var r3, o2 = e2.linelength || 1, n2 = (e2.rowheight || 20) / this.board.unitY, a2 = function() {
      return this.setLabelRelativeCoords(this.visProp.label.offset), new c.Z(i2.Z.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
    };
    for (r3 = 0; r3 < this.label_array.length; r3++)
      this.myAtts.name = this.label_array[r3], this.myAtts.strokecolor = this.color_array[r3 % this.color_array.length], this.myAtts.highlightstrokecolor = this.color_array[r3 % this.color_array.length], this.myAtts.label = { offset: [10, 0], strokeColor: this.color_array[r3 % this.color_array.length], strokeWidth: this.myAtts.strokewidth }, this.lines[r3] = t2.create("line", [[this.coords.usrCoords[1], this.coords.usrCoords[2] - r3 * n2], [this.coords.usrCoords[1] + o2, this.coords.usrCoords[2] - r3 * n2]], this.myAtts), this.lines[r3].getLabelAnchor = a2, this.lines[r3].prepareUpdate().update().updateVisibility(s.Z.evaluate(this.lines[r3].visProp.visible)).updateRenderer();
  }, t.Z.createLegend = function(e2, i3, r3) {
    var o2 = [0, 0];
    if (!s.Z.exists(i3) || 2 !== i3.length)
      throw new Error("JSXGraph: Legend element needs two numbers as parameters");
    return o2 = i3, new t.Z.Legend(e2, o2, r3);
  }, t.Z.registerElement("legend", t.Z.createLegend);
  t.Z.Chart, t.Z.Legend;
  t.Z.Transformation = function(t2, e2, s2) {
    this.elementClass = i2.Z.OBJECT_CLASS_OTHER, this.type = i2.Z.OBJECT_TYPE_TRANSFORMATION, this.matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.board = t2, this.isNumericMatrix = false, this.setMatrix(t2, e2, s2), this.methodMap = { apply: "apply", applyOnce: "applyOnce", bindTo: "bindTo", bind: "bindTo", melt: "melt" };
  }, t.Z.Transformation.prototype = {}, t.Z.extend(t.Z.Transformation.prototype, { update: function() {
    return this;
  }, setMatrix: function(t2, e2, i3) {
    var r3;
    for (this.isNumericMatrix = true, r3 = 0; r3 < i3.length; r3++)
      if ("number" != typeof i3[r3]) {
        this.isNumericMatrix = false;
        break;
      }
    if ("translate" === e2) {
      if (2 !== i3.length)
        throw new Error("JSXGraph: translate transformation needs 2 parameters.");
      this.evalParam = s.Z.createEvalFunction(t2, i3, 2), this.update = function() {
        this.matrix[1][0] = this.evalParam(0), this.matrix[2][0] = this.evalParam(1);
      };
    } else if ("scale" === e2) {
      if (2 !== i3.length)
        throw new Error("JSXGraph: scale transformation needs 2 parameters.");
      this.evalParam = s.Z.createEvalFunction(t2, i3, 2), this.update = function() {
        this.matrix[1][1] = this.evalParam(0), this.matrix[2][2] = this.evalParam(1);
      };
    } else if ("reflect" === e2)
      i3.length < 4 && (i3[0] = t2.select(i3[0])), 2 === i3.length && (i3[1] = t2.select(i3[1])), 4 === i3.length && (this.evalParam = s.Z.createEvalFunction(t2, i3, 4)), this.update = function() {
        var t3, e3, s2, r4, n2, a2, h2, l2;
        1 === i3.length ? h2 = i3[0].stdform : 2 === i3.length ? h2 = o.Z.crossProduct(i3[1].coords.usrCoords, i3[0].coords.usrCoords) : 4 === i3.length && (h2 = o.Z.crossProduct([1, this.evalParam(2), this.evalParam(3)], [1, this.evalParam(0), this.evalParam(1)])), t3 = h2[1], e3 = h2[2], a2 = (l2 = [-(s2 = h2[0]) * t3, -s2 * e3, t3 * t3 + e3 * e3])[2], r4 = l2[0] / l2[2], n2 = l2[1] / l2[2], t3 = -h2[2], e3 = h2[1], this.matrix[1][1] = (t3 * t3 - e3 * e3) / a2, this.matrix[1][2] = 2 * t3 * e3 / a2, this.matrix[2][1] = this.matrix[1][2], this.matrix[2][2] = -this.matrix[1][1], this.matrix[1][0] = r4 * (1 - this.matrix[1][1]) - n2 * this.matrix[1][2], this.matrix[2][0] = n2 * (1 - this.matrix[2][2]) - r4 * this.matrix[2][1];
      };
    else if ("rotate" === e2)
      3 === i3.length ? this.evalParam = s.Z.createEvalFunction(t2, i3, 3) : i3.length > 0 && i3.length <= 2 && (this.evalParam = s.Z.createEvalFunction(t2, i3, 1), 2 !== i3.length || s.Z.isArray(i3[1]) || (i3[1] = t2.select(i3[1]))), this.update = function() {
        var t3, e3, r4 = this.evalParam(0), o2 = Math.cos(r4), n2 = Math.sin(r4);
        this.matrix[1][1] = o2, this.matrix[1][2] = -n2, this.matrix[2][1] = n2, this.matrix[2][2] = o2, i3.length > 1 && (3 === i3.length ? (t3 = this.evalParam(1), e3 = this.evalParam(2)) : s.Z.isArray(i3[1]) ? (t3 = i3[1][0], e3 = i3[1][1]) : (t3 = i3[1].X(), e3 = i3[1].Y()), this.matrix[1][0] = t3 * (1 - o2) + e3 * n2, this.matrix[2][0] = e3 * (1 - o2) - t3 * n2);
      };
    else if ("shear" === e2) {
      if (2 !== i3.length)
        throw new Error("JSXGraph: shear transformation needs 2 parameters.");
      this.evalParam = s.Z.createEvalFunction(t2, i3, 2), this.update = function() {
        this.matrix[1][2] = this.evalParam(0), this.matrix[2][1] = this.evalParam(1);
      };
    } else if ("generic" === e2) {
      if (9 !== i3.length)
        throw new Error("JSXGraph: generic transformation needs 9 parameters.");
      this.evalParam = s.Z.createEvalFunction(t2, i3, 9), this.update = function() {
        this.matrix[0][0] = this.evalParam(0), this.matrix[0][1] = this.evalParam(1), this.matrix[0][2] = this.evalParam(2), this.matrix[1][0] = this.evalParam(3), this.matrix[1][1] = this.evalParam(4), this.matrix[1][2] = this.evalParam(5), this.matrix[2][0] = this.evalParam(6), this.matrix[2][1] = this.evalParam(7), this.matrix[2][2] = this.evalParam(8);
      };
    }
  }, apply: function(t2, e2) {
    return this.update(), s.Z.exists(e2) ? o.Z.matVecMult(this.matrix, t2.initialCoords.usrCoords) : o.Z.matVecMult(this.matrix, t2.coords.usrCoords);
  }, applyOnce: function(t2) {
    var e2, r3, n2;
    for (s.Z.isArray(t2) || (t2 = [t2]), r3 = t2.length, n2 = 0; n2 < r3; n2++)
      this.update(), e2 = o.Z.matVecMult(this.matrix, t2[n2].coords.usrCoords), t2[n2].coords.setCoordinates(i2.Z.COORDS_BY_USER, e2);
  }, bindTo: function(t2) {
    var e2, i3;
    if (s.Z.isArray(t2))
      for (i3 = t2.length, e2 = 0; e2 < i3; e2++)
        t2[e2].transformations.push(this);
    else
      t2.transformations.push(this);
  }, setProperty: function(e2) {
    t.Z.deprecated("Transformation.setProperty()", "Transformation.setAttribute()");
  }, setAttribute: function(t2) {
  }, melt: function(t2) {
    var e2, i3, s2, r3, o2, n2, a2 = [];
    for (i3 = t2.matrix.length, s2 = this.matrix[0].length, e2 = 0; e2 < i3; e2++)
      a2[e2] = [];
    for (this.update(), t2.update(), e2 = 0; e2 < i3; e2++)
      for (n2 = 0; n2 < s2; n2++) {
        for (o2 = 0, r3 = 0; r3 < i3; r3++)
          o2 += t2.matrix[e2][r3] * this.matrix[r3][n2];
        a2[e2][n2] = o2;
      }
    return this.update = function() {
      var t3 = this.matrix.length, i4 = this.matrix[0].length;
      for (e2 = 0; e2 < t3; e2++)
        for (n2 = 0; n2 < i4; n2++)
          this.matrix[e2][n2] = a2[e2][n2];
    }, this;
  }, getParents: function() {
    var t2 = [[].concat.apply([], this.matrix)];
    return 0 !== this.parents.length && (t2 = this.parents), t2;
  } }), t.Z.createTransform = function(e2, i3, s2) {
    return new t.Z.Transformation(e2, s2.type, i3);
  }, t.Z.registerElement("transform", t.Z.createTransform);
  t.Z.Transformation;
  t.Z.Turtle = function(t2, e2, r3) {
    var o2, n2, a2;
    return this.constructor(t2, r3, i2.Z.OBJECT_TYPE_TURTLE, i2.Z.OBJECT_CLASS_OTHER), this.turtleIsHidden = false, this.board = t2, this.visProp.curveType = "plot", this._attributes = s.Z.copyAttributes(this.visProp, t2.options, "turtle"), delete this._attributes.id, o2 = 0, n2 = 0, a2 = 90, 0 !== e2.length && (3 === e2.length ? (o2 = e2[0], n2 = e2[1], a2 = e2[2]) : 2 === e2.length ? s.Z.isArray(e2[0]) ? (o2 = e2[0][0], n2 = e2[0][1], a2 = e2[1]) : (o2 = e2[0], n2 = e2[1]) : (o2 = e2[0][0], n2 = e2[0][1])), this.init(o2, n2, a2), this.methodMap = s.Z.deepCopy(this.methodMap, { forward: "forward", fd: "forward", back: "back", bk: "back", right: "right", rt: "right", left: "left", lt: "left", penUp: "penUp", pu: "penUp", penDown: "penDown", pd: "penDown", clearScreen: "clearScreen", cs: "clearScreen", clean: "clean", setPos: "setPos", home: "home", hideTurtle: "hideTurtle", ht: "hideTurtle", showTurtle: "showTurtle", st: "showTurtle", penSize: "setPenSize", penColor: "setPenColor", getPenColor: "getPenColor", getHighlightPenColor: "getHighlightPenColor", getPenSize: "getPenSize", pushTurtle: "pushTurtle", push: "pushTurtle", popTurtle: "popTurtle", pop: "popTurtle", lookTo: "lookTo", pos: "pos", moveTo: "moveTo", X: "X", Y: "Y" }), this;
  }, t.Z.Turtle.prototype = new J.Z(), t.Z.extend(t.Z.Turtle.prototype, { init: function(t2, e2, i3) {
    var s2 = { fixed: true, name: "", visible: false, withLabel: false };
    this.arrowLen = 20 / Math.sqrt(this.board.unitX * this.board.unitX + this.board.unitY * this.board.unitY), this.pos = [t2, e2], this.isPenDown = true, this.dir = 90, this.stack = [], this.objects = [], this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.turtle = this.board.create("point", this.pos, s2), this.objects.push(this.turtle), this.turtle2 = this.board.create("point", [this.pos[0], this.pos[1] + this.arrowLen], s2), this.objects.push(this.turtle2), this.visProp.arrow.lastArrow = true, this.visProp.arrow.straightFirst = false, this.visProp.arrow.straightLast = false, this.arrow = this.board.create("line", [this.turtle, this.turtle2], this.visProp.arrow), this.objects.push(this.arrow), this.subs = { arrow: this.arrow }, this.inherits.push(this.arrow), this.right(90 - i3), this.board.update();
  }, forward: function(t2) {
    if (0 === t2)
      return this;
    var e2, i3 = t2 * Math.cos(this.dir * Math.PI / 180), s2 = t2 * Math.sin(this.dir * Math.PI / 180);
    return this.turtleIsHidden || ((e2 = this.board.create("transform", [i3, s2], { type: "translate" })).applyOnce(this.turtle), e2.applyOnce(this.turtle2)), this.isPenDown && this.curve.dataX.length >= 8192 && (this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve)), this.pos[0] += i3, this.pos[1] += s2, this.isPenDown && (this.curve.dataX.push(this.pos[0]), this.curve.dataY.push(this.pos[1])), this.board.update(), this;
  }, back: function(t2) {
    return this.forward(-t2);
  }, right: function(t2) {
    (this.dir -= t2, this.dir %= 360, this.turtleIsHidden) || this.board.create("transform", [-t2 * Math.PI / 180, this.turtle], { type: "rotate" }).applyOnce(this.turtle2);
    return this.board.update(), this;
  }, left: function(t2) {
    return this.right(-t2);
  }, penUp: function() {
    return this.isPenDown = false, this;
  }, penDown: function() {
    return this.isPenDown = true, this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this;
  }, clean: function() {
    var t2, e2;
    for (t2 = 0; t2 < this.objects.length; t2++)
      (e2 = this.objects[t2]).type === i2.Z.OBJECT_TYPE_CURVE && (this.board.removeObject(e2), this.objects.splice(t2, 1));
    return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.board.update(), this;
  }, clearScreen: function() {
    var t2, e2, i3 = this.objects.length;
    for (t2 = 0; t2 < i3; t2++)
      e2 = this.objects[t2], this.board.removeObject(e2);
    return this.init(0, 0, 90), this;
  }, setPos: function(t2, e2) {
    return s.Z.isArray(t2) ? this.pos = t2 : this.pos = [t2, e2], this.turtleIsHidden || (this.turtle.setPositionDirectly(i2.Z.COORDS_BY_USER, [t2, e2]), this.turtle2.setPositionDirectly(i2.Z.COORDS_BY_USER, [t2, e2 + this.arrowLen]), this.board.create("transform", [-(this.dir - 90) * Math.PI / 180, this.turtle], { type: "rotate" }).applyOnce(this.turtle2)), this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.board.update(), this;
  }, setPenSize: function(t2) {
    return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("strokeWidth", t2)), this.objects.push(this.curve), this;
  }, setPenColor: function(t2) {
    return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("strokeColor", t2)), this.objects.push(this.curve), this;
  }, getPenAttribute: function(t2) {
    var e2, i3 = this.objects.length;
    return e2 = 4 === i3 ? 0 : i3 - 1, s.Z.evaluate(this.objects[e2].visProp[t2]);
  }, getPenSize: function() {
    return this.getPenAttribute("strokewidth");
  }, getPenColor: function() {
    return this.getPenAttribute("strokecolor");
  }, getHighlightPenColor: function() {
    return this.getPenAttribute("highlightstrokecolor");
  }, setHighlightPenColor: function(t2) {
    return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("highlightStrokeColor", t2)), this.objects.push(this.curve), this;
  }, setAttribute: function(t2) {
    var e2, r3, o2, n2 = this.objects.length;
    for (e2 = 0; e2 < n2; e2++)
      (r3 = this.objects[e2]).type === i2.Z.OBJECT_TYPE_CURVE && r3.setAttribute(t2);
    return o2 = this.visProp.id, this.visProp = s.Z.deepCopy(this.curve.visProp), this.visProp.id = o2, this._attributes = s.Z.deepCopy(this.visProp), delete this._attributes.id, this;
  }, copyAttr: function(t2, e2) {
    return this._attributes[t2.toLowerCase()] = e2, this._attributes;
  }, showTurtle: function() {
    return this.turtleIsHidden = false, this.arrow.setAttribute({ visible: true }), this.visProp.arrow.visible = false, this.setPos(this.pos[0], this.pos[1]), this.board.update(), this;
  }, hideTurtle: function() {
    return this.turtleIsHidden = true, this.arrow.setAttribute({ visible: false }), this.visProp.arrow.visible = false, this.board.update(), this;
  }, home: function() {
    return this.pos = [0, 0], this.setPos(this.pos[0], this.pos[1]), this;
  }, pushTurtle: function() {
    return this.stack.push([this.pos[0], this.pos[1], this.dir]), this;
  }, popTurtle: function() {
    var t2 = this.stack.pop();
    return this.pos[0] = t2[0], this.pos[1] = t2[1], this.dir = t2[2], this.setPos(this.pos[0], this.pos[1]), this;
  }, lookTo: function(t2) {
    var e2, i3, r3, o2, n2;
    return s.Z.isArray(t2) ? (e2 = this.pos[0], i3 = this.pos[1], r3 = t2[0], o2 = t2[1], n2 = Math.atan2(o2 - i3, r3 - e2), this.right(this.dir - 180 * n2 / Math.PI)) : s.Z.isNumber(t2) && this.right(this.dir - t2), this;
  }, moveTo: function(t2) {
    var e2, i3, r3;
    return s.Z.isArray(t2) && (e2 = t2[0] - this.pos[0], i3 = t2[1] - this.pos[1], this.turtleIsHidden || ((r3 = this.board.create("transform", [e2, i3], { type: "translate" })).applyOnce(this.turtle), r3.applyOnce(this.turtle2)), this.isPenDown && this.curve.dataX.length >= 8192 && (this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve)), this.pos[0] = t2[0], this.pos[1] = t2[1], this.isPenDown && (this.curve.dataX.push(this.pos[0]), this.curve.dataY.push(this.pos[1])), this.board.update()), this;
  }, fd: function(t2) {
    return this.forward(t2);
  }, bk: function(t2) {
    return this.back(t2);
  }, lt: function(t2) {
    return this.left(t2);
  }, rt: function(t2) {
    return this.right(t2);
  }, pu: function() {
    return this.penUp();
  }, pd: function() {
    return this.penDown();
  }, ht: function() {
    return this.hideTurtle();
  }, st: function() {
    return this.showTurtle();
  }, cs: function() {
    return this.clearScreen();
  }, push: function() {
    return this.pushTurtle();
  }, pop: function() {
    return this.popTurtle();
  }, evalAt: function(t2, e2) {
    var s2, r3, o2, n2, a2 = this.objects.length;
    for (s2 = 0, r3 = 0; s2 < a2; s2++)
      if ((o2 = this.objects[s2]).elementClass === i2.Z.OBJECT_CLASS_CURVE) {
        if (r3 <= t2 && t2 < r3 + o2.numberPoints)
          return n2 = t2 - r3, o2[e2](n2);
        r3 += o2.numberPoints;
      }
    return this[e2]();
  }, X: function(t2) {
    return s.Z.exists(t2) ? this.evalAt(t2, "X") : this.pos[0];
  }, Y: function(t2) {
    return s.Z.exists(t2) ? this.evalAt(t2, "Y") : this.pos[1];
  }, Z: function(t2) {
    return 1;
  }, minX: function() {
    return 0;
  }, maxX: function() {
    var t2, e2 = this.objects.length, s2 = 0;
    for (t2 = 0; t2 < e2; t2++)
      this.objects[t2].elementClass === i2.Z.OBJECT_CLASS_CURVE && (s2 += this.objects[t2].numberPoints);
    return s2;
  }, hasPoint: function(t2, e2) {
    var s2, r3;
    for (s2 = 0; s2 < this.objects.length; s2++)
      if ((r3 = this.objects[s2]).type === i2.Z.OBJECT_TYPE_CURVE && r3.hasPoint(t2, e2))
        return true;
    return false;
  } }), t.Z.createTurtle = function(e2, i3, r3) {
    var o2;
    return i3 = i3 || [], o2 = s.Z.copyAttributes(r3, e2.options, "turtle"), new t.Z.Turtle(e2, i3, o2);
  }, t.Z.registerElement("turtle", t.Z.createTurtle);
  t.Z.Turtle;
  t.Z.Ticks = function(t2, e2, r3) {
    if (this.constructor(t2.board, r3, i2.Z.OBJECT_TYPE_TICKS, i2.Z.OBJECT_CLASS_OTHER), this.line = t2, this.board = this.line.board, this.ticksFunction = null, this.fixedTicks = null, this.equidistant = false, this.labelsData = [], s.Z.isFunction(e2))
      throw this.ticksFunction = e2, new Error("Function arguments are no longer supported.");
    s.Z.isArray(e2) ? this.fixedTicks = e2 : ((Math.abs(e2) < o.Z.eps || e2 < 0) && (e2 = r3.defaultdistance), this.ticksFunction = this.makeTicksFunction(e2), this.equidistant = true), this.minTicksDistance = r3.minticksdistance, this.ticks = [], this.ticksDelta = 1, this.labels = [], this.labelData = [], this.labelCounter = 0, this.id = this.line.addTicks(this), this.elType = "ticks", this.inherits.push(this.labels), this.board.setId(this, "Ti");
  }, t.Z.Ticks.prototype = new J.Z(), t.Z.extend(t.Z.Ticks.prototype, { makeTicksFunction: function(t2) {
    return function() {
      var e2, i3, r3;
      return s.Z.evaluate(this.visProp.insertticks) ? ((r3 = (i3 = this.getLowerAndUpperBounds(this.getZeroCoordinates(), "ticksdistance")).upper - i3.lower) <= 6 * (e2 = Math.pow(10, Math.floor(Math.log(0.6 * r3) / Math.LN10))) && (e2 *= 0.5), e2) : t2;
    };
  }, hasPoint: function(t2, e2) {
    var r3, n2, a2, h2, l2 = this.ticks && this.ticks.length || 0;
    if (s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (h2 = this.board._inputDevice, a2 = s.Z.evaluate(this.visProp.precision[h2])) : a2 = this.board.options.precision.hasPoint, a2 += 0.5 * s.Z.evaluate(this.visProp.strokewidth), !s.Z.evaluate(this.line.visProp.scalable) || this.line.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      return false;
    if (0 !== this.line.stdform[1] && 0 !== this.line.stdform[2] && this.line.type !== i2.Z.OBJECT_TYPE_AXIS)
      return false;
    for (r3 = 0; r3 < l2; r3++)
      if ((n2 = this.ticks[r3])[2] && !(0 === this.line.stdform[1] && Math.abs(n2[0][0] - this.line.point1.coords.scrCoords[1]) < o.Z.eps || 0 === this.line.stdform[2] && Math.abs(n2[1][0] - this.line.point1.coords.scrCoords[2]) < o.Z.eps) && (Math.abs(n2[0][0] - n2[0][1]) >= 1 || Math.abs(n2[1][0] - n2[1][1]) >= 1)) {
        if (0 === this.line.stdform[1]) {
          if (Math.abs(e2 - 0.5 * (n2[1][0] + n2[1][1])) < 2 * a2 && n2[0][0] - a2 < t2 && t2 < n2[0][1] + a2)
            return true;
        } else if (0 === this.line.stdform[2] && Math.abs(t2 - 0.5 * (n2[0][0] + n2[0][1])) < 2 * a2 && n2[1][0] - a2 < e2 && e2 < n2[1][1] + a2)
          return true;
      }
    return false;
  }, setPositionDirectly: function(t2, e2, r3) {
    var n2, a2, h2 = new c.Z(t2, e2, this.board), l2 = new c.Z(t2, r3, this.board), d2 = this.board.getBoundingBox();
    return this.line.type === i2.Z.OBJECT_TYPE_AXIS && s.Z.evaluate(this.line.visProp.scalable) ? (Math.abs(this.line.stdform[1]) < o.Z.eps && Math.abs(h2.usrCoords[1] * l2.usrCoords[1]) > o.Z.eps ? (n2 = l2.usrCoords[1] / h2.usrCoords[1], d2[0] *= n2, d2[2] *= n2, this.board.setBoundingBox(d2, this.board.keepaspectratio, "update")) : Math.abs(this.line.stdform[2]) < o.Z.eps && Math.abs(h2.usrCoords[2] * l2.usrCoords[2]) > o.Z.eps && (a2 = l2.usrCoords[2] / h2.usrCoords[2], d2[3] *= a2, d2[1] *= a2, this.board.setBoundingBox(d2, this.board.keepaspectratio, "update")), this) : this;
  }, calculateTicksCoordinates: function() {
    var t2, e2, r3, n2;
    if (!(this.line.elementClass === i2.Z.OBJECT_CLASS_LINE && (this.setTicksSizeVariables(), Math.abs(this.dx) < o.Z.eps && Math.abs(this.dy) < o.Z.eps)))
      return t2 = this.getZeroCoordinates(), e2 = this.line.elementClass === i2.Z.OBJECT_CLASS_LINE ? this.getLowerAndUpperBounds(t2) : { lower: this.line.minX(), upper: this.line.maxX() }, "polar" === s.Z.evaluate(this.visProp.type) && (n2 = this.board.getBoundingBox(), r3 = Math.max(Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1]), Math.sqrt(n2[2] * n2[2] + n2[3] * n2[3])), e2.upper = r3), this.ticks = [], this.labelsData = [], this.equidistant ? this.generateEquidistantTicks(t2, e2) : this.generateFixedTicks(t2, e2), this;
  }, setTicksSizeVariables: function(t2) {
    var e2, i3, r3, n2, a2 = 0.5 * s.Z.evaluate(this.visProp.majorheight), h2 = 0.5 * s.Z.evaluate(this.visProp.minorheight);
    s.Z.exists(t2) ? (i3 = this.line.minX(), r3 = this.line.maxX(), (n2 = this.line.points.length) < 2 ? (this.dxMaj = 0, this.dyMaj = 0) : o.Z.relDif(t2, i3) < o.Z.eps ? (this.dxMaj = this.line.points[0].usrCoords[2] - this.line.points[1].usrCoords[2], this.dyMaj = this.line.points[1].usrCoords[1] - this.line.points[0].usrCoords[1]) : o.Z.relDif(t2, r3) < o.Z.eps ? (this.dxMaj = this.line.points[n2 - 2].usrCoords[2] - this.line.points[n2 - 1].usrCoords[2], this.dyMaj = this.line.points[n2 - 1].usrCoords[1] - this.line.points[n2 - 2].usrCoords[1]) : (this.dxMaj = -l.Z.D(this.line.Y)(t2), this.dyMaj = l.Z.D(this.line.X)(t2))) : (this.dxMaj = this.line.stdform[1], this.dyMaj = this.line.stdform[2]), this.dxMin = this.dxMaj, this.dyMin = this.dyMaj, this.dx = this.dxMaj, this.dy = this.dyMaj, e2 = Math.sqrt(this.dxMaj * this.dxMaj * this.board.unitX * this.board.unitX + this.dyMaj * this.dyMaj * this.board.unitY * this.board.unitY), this.dxMaj *= a2 / e2 * this.board.unitX, this.dyMaj *= a2 / e2 * this.board.unitY, this.dxMin *= h2 / e2 * this.board.unitX, this.dyMin *= h2 / e2 * this.board.unitY, this.minStyle = s.Z.evaluate(this.visProp.minorheight) < 0 ? "infinite" : "finite", this.majStyle = s.Z.evaluate(this.visProp.majorheight) < 0 ? "infinite" : "finite";
  }, getZeroCoordinates: function() {
    var t2, e2, r3, o2, n2, a2, h2, l2, d2 = s.Z.evaluate(this.visProp.anchor);
    return this.line.elementClass === i2.Z.OBJECT_CLASS_LINE ? this.line.type === i2.Z.OBJECT_TYPE_AXIS ? u.Z.projectPointToLine({ coords: { usrCoords: [1, 0, 0] } }, this.line, this.board) : (r3 = this.line.point1.coords.usrCoords[0], t2 = this.line.point1.coords.usrCoords[1], e2 = this.line.point1.coords.usrCoords[2], a2 = this.line.point2.coords.usrCoords[0], o2 = this.line.point2.coords.usrCoords[1], n2 = this.line.point2.coords.usrCoords[2], "right" === d2 ? this.line.point2.coords : "middle" === d2 ? new c.Z(i2.Z.COORDS_BY_USER, [0.5 * (r3 + a2), 0.5 * (t2 + o2), 0.5 * (e2 + n2)], this.board) : s.Z.isNumber(d2) ? new c.Z(i2.Z.COORDS_BY_USER, [r3 + (a2 - r3) * d2, t2 + (o2 - t2) * d2, e2 + (n2 - e2) * d2], this.board) : this.line.point1.coords) : (h2 = this.line.minX(), l2 = this.line.maxX(), "right" === d2 ? l2 : "middle" === d2 ? 0.5 * (h2 + l2) : s.Z.isNumber(d2) ? h2 * (1 - d2) + l2 * d2 : h2);
  }, getLowerAndUpperBounds: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, p2, _2, f2, b2, g2 = s.Z.evaluate(this.line.visProp.straightfirst), m2 = s.Z.evaluate(this.line.visProp.straightlast), v2 = s.Z.evaluate(this.visProp.includeboundaries);
    return this.line.elementClass === i2.Z.OBJECT_CLASS_CURVE ? { lower: this.line.minX(), upper: this.line.maxX() } : (l2 = new c.Z(i2.Z.COORDS_BY_USER, this.line.point1.coords.usrCoords, this.board), d2 = new c.Z(i2.Z.COORDS_BY_USER, this.line.point2.coords.usrCoords, this.board), p2 = Math.abs(l2.usrCoords[0]) >= o.Z.eps && l2.scrCoords[1] >= 0 && l2.scrCoords[1] <= this.board.canvasWidth && l2.scrCoords[2] >= 0 && l2.scrCoords[2] <= this.board.canvasHeight, _2 = Math.abs(d2.usrCoords[0]) >= o.Z.eps && d2.scrCoords[1] >= 0 && d2.scrCoords[1] <= this.board.canvasWidth && d2.scrCoords[2] >= 0 && d2.scrCoords[2] <= this.board.canvasHeight, s.Z.exists(e2) || "tickdistance" === e2 ? u.Z.calcStraight(this.line, l2, d2, s.Z.evaluate(this.line.visProp.margin)) : u.Z.calcLineDelimitingPoints(this.line, l2, d2), a2 = s.Z.evaluate(this.line.visProp.firstarrow), h2 = s.Z.evaluate(this.line.visProp.lastarrow), (a2 || h2) && (this.board.renderer.getPositionArrowHead(this.line, l2, d2, s.Z.evaluate(this.line.visProp.strokewidth)), a2 && l2.setCoordinates(i2.Z.COORDS_BY_SCREEN, [l2.scrCoords[1], l2.scrCoords[2]]), h2 && d2.setCoordinates(i2.Z.COORDS_BY_SCREEN, [d2.scrCoords[1], d2.scrCoords[2]])), (f2 = this.getDistanceFromZero(t2, l2)) < (b2 = this.getDistanceFromZero(t2, d2)) ? (r3 = f2, g2 || !p2 || v2 || (r3 += o.Z.eps), n2 = b2, m2 || !_2 || v2 || (n2 -= o.Z.eps)) : b2 < f2 ? (r3 = b2, m2 || !_2 || v2 || (r3 += o.Z.eps), n2 = f2, g2 || !p2 || v2 || (n2 -= o.Z.eps)) : (r3 = 0, n2 = 0), { lower: r3, upper: n2 });
  }, getDistanceFromZero: function(t2, e2) {
    var s2, r3, n2, a2, h2;
    return s2 = this.line.point1.coords, r3 = this.line.point2.coords, h2 = t2.distance(i2.Z.COORDS_BY_USER, e2), n2 = [r3.usrCoords[0] - s2.usrCoords[0], r3.usrCoords[1] - s2.usrCoords[1], r3.usrCoords[2] - s2.usrCoords[2]], a2 = [e2.usrCoords[0] - t2.usrCoords[0], e2.usrCoords[1] - t2.usrCoords[1], e2.usrCoords[2] - t2.usrCoords[2]], o.Z.innerProduct(n2, a2, 3) < 0 && (h2 *= -1), h2;
  }, generateEquidistantTicks: function(t2, e2) {
    var r3, n2, a2 = o.Z.eps, h2 = this.equidistant ? this.ticksFunction(1) : this.ticksDelta, l2 = s.Z.evaluate(this.visProp.insertticks), c2 = s.Z.evaluate(this.visProp.minorticks);
    if (this.line.elementClass === i2.Z.OBJECT_CLASS_LINE && (n2 = this.getXandYdeltas()), h2 *= s.Z.evaluate(this.visProp.scale), l2 && this.minTicksDistance > o.Z.eps ? (h2 = this.adjustTickDistance(h2, t2, n2), h2 /= c2 + 1) : l2 || (h2 /= c2 + 1), this.ticksDelta = h2, !(h2 < o.Z.eps)) {
      for (r3 = 0, s.Z.evaluate(this.visProp.drawzero) || (r3 = h2); r3 <= e2.upper + a2 && (r3 >= e2.lower - a2 && this.processTickPosition(t2, r3, h2, n2), r3 += h2, !(e2.upper - r3 > 1e4 * h2)); )
        ;
      for (r3 = -h2; r3 >= e2.lower - a2 && (r3 <= e2.upper + a2 && this.processTickPosition(t2, r3, h2, n2), !((r3 -= h2) - e2.lower > 1e4 * h2)); )
        ;
    }
  }, adjustTickDistance: function(t2, e2, r3) {
    var o2, n2, a2, h2 = 1, l2 = s.Z.evaluate(this.visProp.minorticks);
    if (this.line.elementClass === i2.Z.OBJECT_CLASS_CURVE)
      return t2;
    if (this.getLowerAndUpperBounds(e2, "ticksdistance"), o2 = e2.usrCoords[1] + r3.x * t2, n2 = e2.usrCoords[2] + r3.y * t2, a2 = e2.distance(i2.Z.COORDS_BY_SCREEN, new c.Z(i2.Z.COORDS_BY_USER, [o2, n2], this.board)), 0 === t2)
      return 0;
    for (; a2 / (l2 + 1) < this.minTicksDistance; )
      t2 *= 1 === h2 ? 2 : 5, h2 *= -1, o2 = e2.usrCoords[1] + r3.x * t2, n2 = e2.usrCoords[2] + r3.y * t2, a2 = e2.distance(i2.Z.COORDS_BY_SCREEN, new c.Z(i2.Z.COORDS_BY_USER, [o2, n2], this.board));
    return t2;
  }, processTickPosition: function(t2, e2, r3, o2) {
    var n2, a2, h2, l2, d2, u2 = s.Z.evaluate(this.visProp.ticksperlabel), p2 = null;
    this.line.elementClass === i2.Z.OBJECT_CLASS_LINE ? (n2 = t2.usrCoords[1] + e2 * o2.x, a2 = t2.usrCoords[2] + e2 * o2.y) : (n2 = this.line.X(t2 + e2), a2 = this.line.Y(t2 + e2)), h2 = new c.Z(i2.Z.COORDS_BY_USER, [n2, a2], this.board), this.line.elementClass === i2.Z.OBJECT_CLASS_CURVE && (p2 = t2 + e2, this.setTicksSizeVariables(p2)), h2.major = Math.round(e2 / r3) % (s.Z.evaluate(this.visProp.minorticks) + 1) == 0, u2 || (u2 = s.Z.evaluate(this.visProp.minorticks) + 1), d2 = Math.round(e2 / r3) % u2 == 0, 3 === (l2 = this.createTickPath(h2, h2.major)).length && (this.ticks.push(l2), d2 && s.Z.evaluate(this.visProp.drawlabels) ? this.labelsData.push(this.generateLabelData(this.generateLabelText(h2, t2, p2), h2, this.ticks.length)) : this.labelsData.push(null));
  }, generateFixedTicks: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, u2, p2, _2 = o.Z.eps, f2 = s.Z.isArray(this.visProp.labels), b2 = s.Z.evaluate(this.visProp.drawlabels);
    for (this.line.elementClass === i2.Z.OBJECT_CLASS_LINE && (p2 = this.getXandYdeltas()), a2 = 0; a2 < this.fixedTicks.length; a2++)
      this.line.elementClass === i2.Z.OBJECT_CLASS_LINE ? (u2 = this.fixedTicks[a2], l2 = t2.usrCoords[1] + u2 * p2.x, d2 = t2.usrCoords[2] + u2 * p2.y) : (u2 = t2 + this.fixedTicks[a2], l2 = this.line.X(u2), d2 = this.line.Y(u2)), r3 = new c.Z(i2.Z.COORDS_BY_USER, [l2, d2], this.board), this.line.elementClass === i2.Z.OBJECT_CLASS_CURVE && this.setTicksSizeVariables(u2), 3 === (h2 = this.createTickPath(r3, true)).length && u2 >= e2.lower - _2 && u2 <= e2.upper + _2 && (this.ticks.push(h2), b2 && (f2 || s.Z.exists(this.visProp.labels[a2])) ? (n2 = f2 ? s.Z.evaluate(this.visProp.labels[a2]) : u2, this.labelsData.push(this.generateLabelData(this.generateLabelText(r3, t2, n2), r3, a2))) : this.labelsData.push(null));
  }, getXandYdeltas: function() {
    var t2, e2, s2 = this.line.point1.Dist(this.line.point2);
    return this.line.type === i2.Z.OBJECT_TYPE_AXIS ? (t2 = this.line.point1.coords.usrCoords, e2 = this.line.point2.coords.usrCoords, (t2[1] > e2[1] || Math.abs(t2[1] - e2[1]) < o.Z.eps && t2[2] > e2[2]) && (t2 = this.line.point2.coords.usrCoords, e2 = this.line.point1.coords.usrCoords)) : (t2 = this.line.point1.coords.usrCoords, e2 = this.line.point2.coords.usrCoords), { x: (e2[1] - t2[1]) / s2, y: (e2[2] - t2[2]) / s2 };
  }, _isInsideCanvas: function(t2, e2, i3) {
    var s2 = this.board.canvasWidth, r3 = this.board.canvasHeight;
    return void 0 === i3 && (i3 = 0), t2[0] >= i3 && t2[0] <= s2 - i3 && e2[0] >= i3 && e2[0] <= r3 - i3 || t2[1] >= i3 && t2[1] <= s2 - i3 && e2[1] >= i3 && e2[1] <= r3 - i3;
  }, createTickPath: function(t2, e2) {
    var i3, r3, n2, a2, h2, l2, c2, d2, p2, _2, f2, b2, g2, m2, v2, Z2, C2, y2 = [-2e6, -2e6], P2 = [-2e6, -2e6];
    if (i3 = t2.scrCoords, e2 ? (a2 = this.dxMaj, h2 = this.dyMaj, p2 = this.majStyle, v2 = s.Z.evaluate(this.visProp.majortickendings[0]) > 0, Z2 = s.Z.evaluate(this.visProp.majortickendings[1]) > 0) : (a2 = this.dxMin, h2 = this.dyMin, p2 = this.minStyle, v2 = s.Z.evaluate(this.visProp.tickendings[0]) > 0, Z2 = s.Z.evaluate(this.visProp.tickendings[1]) > 0), r3 = [-h2 * i3[1] - a2 * i3[2], h2, a2], e2 && "polar" === s.Z.evaluate(this.visProp.type)) {
      if (b2 = this.board.getBoundingBox(), m2 = (g2 = 2 * Math.PI) / 180, i3 = t2.usrCoords, (f2 = Math.sqrt(i3[1] * i3[1] + i3[2] * i3[2])) < Math.max(Math.sqrt(b2[0] * b2[0] + b2[1] * b2[1]), Math.sqrt(b2[2] * b2[2] + b2[3] * b2[3]))) {
        for (y2 = [], P2 = [], _2 = 0; _2 <= g2; _2 += m2)
          y2.push(this.board.origin.scrCoords[1] + f2 * Math.cos(_2) * this.board.unitX), P2.push(this.board.origin.scrCoords[2] + f2 * Math.sin(_2) * this.board.unitY);
        return [y2, P2, e2];
      }
    } else {
      if ("infinite" === p2) {
        if (s.Z.evaluate(this.visProp.ignoreinfinitetickendings) && (v2 = Z2 = true), n2 = u.Z.meetLineBoard(r3, this.board), v2 && Z2)
          y2[0] = n2[0].scrCoords[1], y2[1] = n2[1].scrCoords[1], P2[0] = n2[0].scrCoords[2], P2[1] = n2[1].scrCoords[2];
        else if ((C2 = [o.Z.innerProduct(n2[0].usrCoords.slice(1, 3), this.line.stdform.slice(1, 3)) + this.line.stdform[0], o.Z.innerProduct(n2[1].usrCoords.slice(1, 3), this.line.stdform.slice(1, 3)) + this.line.stdform[0]])[0] < C2[1] && (n2.reverse(), C2.reverse()), v2) {
          if (C2[0] < 0)
            return [];
          C2[1] < 0 ? (y2[0] = n2[0].scrCoords[1], P2[0] = n2[0].scrCoords[2], y2[1] = i3[1], P2[1] = i3[2]) : (y2[0] = n2[0].scrCoords[1], P2[0] = n2[0].scrCoords[2], y2[1] = n2[1].scrCoords[1], P2[1] = n2[1].scrCoords[2]);
        } else if (Z2) {
          if (C2[1] > 0)
            return [];
          C2[0] > 0 ? (y2[0] = i3[1], P2[0] = i3[2], y2[1] = n2[1].scrCoords[1], P2[1] = n2[1].scrCoords[2]) : (y2[0] = n2[0].scrCoords[1], P2[0] = n2[0].scrCoords[2], y2[1] = n2[1].scrCoords[1], P2[1] = n2[1].scrCoords[2]);
        }
      } else
        d2 = ">" === s.Z.evaluate(this.visProp.face) ? Math.PI / 4 : "<" === s.Z.evaluate(this.visProp.face) ? -Math.PI / 4 : 0, l2 = Math.cos(d2) * a2 - Math.sin(d2) * h2, c2 = Math.sin(d2) * a2 + Math.cos(d2) * h2, y2[0] = i3[1] + l2 * v2, P2[0] = i3[2] - c2 * v2, y2[1] = i3[1], P2[1] = i3[2], d2 = -d2, l2 = Math.cos(d2) * a2 - Math.sin(d2) * h2, c2 = Math.sin(d2) * a2 + Math.cos(d2) * h2, y2[2] = i3[1] - l2 * Z2, P2[2] = i3[2] + c2 * Z2;
      if (this._isInsideCanvas(y2, P2))
        return [y2, P2, e2];
    }
    return [];
  }, formatLabelText: function(t2) {
    var e2, i3, r3 = s.Z.evaluate(this.visProp.scalesymbol);
    return s.Z.isNumber(t2) ? (((e2 = (Math.round(1e11 * t2) / 1e11).toString()).length > s.Z.evaluate(this.visProp.maxlabellength) || -1 !== e2.indexOf("e")) && (i3 = s.Z.evaluate(this.visProp.digits), 3 !== s.Z.evaluate(this.visProp.precision) && 3 === i3 && (i3 = s.Z.evaluate(this.visProp.precision)), e2 = t2.toExponential(i3).toString()), s.Z.evaluate(this.visProp.beautifulscientificticklabels) && (e2 = this.beautifyScientificNotationLabel(e2)), e2.indexOf(".") > -1 && -1 === e2.indexOf("e") && (e2 = (e2 = e2.replace(/0+$/, "")).replace(/\.$/, ""))) : e2 = t2.toString(), r3.length > 0 && ("1" === e2 ? e2 = r3 : "-1" === e2 ? e2 = "-" + r3 : "0" !== e2 && (e2 += r3)), s.Z.evaluate(this.visProp.useunicodeminus) && (e2 = e2.replace(/-/g, "")), e2;
  }, beautifyScientificNotationLabel: function(t2) {
    return -1 === t2.indexOf("e") ? t2 : (parseFloat(t2.substring(0, t2.indexOf("e"))) + t2.substring(t2.indexOf("e"))).replace(/e(.*)$/g, function(t3, e2) {
      var i3 = "10";
      return i3 += e2.replace(/-/g, "").replace(/\+/g, "").replace(/0/g, "").replace(/1/g, "").replace(/2/g, "").replace(/3/g, "").replace(/4/g, "").replace(/5/g, "").replace(/6/g, "").replace(/7/g, "").replace(/8/g, "").replace(/9/g, "");
    });
  }, generateLabelText: function(t2, e2, i3) {
    var r3;
    if (!s.Z.exists(i3)) {
      if (r3 = this.getDistanceFromZero(e2, t2), Math.abs(r3) < o.Z.eps)
        return "0";
      i3 = r3 / s.Z.evaluate(this.visProp.scale);
    }
    return this.formatLabelText(i3);
  }, generateLabelData: function(t2, e2, i3) {
    var r3, o2, n2, a2;
    return a2 = s.Z.evaluate(this.visProp.label.fontsize), r3 = [e2.scrCoords[1], e2.scrCoords[1]], o2 = [e2.scrCoords[2], e2.scrCoords[2]], n2 = void 0 === a2 ? 12 : a2, n2 *= 0.5, this._isInsideCanvas(r3, o2, n2) ? (r3 = s.Z.evaluate(this.visProp.label.offset[0]), o2 = s.Z.evaluate(this.visProp.label.offset[1]), { x: e2.usrCoords[1] + r3 / this.board.unitX, y: e2.usrCoords[2] + o2 / this.board.unitY, t: t2, i: i3 }) : null;
  }, update: function() {
    return this.needsUpdate && 0 !== this.board.canvasWidth && 0 !== this.board.canvasHeight && this.calculateTicksCoordinates(), this;
  }, updateRenderer: function() {
    return this.needsUpdate ? (this.visPropCalc.visible && this.board.renderer.updateTicks(this), this.updateRendererLabels(), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
  }, updateRendererLabels: function() {
    var e2, i3, r3, o2, n2, a2, h2, l2;
    for (r3 = this.labelsData.length, o2 = this.labels.length, e2 = 0, i3 = 0; e2 < r3; e2++)
      null !== this.labelsData[e2] && (h2 = this.labelsData[e2], i3 < o2 ? ((a2 = this.labels[i3]).setText(h2.t), a2.setCoords(h2.x, h2.y), i3++) : (this.labelCounter += 1, n2 = { isLabel: true, layer: this.board.options.layer.line, highlightStrokeColor: this.board.options.text.strokeColor, highlightStrokeWidth: this.board.options.text.strokeWidth, highlightStrokeOpacity: this.board.options.text.strokeOpacity, priv: this.visProp.priv }, (n2 = s.Z.deepCopy(n2, this.visProp.label)).id = this.id + h2.i + "Label" + this.labelCounter, a2 = t.Z.createText(this.board, [h2.x, h2.y, h2.t], n2), this.addChild(a2), a2.setParents(this), a2.isDraggable = false, a2.dump = false, this.labels.push(a2)), "inherit" === (l2 = s.Z.evaluate(this.visProp.label.visible)) && (l2 = this.visPropCalc.visible), a2.prepareUpdate().updateVisibility(l2).updateRenderer(), a2.distanceX = s.Z.evaluate(this.visProp.label.offset[0]), a2.distanceY = s.Z.evaluate(this.visProp.label.offset[1]));
    for (i3 = r3 = i3; i3 < o2; i3++)
      this.board.renderer.display(this.labels[i3], false), this.labels[i3].visProp.visible = this.labels[i3].visPropCalc.visible = false;
    return this;
  }, hideElement: function() {
    var e2;
    for (t.Z.deprecated("Element.hideElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = false, this.board.renderer.display(this, false), e2 = 0; e2 < this.labels.length; e2++)
      s.Z.exists(this.labels[e2]) && this.labels[e2].hideElement();
    return this;
  }, showElement: function() {
    var e2;
    for (t.Z.deprecated("Element.showElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = true, this.board.renderer.display(this, false), e2 = 0; e2 < this.labels.length; e2++)
      s.Z.exists(this.labels[e2]) && this.labels[e2].showElement();
    return this;
  } }), t.Z.createTicks = function(e2, r3, o2) {
    var n2, a2, h2 = s.Z.copyAttributes(o2, e2.options, "ticks");
    if (a2 = r3.length < 2 ? h2.ticksdistance : r3[1], r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE && r3[0].elementClass !== i2.Z.OBJECT_CLASS_CURVE)
      throw new Error("JSXGraph: Can't create Ticks with parent types '" + typeof r3[0] + "'.");
    return n2 = new t.Z.Ticks(r3[0], a2, h2), s.Z.isFunction(h2.generatelabelvalue) && (n2.generateLabelText = h2.generatelabelvalue), s.Z.isFunction(h2.generatelabeltext) && (n2.generateLabelText = h2.generatelabeltext), n2.setParents(r3[0]), n2.isDraggable = true, n2.fullUpdate(r3[0].visPropCalc.visible), n2;
  }, t.Z.createHatchmark = function(t2, e2, r3) {
    var o2, n2, a2, h2, l2, c2 = [], d2 = s.Z.copyAttributes(r3, t2.options, "hatch");
    if (e2[0].elementClass !== i2.Z.OBJECT_CLASS_LINE && e2[0].elementClass !== i2.Z.OBJECT_CLASS_CURVE || "number" != typeof e2[1])
      throw new Error("JSXGraph: Can't create Hatch mark with parent types '" + typeof e2[0] + "' and '" + typeof e2[1] + " and ''" + typeof e2[2] + "'.");
    for (a2 = 0.5 * -(((o2 = e2[1]) - 1) * (h2 = d2.ticksdistance)), n2 = 0; n2 < o2; n2++)
      c2[n2] = a2 + n2 * h2;
    return (l2 = t2.create("ticks", [e2[0], c2], d2)).elType = "hatch", e2[0].inherits.push(l2), l2;
  }, t.Z.registerElement("ticks", t.Z.createTicks), t.Z.registerElement("hash", t.Z.createHatchmark), t.Z.registerElement("hatch", t.Z.createHatchmark);
  t.Z.Ticks;
  t.Z.CA = function(t2, e2, i3) {
    this.node = t2, this.createNode = e2, this.parser = i3;
  }, t.Z.extend(t.Z.CA.prototype, { findMapNode: function(t2, e2) {
    var i3, s2, r3;
    if ("op_assign" === e2.value && e2.children[0].value === t2)
      return e2.children[1];
    if (e2.children) {
      for (s2 = e2.children.length, i3 = 0; i3 < s2; ++i3)
        if (null !== (r3 = this.findMapNode(t2, e2.children[i3])))
          return r3;
    }
    return null;
  }, setMath: function(t2) {
    var e2, i3;
    if (("node_op" != t2.type || "op_add" != t2.value && "op_sub" != t2.value && "op_mul" != t2.value && "op_div" != t2.value && "op_neg" != t2.value && "op_execfun" != t2.value && "op_exp" != t2.value) && "node_var" != t2.type && "node_const" != t2.type || (t2.isMath = true), t2.children)
      for (i3 = t2.children.length, e2 = 0; e2 < i3; ++e2)
        this.setMath(t2.children[e2]);
  }, deriveElementary: function(t2, e2) {
    var i3, r3 = t2.children[0].value, o2 = t2.children[1];
    switch (r3) {
      case "abs":
        i3 = this.createNode("node_op", "op_div", o2[0], this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0]))]));
        break;
      case "sqrt":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", this.createNode("node_const", 2), this.createNode(t2.type, t2.value, s.Z.deepCopy(t2.children[0]), s.Z.deepCopy(t2.children[1]))));
        break;
      case "sin":
        i3 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "cos"), s.Z.deepCopy(o2));
        break;
      case "cos":
        i3 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_execfun", this.createNode("node_var", "sin"), s.Z.deepCopy(o2)));
        break;
      case "tan":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "cos"), s.Z.deepCopy(o2)), this.createNode("node_const", 2)));
        break;
      case "cot":
        i3 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "sin"), s.Z.deepCopy(o2)), this.createNode("node_const", 2))));
        break;
      case "exp":
        i3 = this.createNode(t2.type, t2.value, s.Z.deepCopy(t2.children[0]), s.Z.deepCopy(t2.children[1]));
        break;
      case "pow":
        i3 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_execfun", s.Z.deepCopy(t2.children[0]), s.Z.deepCopy(t2.children[1])), this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", this.derivative(t2.children[1][0], e2), this.createNode("node_op", "op_div", s.Z.deepCopy(t2.children[1][1]), s.Z.deepCopy(t2.children[1][0]))), this.createNode("node_op", "op_mul", this.derivative(t2.children[1][1], e2), this.createNode("node_op", "op_execfun", this.createNode("node_var", "log"), [s.Z.deepCopy(t2.children[1][0])]))));
        break;
      case "log":
      case "ln":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), s.Z.deepCopy(o2[0]));
        break;
      case "log2":
      case "lb":
      case "ld":
        i3 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_div", this.createNode("node_const", 1), s.Z.deepCopy(o2[0])), this.createNode("node_const", 1.4426950408889634));
        break;
      case "log10":
      case "lg":
        i3 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_div", this.createNode("node_const", 1), s.Z.deepCopy(o2[0])), this.createNode("node_const", 0.43429448190325176));
        break;
      case "asin":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0])))]));
        break;
      case "acos":
        i3 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0])))])));
        break;
      case "atan":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_add", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0]))));
        break;
      case "acot":
        i3 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_add", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0])))));
        break;
      case "sinh":
        i3 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "cosh"), [s.Z.deepCopy(o2[0])]);
        break;
      case "cosh":
        i3 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "sinh"), [s.Z.deepCopy(o2[0])]);
        break;
      case "tanh":
        i3 = this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "tanh"), [s.Z.deepCopy(o2[0])]), this.createNode("node_const", 2)));
        break;
      case "asinh":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0])), this.createNode("node_const", 1))]));
        break;
      case "acosh":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0])), this.createNode("node_const", 1))]));
        break;
      case "atanh":
        i3 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", s.Z.deepCopy(o2[0]), s.Z.deepCopy(o2[0]))));
        break;
      default:
        throw i3 = this.createNode("node_const", 0), console.log('Derivative of "' + r3 + '" not yet implemented'), new Error("Error(" + this.line + "): ");
    }
    return i3;
  }, derivative: function(t2, e2) {
    var i3;
    switch (t2.type) {
      case "node_op":
        switch (t2.value) {
          case "op_execfun":
            i3 = "pow" == t2.children[0].value ? this.deriveElementary(t2, e2) : 0 === t2.children[1].length ? this.createNode("node_const", 0) : this.createNode("node_op", "op_mul", this.deriveElementary(t2, e2), this.derivative(t2.children[1][0], e2));
            break;
          case "op_div":
            i3 = this.createNode("node_op", "op_div", this.createNode("node_op", "op_sub", this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e2), s.Z.deepCopy(t2.children[1])), this.createNode("node_op", "op_mul", s.Z.deepCopy(t2.children[0]), this.derivative(t2.children[1], e2))), this.createNode("node_op", "op_mul", s.Z.deepCopy(t2.children[1]), s.Z.deepCopy(t2.children[1])));
            break;
          case "op_mul":
            i3 = this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", s.Z.deepCopy(t2.children[0]), this.derivative(t2.children[1], e2)), this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e2), s.Z.deepCopy(t2.children[1])));
            break;
          case "op_neg":
            i3 = this.createNode("node_op", "op_neg", this.derivative(t2.children[0], e2));
            break;
          case "op_add":
          case "op_sub":
            i3 = this.createNode("node_op", t2.value, this.derivative(t2.children[0], e2), this.derivative(t2.children[1], e2));
            break;
          case "op_exp":
            i3 = this.createNode("node_op", "op_mul", s.Z.deepCopy(t2), this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e2), this.createNode("node_op", "op_div", s.Z.deepCopy(t2.children[1]), s.Z.deepCopy(t2.children[0]))), this.createNode("node_op", "op_mul", this.derivative(t2.children[1], e2), this.createNode("node_op", "op_execfun", this.createNode("node_var", "log"), [s.Z.deepCopy(t2.children[0])]))));
        }
        break;
      case "node_var":
        i3 = t2.value === e2 ? this.createNode("node_const", 1) : this.createNode("node_const", 0);
        break;
      case "node_const":
        i3 = this.createNode("node_const", 0);
    }
    return i3;
  }, expandDerivatives: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2;
    if (!t2)
      return 0;
    for (this.line = t2.line, this.col = t2.col, r3 = t2.children.length, o2 = 0; o2 < r3; ++o2)
      if (t2.children[o2] && t2.children[o2].type)
        t2.children[o2] = this.expandDerivatives(t2.children[o2], t2, i3);
      else if (s.Z.isArray(t2.children[o2]))
        for (n2 = 0; n2 < t2.children[o2].length; ++n2)
          t2.children[o2][n2] && t2.children[o2][n2].type && (t2.children[o2][n2] = this.expandDerivatives(t2.children[o2][n2], t2, i3));
    if ("node_op" === t2.type) {
      if ("op_execfun" === t2.value) {
        if (t2.children[0] && "D" === t2.children[0].value) {
          if ("node_var" == t2.children[1][0].type ? (d2 = t2.children[1][0].value, p2 = (a2 = this.findMapNode(d2, i3)).children[0], u2 = t2.children[1].length >= 2 ? t2.children[1][1].value : a2.children[0][0], h2 = a2.children[1]) : (h2 = t2.children[1][0], p2 = ["x"], u2 = t2.children[1].length >= 2 ? t2.children[1][1].value : "x"), c2 = h2, (_2 = t2.children[1].length >= 3 ? t2.children[1][2].value : 1) >= 1)
            for (; _2 >= 1; )
              c2 = this.derivative(c2, u2), c2 = this.removeTrivialNodes(c2), _2--;
          l2 = "node_op" == e2.type && "op_assign" == e2.value ? this.createNode("node_op", "op_map", p2, c2) : c2, this.setMath(l2), t2.type = l2.type, t2.value = l2.value, t2.children[0] = l2.children[0], t2.children[1] = l2.children[1];
        }
      }
    }
    return t2;
  }, removeTrivialNodes: function(t2) {
    var e2, i3, r3, o2, n2;
    if (s.Z.isArray(t2))
      for (i3 = t2.length, e2 = 0; e2 < i3; ++e2)
        t2[e2] = this.removeTrivialNodes(t2[e2]);
    if ("node_op" != t2.type || !t2.children)
      return t2;
    for (i3 = t2.children.length, e2 = 0; e2 < i3; ++e2) {
      this.mayNotBeSimplified = false;
      do {
        t2.children[e2] = this.removeTrivialNodes(t2.children[e2]);
      } while (this.mayNotBeSimplified);
    }
    switch (t2.value) {
      case "op_map":
        if (r3 = t2.children[0], "node_var" == (o2 = t2.children[1]).type) {
          for (e2 = 0; e2 < r3.length; ++e2)
            if (r3[e2] == o2.value) {
              o2.isMath = true;
              break;
            }
        }
        break;
      case "op_add":
        if (r3 = t2.children[0], o2 = t2.children[1], "node_const" == r3.type && 0 === r3.value)
          return o2;
        if ("node_const" == o2.type && 0 === o2.value)
          return r3;
        if ("node_const" == r3.type && "node_const" == o2.type)
          return r3.value += o2.value, r3;
        break;
      case "op_mul":
        if (r3 = t2.children[0], o2 = t2.children[1], "node_const" == r3.type && 1 == r3.value)
          return o2;
        if ("node_const" == o2.type && 1 == o2.value)
          return r3;
        if ("node_const" == r3.type && 0 === r3.value)
          return r3;
        if ("node_const" == o2.type && 0 === o2.value)
          return o2;
        if ("node_const" == o2.type && 0 === o2.value)
          return o2;
        if ("node_op" == r3.type && "op_neg" == r3.value && "node_op" == o2.type && "op_neg" == o2.value)
          return t2.children = [r3.children[0], o2.children[0]], this.mayNotBeSimplified = true, t2;
        if ("op_neg" == r3.value && "op_neg" != o2.value)
          return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_mul", r3.children[0], o2)], this.mayNotBeSimplified = true, t2;
        if ("op_neg" != r3.value && "op_neg" == o2.value)
          return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_mul", r3, o2.children[0])], this.mayNotBeSimplified = true, t2;
        if ("op_div" == r3.value && "node_const" == r3.children[0].type && 1 == r3.children[0].value)
          return t2.type = "node_op", t2.value = "op_div", t2.children = [o2, r3.children[1]], this.mayNotBeSimplified = true, t2;
        if ("op_div" == o2.value && "node_const" == o2.children[0].type && 1 == o2.children[0].value)
          return t2.type = "node_op", t2.value = "op_div", t2.children = [r3, o2.children[1]], this.mayNotBeSimplified = true, t2;
        if ("node_const" != r3.type && "node_const" == o2.type)
          return t2.children = [o2, r3], this.mayNotBeSimplified = true, t2;
        if ("node_const" != r3.type && "node_op" == o2.type && "op_neg" == o2.value && "node_const" == o2.children[0].type)
          return t2.children = [o2, r3], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_execfun" != r3.value && ("node_var" == o2.type || "node_op" == o2.type && "op_execfun" == o2.value))
          return t2.children = [o2, r3], this.mayNotBeSimplified = true, t2;
        if ("node_op" != r3.type && "node_op" == o2.type && "op_neg" == o2.value && "node_var" == o2.children[0].type)
          return t2.children = [o2, r3], this.mayNotBeSimplified = true, t2;
        if ("node_const" != r3.type && "node_op" == o2.type && ("op_mul" == o2.value || "op_div" == o2.value) && "node_const" == o2.children[0].type)
          return n2 = o2.children[0], o2.children[0] = r3, t2.children = [n2, o2], this.mayNotBeSimplified = true, t2;
        if ("node_const" != o2.type && "node_op" == r3.type && "op_mul" == r3.value && "node_const" == r3.children[0].type)
          return t2.children = [r3.children[0], this.createNode("node_op", "op_mul", r3.children[1], o2)], this.mayNotBeSimplified = true, t2;
        if ("node_const" == r3.type && "node_const" == o2.type)
          return r3.value *= o2.value, r3;
        if ("node_const" == r3.type && "node_op" == o2.type && ("op_mul" == o2.value || "op_div" == o2.value) && "node_const" == o2.children[0].type)
          return o2.children[0].value *= r3.value, o2;
        if (r3.hash = this.parser.compile(r3), o2.hash = this.parser.compile(o2), r3.hash === o2.hash)
          return t2.value = "op_exp", t2.children[1] = this.createNode("node_const", 2), t2;
        if ("node_const" == r3.type && "node_op" == o2.type && ("op_mul" == o2.value || "op_div" == o2.value) && "node_const" == o2.children[0].type)
          return o2.children[0].value *= r3.value, o2;
        if ("node_op" == o2.type && "op_exp" == o2.value && (r3.hash || (r3.hash = this.parser.compile(r3)), o2.children[0].hash || (o2.children[0].hash = this.parser.compile(o2.children[0])), r3.hash === o2.children[0].hash))
          return o2.children[1] = this.createNode("node_op", "op_add", o2.children[1], this.createNode("node_const", 1)), this.mayNotBeSimplified = true, o2;
        if ("node_op" == r3.type && "op_exp" == r3.value && "node_op" == o2.type && "op_exp" == o2.value && (r3.children[0].hash = this.parser.compile(r3.children[0]), o2.children[0].hash = this.parser.compile(o2.children[0]), r3.children[0].hash === o2.children[0].hash))
          return r3.children[1] = this.createNode("node_op", "op_add", r3.children[1], o2.children[1]), this.mayNotBeSimplified = true, r3;
        break;
      case "op_sub":
        if (r3 = t2.children[0], o2 = t2.children[1], "node_const" == r3.type && 0 === r3.value)
          return t2.value = "op_neg", t2.children[0] = o2, t2;
        if ("node_const" == o2.type && 0 === o2.value)
          return r3;
        if ("node_const" == r3.type && "node_const" == o2.type && r3.value == o2.value)
          return this.createNode("node_const", 0);
        if ("node_var" == r3.type && "node_var" == o2.type && r3.value == o2.value)
          return this.createNode("node_const", 0);
        if ("node_const" == r3.type && "node_const" == o2.type)
          return r3.value -= o2.value, r3;
        if ("node_op" == r3.type && "op_mul" == r3.value && "node_op" == o2.type && "op_mul" == o2.value && (r3.children[1].hash = this.parser.compile(r3.children[1]), o2.children[1].hash = this.parser.compile(o2.children[1]), r3.children[1].hash === o2.children[1].hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", r3.children[0], o2.children[0]), r3.children[1]], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_mul" == r3.value && (r3.children[1].hash = this.parser.compile(r3.children[1]), o2.hash = this.parser.compile(o2), r3.children[1].hash === o2.hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", r3.children[0], this.createNode("node_const", 1)), o2], this.mayNotBeSimplified = true, t2;
        if ("node_op" == o2.type && "op_mul" == o2.value && (o2.children[1].hash = this.parser.compile(o2.children[1]), r3.hash = this.parser.compile(r3), o2.children[1].hash === r3.hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), o2.children[0]), r3], this.mayNotBeSimplified = true, t2;
        break;
      case "op_neg":
        if ("node_const" == (r3 = t2.children[0]).type && 0 === r3.value)
          return r3;
        if ("node_op" == r3.type && "op_neg" == r3.value)
          return r3.children[0];
        break;
      case "op_div":
        if (r3 = t2.children[0], o2 = t2.children[1], "node_const" == r3.type && "node_const" == o2.type && r3.value == o2.value && 0 !== r3.value)
          return r3.value = 1, r3;
        if ("node_const" == r3.type && 0 === r3.value && "node_const" == o2.type && 0 !== o2.value)
          return r3.value = 0, r3;
        if ("node_const" == r3.type && 0 === r3.value && ("node_op" == o2.type || "node_var" == o2.type))
          return t2.type = "node_const", t2.value = 0, t2;
        if ("node_var" == r3.type && "node_var" == o2.type && r3.value == o2.value)
          return this.createNode("node_const", 1);
        if ("node_const" == r3.type && 0 !== r3.value && "node_const" == o2.type && 0 === o2.value)
          return r3.value > 0 ? r3.value = 1 / 0 : r3.value = -1 / 0, r3;
        if ("node_op" == r3.type && "op_neg" == r3.value && "node_op" == o2.type && "op_neg" == o2.value)
          return t2.children = [r3.children[0], o2.children[0]], this.mayNotBeSimplified = true, t2;
        if ("op_neg" == r3.value && "op_neg" != o2.value)
          return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_div", r3.children[0], o2)], this.mayNotBeSimplified = true, t2;
        if ("op_neg" != r3.value && "op_neg" == o2.value)
          return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_div", r3, o2.children[0])], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_exp" == r3.value && (o2.hash || (o2.hash = this.parser.compile(o2)), r3.children[0].hash || (r3.children[0].hash = this.parser.compile(r3.children[0])), o2.hash === r3.children[0].hash))
          return r3.children[1] = this.createNode("node_op", "op_sub", r3.children[1], this.createNode("node_const", 1)), this.mayNotBeSimplified = true, r3;
        if ("node_const" != o2.type && "node_op" == r3.type && "op_mul" == r3.value && "node_const" == r3.children[0].type)
          return t2.value = "op_mul", t2.children = [r3.children[0], this.createNode("node_op", "op_div", r3.children[1], o2)], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_exp" == r3.value && "node_op" == o2.type && "op_exp" == o2.value && (r3.children[0].hash = this.parser.compile(r3.children[0]), o2.children[0].hash = this.parser.compile(o2.children[0]), r3.children[0].hash === o2.children[0].hash))
          return r3.children[1] = this.createNode("node_op", "op_sub", r3.children[1], o2.children[1]), this.mayNotBeSimplified = true, r3;
        break;
      case "op_exp":
        if (r3 = t2.children[0], "node_const" == (o2 = t2.children[1]).type && 0 === o2.value)
          return o2.value = 1, o2;
        if ("node_const" == o2.type && 1 == o2.value)
          return r3;
        if ("node_const" == r3.type && 1 == r3.value)
          return r3;
        if ("node_const" == r3.type && 0 === r3.value && "node_const" == o2.type && 0 !== o2.value)
          return r3;
        if ("node_op" == r3.type && "op_exp" == r3.value)
          return t2.children = [r3.children[0], this.createNode("node_op", "op_mul", r3.children[1], o2)], t2;
    }
    switch (t2.value) {
      case "op_add":
        if (r3 = t2.children[0], o2 = t2.children[1], "node_const" == r3.type && "node_const" == o2.type && r3.value == o2.value)
          return r3.value += o2.value, r3;
        if ("node_var" == r3.type && "node_var" == o2.type && r3.value == o2.value)
          return t2.children[0] = this.createNode("node_const", 2), t2.value = "op_mul", t2;
        if ("node_op" == r3.type && "op_neg" == r3.value)
          return t2.value = "op_sub", t2.children[0] = o2, t2.children[1] = r3.children[0], this.mayNotBeSimplified = true, t2;
        if ("node_op" == o2.type && "op_neg" == o2.value)
          return t2.value = "op_sub", t2.children[1] = o2.children[0], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_mul" == r3.value && "node_op" == o2.type && "op_mul" == o2.value && (r3.children[1].hash = this.parser.compile(r3.children[1]), o2.children[1].hash = this.parser.compile(o2.children[1]), r3.children[1].hash === o2.children[1].hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", r3.children[0], o2.children[0]), r3.children[1]], this.mayNotBeSimplified = true, t2;
        if ("node_op" == r3.type && "op_mul" == r3.value && (r3.children[1].hash = this.parser.compile(r3.children[1]), o2.hash = this.parser.compile(o2), r3.children[1].hash === o2.hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", r3.children[0], this.createNode("node_const", 1)), o2], this.mayNotBeSimplified = true, t2;
        if ("node_op" == o2.type && "op_mul" == o2.value && (o2.children[1].hash = this.parser.compile(o2.children[1]), r3.hash = this.parser.compile(r3), o2.children[1].hash === r3.hash))
          return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", this.createNode("node_const", 1), o2.children[0]), r3], this.mayNotBeSimplified = true, t2;
        break;
      case "op_sub":
        if (r3 = t2.children[0], "node_op" == (o2 = t2.children[1]).type && "op_neg" == o2.value)
          return t2.value = "op_add", t2.children[1] = o2.children[0], this.mayNotBeSimplified = true, t2;
        break;
      case "op_execfun":
        return this.simplifyElementary(t2);
    }
    return t2;
  }, simplifyElementary: function(t2) {
    var e2 = t2.children[0].value, i3 = t2.children[1];
    if (0 == i3.length)
      return t2;
    switch (e2) {
      case "sin":
      case "tan":
        if ("node_const" == i3[0].type && 0 === i3[0].value)
          return t2.type = "node_const", t2.value = 0, t2;
        if ("node_var" == i3[0].type && "PI" == i3[0].value)
          return t2.type = "node_const", t2.value = 0, t2;
        if ("node_op" == i3[0].type && "op_mul" == i3[0].value && "node_const" == i3[0].children[0].type && i3[0].children[0].value % 1 == 0 && "node_var" == i3[0].children[1].type && "PI" == i3[0].children[1].value)
          return t2.type = "node_const", t2.value = 0, t2;
        break;
      case "cos":
        if ("node_const" == i3[0].type && 0 === i3[0].value)
          return t2.type = "node_const", t2.value = 1, t2;
        if ("node_var" == i3[0].type && "PI" == i3[0].value)
          return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_const", 1)], t2;
        break;
      case "exp":
        if ("node_const" == i3[0].type && 0 === i3[0].value)
          return t2.type = "node_const", t2.value = 1, t2;
        break;
      case "pow":
        if ("node_const" == i3[1].type && 0 === i3[1].value)
          return t2.type = "node_const", t2.value = 1, t2;
    }
    return t2;
  } });
  t.Z.CA;
  t.Z.Dump = { addMarkers: function(t2, e2, i3) {
    var r3, o2, n2;
    for (r3 in s.Z.isArray(e2) || (e2 = [e2]), s.Z.isArray(i3) || (i3 = [i3]), o2 = Math.min(e2.length, i3.length), e2.length = o2, i3.length = o2, t2.objects)
      if (t2.objects.hasOwnProperty(r3))
        for (n2 = 0; n2 < o2; n2++)
          t2.objects[r3][e2[n2]] = i3[n2];
  }, deleteMarkers: function(t2, e2) {
    var i3, r3, o2;
    for (i3 in s.Z.isArray(e2) || (e2 = [e2]), r3 = e2.length, e2.length = r3, t2.objects)
      if (t2.objects.hasOwnProperty(i3))
        for (o2 = 0; o2 < r3; o2++)
          delete t2.objects[i3][e2[o2]];
  }, str: function(t2) {
    return "string" == typeof t2 && "function" !== t2.substr(0, 7) && (t2 = '"' + t2 + '"'), t2;
  }, minimizeObject: function(e2, i3) {
    var r3, o2, n2, a2 = {}, h2 = s.Z.deepCopy(e2), l2 = [];
    for (n2 = 1; n2 < arguments.length; n2++)
      l2.push(arguments[n2]);
    for (a2 = s.Z.deepCopy(a2, t.Z.Options.elements, true), n2 = l2.length; n2 > 0; n2--)
      a2 = s.Z.deepCopy(a2, l2[n2 - 1], true);
    for (r3 in a2)
      a2.hasOwnProperty(r3) && (o2 = r3.toLowerCase(), "object" != typeof a2[r3] && a2[r3] === h2[o2] && delete h2[o2]);
    return h2;
  }, prepareAttributes: function(e2, i3) {
    var s2, r3;
    for (r3 in s2 = this.minimizeObject(i3.getAttributes(), t.Z.Options[i3.elType]), i3.subs)
      i3.subs.hasOwnProperty(r3) && (s2[r3] = this.minimizeObject(i3.subs[r3].getAttributes(), t.Z.Options[i3.elType][r3], t.Z.Options[i3.subs[r3].elType]), s2[r3].id = i3.subs[r3].id, s2[r3].name = i3.subs[r3].name);
    return s2.id = i3.id, s2.name = i3.name, s2;
  }, setBoundingBox: function(t2, e2, i3) {
    return t2.push({ obj: i3, method: "setBoundingBox", params: [e2.getBoundingBox(), e2.keepaspectratio] }), t2;
  }, dump: function(t2) {
    var e2, i3, r3, o2, n2 = [], a2 = [], h2 = t2.objectsList.length;
    for (this.addMarkers(t2, "dumped", false), e2 = 0; e2 < h2; e2++)
      if (r3 = {}, !(i3 = t2.objectsList[e2]).dumped && i3.dump) {
        for (r3.type = i3.getType(), r3.parents = i3.getParents().slice(), "point" === r3.type && 1 === r3.parents[0] && (r3.parents = r3.parents.slice(1)), o2 = 0; o2 < r3.parents.length; o2++)
          s.Z.isString(r3.parents[o2]) && "'" !== r3.parents[o2][0] && '"' !== r3.parents[o2][0] ? r3.parents[o2] = '"' + r3.parents[o2] + '"' : s.Z.isArray(r3.parents[o2]) && (r3.parents[o2] = "[" + r3.parents[o2].toString() + "]");
        r3.attributes = this.prepareAttributes(t2, i3), "glider" === r3.type && i3.onPolygon && n2.push({ obj: i3.id, prop: "onPolygon", val: true }), a2.push(r3);
      }
    return this.deleteMarkers(t2, "dumped"), { elements: a2, props: n2, methods: [] };
  }, arrayToParamStr: function(t2, e2) {
    var i3, s2 = [];
    for (i3 = 0; i3 < t2.length; i3++)
      s2.push(e2.call(this, t2[i3]));
    return s2.join(", ");
  }, toJCAN: function(t2) {
    var e2, i3, r3;
    switch (typeof t2) {
      case "object":
        if (t2) {
          if (i3 = [], s.Z.isArray(t2)) {
            for (e2 = 0; e2 < t2.length; e2++)
              i3.push(this.toJCAN(t2[e2]));
            return "[" + i3.join(",") + "]";
          }
          for (r3 in t2)
            t2.hasOwnProperty(r3) && i3.push(r3 + ": " + this.toJCAN(t2[r3]));
          return "<<" + i3.join(", ") + ">> ";
        }
        return "null";
      case "string":
        return "'" + t2.replace(/\\/g, "\\\\").replace(/(["'])/g, "\\$1") + "'";
      case "number":
      case "boolean":
        return t2.toString();
      case "null":
        return "null";
    }
  }, toJessie: function(t2) {
    var e2, i3, s2, r3 = this.dump(t2), o2 = [];
    for (r3.methods = this.setBoundingBox(r3.methods, t2, "$board"), i3 = r3.elements, e2 = 0; e2 < i3.length; e2++)
      i3[e2].attributes.name.length > 0 && o2.push("// " + i3[e2].attributes.name), o2.push("s" + e2 + " = " + i3[e2].type + "(" + i3[e2].parents.join(", ") + ") " + this.toJCAN(i3[e2].attributes).replace(/\n/, "\\n") + ";"), "axis" === i3[e2].type && (s2 = i3[e2].attributes.id, null === t2.objects[s2].defaultTicks && o2.push("s" + e2 + ".removeAllTicks();")), o2.push("");
    for (e2 = 0; e2 < r3.methods.length; e2++)
      o2.push(r3.methods[e2].obj + "." + r3.methods[e2].method + "(" + this.arrayToParamStr(r3.methods[e2].params, this.toJCAN) + ");"), o2.push("");
    for (e2 = 0; e2 < r3.props.length; e2++)
      o2.push(r3.props[e2].obj + "." + r3.props[e2].prop + " = " + this.toJCAN(r3.props[e2].val) + ";"), o2.push("");
    return o2.join("\n");
  }, toJavaScript: function(t2) {
    var e2, i3, r3, o2 = this.dump(t2), n2 = [];
    for (o2.methods = this.setBoundingBox(o2.methods, t2, "board"), i3 = o2.elements, e2 = 0; e2 < i3.length; e2++)
      n2.push('board.create("' + i3[e2].type + '", [' + i3[e2].parents.join(", ") + "], " + s.Z.toJSON(i3[e2].attributes) + ");"), "axis" === i3[e2].type && (r3 = i3[e2].attributes.id, null === t2.objects[r3].defaultTicks && n2.push('board.objects["' + r3 + '"].removeTicks(board.objects["' + r3 + '"].defaultTicks);'));
    for (e2 = 0; e2 < o2.methods.length; e2++)
      n2.push(o2.methods[e2].obj + "." + o2.methods[e2].method + "(" + this.arrayToParamStr(o2.methods[e2].params, s.Z.toJSON) + ");"), n2.push("");
    for (e2 = 0; e2 < o2.props.length; e2++)
      n2.push(o2.props[e2].obj + "." + o2.props[e2].prop + " = " + s.Z.toJSON(o2.props[e2].val) + ";"), n2.push("");
    return n2.join("\n");
  } };
  t.Z.Dump;
  t.Z.createComb = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2;
    if (2 !== i3.length)
      throw l2 = i3.map(function(t2) {
        return "'" + typeof t2 + "'";
      }), new Error("JSXGraph: Can't create comb with parent types " + l2.join(", ") + ".\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
    if (s.Z.isArray(i3[0]) && i3[0].length > 1)
      h2 = s.Z.copyAttributes(r3, e2.options, "comb", "point1"), o2 = e2.create("point", i3[0], h2);
    else if (s.Z.isString(i3[0]) || s.Z.isPoint(i3[0]))
      o2 = e2.select(i3[0]);
    else if (s.Z.isFunction(i3[0]) && s.Z.isPoint(i3[0]()))
      o2 = i3[0]();
    else {
      if (!(s.Z.isFunction(i3[0]) && i3[0]().length && i3[0]().length >= 2))
        throw new Error("JSXGraph: Can't create comb with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
      h2 = s.Z.copyAttributes(r3, e2.options, "comb", "point1"), o2 = t.Z.createPoint(e2, i3[0](), h2);
    }
    if (s.Z.isArray(i3[1]) && i3[1].length > 1)
      h2 = s.Z.copyAttributes(r3, e2.options, "comb", "point2"), n2 = e2.create("point", i3[1], h2);
    else if (s.Z.isString(i3[1]) || s.Z.isPoint(i3[1]))
      n2 = e2.select(i3[1]);
    else if (s.Z.isFunction(i3[1]) && s.Z.isPoint(i3[1]()))
      n2 = i3[1]();
    else {
      if (!(s.Z.isFunction(i3[1]) && i3[1]().length && i3[1]().length >= 2))
        throw new Error("JSXGraph: Can't create comb with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
      h2 = s.Z.copyAttributes(r3, e2.options, "comb", "point2"), n2 = t.Z.createPoint(e2, i3[1](), h2);
    }
    return h2 = s.Z.copyAttributes(r3, e2.options, "comb"), s.Z.merge(h2, s.Z.copyAttributes(r3, e2.options, "comb", "curve")), (a2 = e2.create("curve", [[0], [0]], h2)).updateDataArray = function() {
      var t2, e3, i4, r4, h3, l3, c2, d2, u2, p2, _2 = 0, f2 = o2.Dist(n2), b2 = o2, g2 = n2;
      for (d2 = s.Z.evaluate(a2.visProp.frequency), u2 = -s.Z.evaluate(a2.visProp.angle), p2 = s.Z.evaluate(a2.visProp.width), s.Z.evaluate(a2.visProp.reverse) && (b2 = n2, g2 = o2, u2 = -u2), t2 = Math.cos(u2), e3 = Math.sin(u2), i4 = (g2.X() - b2.X()) / f2, r4 = (g2.Y() - b2.Y()) / f2, t2 *= p2 / Math.abs(e3), e3 *= p2 / Math.abs(e3), this.dataX = [], this.dataY = []; _2 < f2; )
        h3 = b2.X() + i4 * _2, l3 = b2.Y() + r4 * _2, e3 *= c2 = Math.min(t2, f2 - _2) / Math.abs(t2), t2 *= c2, this.dataX.push(h3), this.dataY.push(l3), this.dataX.push(h3 + i4 * t2 + r4 * e3), this.dataY.push(l3 - i4 * e3 + r4 * t2), this.dataX.push(NaN), this.dataY.push(NaN), _2 += d2;
    }, a2;
  }, t.Z.registerElement("comb", t.Z.createComb);
  var $ = function() {
    W.prototype.remove.call(this), this.board.removeObject(this.toppoint), this.board.removeObject(this.glider), this.board.removeObject(this.baseline), this.board.removeObject(this.basepoint), this.board.removeObject(this.label), this._isPrivateTangent && this.board.removeObject(this.tangent);
  }, K = function() {
    return this.tangent.getSlope();
  };
  t.Z.createSlopeTriangle = function(e2, r3, o2) {
    var n2, a2, h2, l2, c2, d2, u2, p2, _2, f2 = false;
    if (1 === r3.length && r3[0].type === i2.Z.OBJECT_TYPE_TANGENT)
      a2 = r3[0], h2 = a2.glider;
    else if (1 === r3.length && r3[0].type === i2.Z.OBJECT_TYPE_GLIDER)
      h2 = r3[0], _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "tangent"), a2 = e2.create("tangent", [h2], _2), f2 = true;
    else {
      if (2 !== r3.length || r3[0].elementClass !== i2.Z.OBJECT_CLASS_LINE || !s.Z.isPoint(r3[1]))
        throw new Error("JSXGraph: Can't create slope triangle with parent types '" + typeof r3[0] + "'.");
      a2 = r3[0], h2 = r3[1];
    }
    return _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "basepoint"), u2 = e2.create("point", [function() {
      return [h2.X() + 1, h2.Y()];
    }], _2), _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "baseline"), d2 = e2.create("line", [h2, u2], _2), _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "glider"), l2 = e2.create("glider", [h2.X() + 1, h2.Y(), d2], _2), _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "toppoint"), c2 = e2.create("point", [function() {
      return [l2.X(), l2.Y() + (l2.X() - h2.X()) * a2.getSlope()];
    }], _2), (_2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle")).borders = s.Z.copyAttributes(_2.borders, e2.options, "slopetriangle", "borders"), (n2 = e2.create("polygon", [h2, l2, c2], _2)).Value = K, n2.tangent = a2, n2._isPrivateTangent = f2, n2.borders[2].setArrow(false, false), _2 = s.Z.copyAttributes(o2, e2.options, "slopetriangle", "label"), (p2 = e2.create("text", [function() {
      return l2.X() + 0.1;
    }, function() {
      return 0.5 * (l2.Y() + c2.Y());
    }, function() {
      return "";
    }], _2))._setText(function() {
      return s.Z.toFixed(n2.Value(), s.Z.evaluate(p2.visProp.digits));
    }), p2.fullUpdate(), n2.glider = l2, n2.basepoint = u2, n2.baseline = d2, n2.toppoint = c2, n2.label = p2, n2.subs = { glider: l2, basePoint: u2, baseLine: d2, topPoint: c2, label: p2 }, n2.inherits.push(l2, u2, d2, c2, p2), n2.methodMap = t.Z.deepCopy(n2.methodMap, { tangent: "tangent", glider: "glider", basepoint: "basepoint", baseline: "baseline", toppoint: "toppoint", label: "label", Value: "Value", V: "Value" }), n2.remove = $, n2;
  }, t.Z.registerElement("slopetriangle", t.Z.createSlopeTriangle);
  var q = function() {
    this._value = this.rendNodeCheckbox.checked, this.board.update();
  };
  t.Z.createCheckbox = function(i3, r3, o2) {
    var n2, a2, h2 = s.Z.copyAttributes(o2, i3.options, "checkbox");
    return a2 = [r3[0], r3[1], '<span style="display:inline"><input type="checkbox" /><label for=""></label></span>'], (n2 = i3.create("text", a2, h2)).type = s.Z.OBJECT_TYPE_CHECKBOX, n2.rendNodeCheckbox = n2.rendNode.childNodes[0].childNodes[0], n2.rendNodeLabel = n2.rendNode.childNodes[0].childNodes[1], n2.rendNodeTag = n2.rendNodeCheckbox, n2.rendNodeTag.disabled = !!h2.disabled, n2.rendNodeCheckbox.id = n2.rendNode.id + "_checkbox", n2.rendNodeLabel.id = n2.rendNode.id + "_label", n2.rendNodeLabel.setAttribute("for", n2.rendNodeCheckbox.id), n2.setText(r3[2]), n2.visPropOld.fontsize = "0px", i3.renderer.updateTextStyle(n2, false), n2.rendNodeCheckbox.checked = h2.checked, n2._value = h2.checked, n2.Value = function() {
      return this._value;
    }, n2.update = function() {
      return this.needsUpdate && (t.Z.Text.prototype.update.call(this), this._value = this.rendNodeCheckbox.checked), this;
    }, e.Z.addEvent(n2.rendNodeCheckbox, "change", q, n2), n2;
  }, t.Z.registerElement("checkbox", t.Z.createCheckbox);
  var Q = function(t2) {
    this._value = this.rendNodeInput.value, this.board.update();
  };
  t.Z.createInput = function(i3, r3, o2) {
    var n2, a2, h2 = s.Z.copyAttributes(o2, i3.options, "input");
    return a2 = [r3[0], r3[1], '<span style="display:inline; white-space:nowrap; padding:0px;"><span></span><input type="text" maxlength="' + h2.maxlength + '" style="width:100%"/></span>'], (n2 = i3.create("text", a2, h2)).type = s.Z.OBJECT_TYPE_INPUT, n2.rendNodeLabel = n2.rendNode.childNodes[0].childNodes[0], n2.rendNodeInput = n2.rendNode.childNodes[0].childNodes[1], n2.rendNodeInput.value = r3[2], n2.rendNodeTag = n2.rendNodeInput, n2.rendNodeTag.disabled = !!h2.disabled, n2.rendNodeLabel.id = n2.rendNode.id + "_label", n2.rendNodeInput.id = n2.rendNode.id + "_input", n2.setText(r3[3]), n2._value = r3[2], n2.update = function() {
      return this.needsUpdate && (t.Z.Text.prototype.update.call(this), this._value = this.rendNodeInput.value), this;
    }, n2.Value = function() {
      return this._value;
    }, n2.set = function(t2) {
      return this._value = t2, this.rendNodeInput.value = t2, this;
    }, e.Z.addEvent(n2.rendNodeInput, "input", Q, n2), e.Z.addEvent(n2.rendNodeInput, "mousedown", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), e.Z.addEvent(n2.rendNodeInput, "touchstart", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), e.Z.addEvent(n2.rendNodeInput, "pointerdown", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), n2.visPropOld.fontsize = "0px", i3.renderer.updateTextStyle(n2, false), n2;
  }, t.Z.registerElement("input", t.Z.createInput);
  var tt = function() {
    this._handler && this._handler(), this.board.update();
  };
  t.Z.createButton = function(i3, r3, o2) {
    var n2, a2, h2 = s.Z.copyAttributes(o2, i3.options, "button");
    return a2 = [r3[0], r3[1], '<button type="button" style="width:100%;"></button>'], (n2 = i3.create("text", a2, h2)).type = s.Z.OBJECT_TYPE_BUTTON, n2.rendNodeButton = n2.rendNode.childNodes[0], n2.rendNodeButton.id = n2.rendNode.id + "_button", n2.rendNodeTag = n2.rendNodeButton, n2.rendNodeTag.disabled = !!h2.disabled, n2.setText(r3[2]), n2.visPropOld.fontsize = "0px", i3.renderer.updateTextStyle(n2, false), r3[3] && (s.Z.isString(r3[3]) ? (n2._jc = new t.Z.JessieCode(), n2._jc.use(i3), n2._handler = function() {
      n2._jc.parse(r3[3]);
    }) : n2._handler = r3[3]), e.Z.addEvent(n2.rendNodeButton, "click", tt, n2), e.Z.addEvent(n2.rendNodeButton, "mousedown", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), e.Z.addEvent(n2.rendNodeButton, "touchstart", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), e.Z.addEvent(n2.rendNodeButton, "pointerdown", function(t2) {
      s.Z.exists(t2.stopPropagation) && t2.stopPropagation();
    }, n2), n2;
  }, t.Z.registerElement("button", t.Z.createButton), t.Z.ForeignObject = function(e2, r3, o2, n2, a2) {
    this.constructor(e2, o2, i2.Z.OBJECT_TYPE_FOREIGNOBJECT, i2.Z.OBJECT_CLASS_OTHER), this.element = this.board.select(o2.anchor), this.coordsConstructor(r3), this._useUserSize = false, this.size = [1, 1], s.Z.exists(a2) && a2.length > 0 && (this._useUserSize = true, this.W = s.Z.createFunction(a2[0], this.board, ""), this.H = s.Z.createFunction(a2[1], this.board, ""), this.addParentsFromJCFunctions([this.W, this.H]), this.usrSize = [this.W(), this.H()]), this.content = n2, this.elType = "foreignobject", this.id = this.board.setId(this, "Im"), this.board.renderer.drawForeignObject(this), this.board.finalizeAdding(this), this.methodMap = t.Z.deepCopy(this.methodMap, { addTransformation: "addTransform", trans: "addTransform" });
  }, t.Z.ForeignObject.prototype = new J.Z(), s.Z.copyPrototypeMethods(t.Z.ForeignObject, G.Z, "coordsConstructor"), t.Z.extend(t.Z.ForeignObject.prototype, { hasPoint: function(t2, e2) {
    var r3, n2, a2, h2, l2, d2, u2, p2, _2, f2 = this.transformations.length;
    return s.Z.isObject(s.Z.evaluate(this.visProp.precision)) ? (h2 = this.board._inputDevice, l2 = s.Z.evaluate(this.visProp.precision[h2])) : l2 = this.board.options.precision.hasPoint, 0 === f2 ? (r3 = t2 - this.coords.scrCoords[1], n2 = this.coords.scrCoords[2] - e2, r3 >= -(a2 = l2) && r3 - this.size[0] <= a2 && n2 >= -a2 && n2 - this.size[1] <= a2) : (u2 = [(d2 = (d2 = new c.Z(i2.Z.COORDS_BY_SCREEN, [t2, e2], this.board)).usrCoords)[0] - this.span[0][0], d2[1] - this.span[0][1], d2[2] - this.span[0][2]], 0 <= (p2 = (_2 = o.Z.innerProduct)(u2, this.span[1])) && p2 <= _2(this.span[1], this.span[1]) && 0 <= (p2 = _2(u2, this.span[2])) && p2 <= _2(this.span[2], this.span[2]));
  }, update: function(t2) {
    return this.needsUpdate ? (this.updateCoords(t2), this.updateSize(), this) : this;
  }, updateRenderer: function() {
    return this.updateRendererGeneric("updateForeignObject");
  }, updateSize: function() {
    var t2 = [0, 0];
    return this._useUserSize ? (this.usrSize = [this.W(), this.H()], this.size = [Math.abs(this.usrSize[0] * this.board.unitX), Math.abs(this.usrSize[1] * this.board.unitY)]) : this.rendNode.hasChildNodes() && (t2 = this.rendNode.childNodes[0].getBoundingClientRect(), this.size = [t2.width, t2.height]), this;
  }, updateSpan: function() {
    var t2, e2, i3 = this.transformations.length, s2 = [];
    if (0 === i3)
      this.span = [[this.Z(), this.X(), this.Y()], [this.Z(), this.W(), 0], [this.Z(), 0, this.H()]];
    else {
      for (s2[0] = [this.Z(), this.X(), this.Y()], s2[1] = [this.Z(), this.X() + this.W(), this.Y()], s2[2] = [this.Z(), this.X(), this.Y() + this.H()], t2 = 0; t2 < i3; t2++)
        for (e2 = 0; e2 < 3; e2++)
          s2[e2] = o.Z.matVecMult(this.transformations[t2].matrix, s2[e2]);
      for (e2 = 0; e2 < 3; e2++)
        s2[e2][1] /= s2[e2][0], s2[e2][2] /= s2[e2][0], s2[e2][0] /= s2[e2][0];
      for (e2 = 1; e2 < 3; e2++)
        s2[e2][0] -= s2[0][0], s2[e2][1] -= s2[0][1], s2[e2][2] -= s2[0][2];
      this.span = s2;
    }
    return this;
  }, addTransform: function(t2) {
    var e2;
    if (s.Z.isArray(t2))
      for (e2 = 0; e2 < t2.length; e2++)
        this.transformations.push(t2[e2]);
    else
      this.transformations.push(t2);
    return this;
  }, getParents: function() {
    var t2 = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];
    return 0 !== this.parents.length && (t2 = this.parents), t2;
  }, setSize: function(t2, e2) {
    return this.W = s.Z.createFunction(t2, this.board, ""), this.H = s.Z.createFunction(e2, this.board, ""), this._useUserSize = true, this.addParentsFromJCFunctions([this.W, this.H]), this;
  }, W: function() {
  }, H: function() {
  } }), t.Z.createForeignObject = function(e2, i3, r3) {
    var o2, n2, a2 = i3[0], h2 = i3[1], l2 = [];
    if (i3.length >= 2 && (l2 = i3[2]), o2 = s.Z.copyAttributes(r3, e2.options, "foreignobject"), !(n2 = G.Z.create(t.Z.ForeignObject, e2, h2, o2, a2, l2)))
      throw new Error("JSXGraph: Can't create foreignObject with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [string, [x, y], [w, h]], [string, [x, y]], [element,transformation]");
    return n2;
  }, t.Z.registerElement("foreignobject", t.Z.createForeignObject), t.Z.registerElement("fo", t.Z.createForeignObject);
  t.Z.ForeignObject;
  t.Z.extend(M.Z, { axes3d: { axesPosition: "center", xAxis: { visible: true, point2: { name: "x" } }, yAxis: { visible: true, point2: { name: "y" } }, zAxis: { visible: true, point2: { name: "z" } }, xPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } }, yPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } }, zPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } }, xPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } }, yPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } }, zPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } }, xPlaneRearYAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, xPlaneRearZAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, xPlaneFrontYAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, xPlaneFrontZAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, yPlaneRearXAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, yPlaneRearZAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, yPlaneFrontXAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, yPlaneFrontZAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, zPlaneRearXAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, zPlaneRearYAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, zPlaneFrontXAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 }, zPlaneFrontYAxis: { visible: "inherit", strokeColor: "#888888", strokeWidth: 1 } }, axis3d: { highlight: false, strokecolor: "black", strokeWidth: 1, tabindex: null, point1: { visible: false, name: "" }, point2: { visible: false, name: "", label: { visible: true } } }, curve3d: { highlight: false, tabindex: -1, strokeWidth: 1, numberPointsHigh: 200 }, mesh3d: { strokeWidth: 1, strokeColor: "#9a9a9a", strokeOpacity: 0.6, highlight: false, fillColor: "#9a9a9a", fillOpacity: 0.1, tabindex: null, visible: "inherit" }, line3d: { strokeWidth: 1, strokeColor: "black", fixed: true, tabindex: null, gradient: "linear", gradientSecondColor: "#ffffff", point: { visible: false, name: "" }, point1: { visible: false, name: "" }, point2: { visible: false, name: "" } }, plane3d: { strokeWidth: 0, strokeColor: "black", strokeOpacity: 1, highlight: false, tabindex: null, gradient: "linear", gradientSecondColor: "#ffffff", gradientAngle: Math.PI, fillColor: "#a7a7a7", fillOpacity: 0.6, point: { visible: false, name: "", fixed: true } }, point3d: { infoboxDigits: "auto", strokeWidth: 0, gradient: "radial", gradientSecondColor: "#555555", fillColor: "yellow", highlightStrokeColor: "#555555" }, surface3d: { highlight: false, tabindex: -1, strokeWidth: 1, stepsU: 30, stepsV: 30 }, view3d: { needsRegularUpdate: true } });
  t.Z.Options;
  t.Z.View3D = function(t2, e2, r3) {
    this.constructor(t2, r3, i2.Z.OBJECT_TYPE_VIEW3D, i2.Z.OBJECT_CLASS_3D), this.objects = {}, this.objectsList = [], this.elementsByName = {}, this.defaultAxes = null, this.matrix3D = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]], this.llftCorner = e2[0], this.size = e2[1], this.bbox3D = e2[2], this.r = -1, this.timeoutAzimuth = null, this.id = this.board.setId(this, "V"), this.board.finalizeAdding(this), this.elType = "view3d", this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.View3D.prototype = new J.Z(), t.Z.extend(t.Z.View3D.prototype, { create: function(t2, e2, i3) {
    var s2 = [];
    return t2.indexOf("3d") > 0 && s2.push(this), this.board.create(t2, s2.concat(e2), i3);
  }, select: function(t2, e2) {
    var i3, r3, o2, n2, a2 = t2;
    if (null === a2)
      return a2;
    if (s.Z.isString(a2) && "" !== a2)
      s.Z.exists(this.objects[a2]) ? a2 = this.objects[a2] : s.Z.exists(this.elementsByName[a2]) && (a2 = this.elementsByName[a2]);
    else if (!e2 && (s.Z.isFunction(a2) || s.Z.isObject(a2) && !s.Z.isFunction(a2.setAttribute))) {
      for (r3 = {}, n2 = (i3 = s.Z.filterElements(this.objectsList, a2)).length, o2 = 0; o2 < n2; o2++)
        r3[i3[o2].id] = i3[o2];
      a2 = new L(r3);
    } else
      s.Z.isObject(a2) && s.Z.exists(a2.id) && !s.Z.exists(this.objects[a2.id]) && (a2 = null);
    return a2;
  }, update: function() {
    var t2, e2, i3, r3, n2;
    return s.Z.exists(this.el_slide) && s.Z.exists(this.az_slide) && this.needsUpdate ? (t2 = this.el_slide.Value(), e2 = this.r, i3 = this.az_slide.Value(), r3 = e2 * Math.sin(t2), n2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.matrix3D = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]], this.matrix3D[1][1] = e2 * Math.cos(i3), this.matrix3D[1][2] = -e2 * Math.sin(i3), this.matrix3D[2][1] = r3 * Math.sin(i3), this.matrix3D[2][2] = r3 * Math.cos(i3), this.matrix3D[2][3] = Math.cos(t2), n2[1][1] = this.size[0] / (this.bbox3D[0][1] - this.bbox3D[0][0]), n2[2][2] = this.size[1] / (this.bbox3D[1][1] - this.bbox3D[1][0]), n2[1][0] = this.llftCorner[0] - n2[1][1] * this.bbox3D[0][0], n2[2][0] = this.llftCorner[1] - n2[2][2] * this.bbox3D[1][0], this.matrix3D = o.Z.matMatMult(n2, this.matrix3D), this) : this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  }, project3DTo2D: function(t2, e2, i3) {
    var s2;
    return s2 = 3 === arguments.length ? [1, t2, e2, i3] : 3 === t2.length ? [1].concat(t2) : t2, o.Z.matVecMult(this.matrix3D, s2);
  }, project2DTo3DPlane: function(t2, e2, i3) {
    var s2, r3, n2, a2, h2 = e2.slice(1), l2 = [1, 0, 0, 0];
    i3 = i3 || [1, 0, 0, 0], a2 = o.Z.norm(h2, 3), n2 = o.Z.innerProduct(i3.slice(1), h2, 3) / a2, (s2 = this.matrix3D.slice(0, 3)).push([0].concat(h2)), r3 = t2.coords.usrCoords.concat([n2]);
    try {
      1 === s2[2][3] && (s2[2][1] = s2[2][2] = 1e-3 * o.Z.eps), l2 = o.Z.Numerics.Gauss(s2, r3);
    } catch (t3) {
      l2 = [0, NaN, NaN, NaN];
    }
    return l2;
  }, project3DToCube: function(t2) {
    var e2 = this.bbox3D;
    return t2[1] < e2[0][0] && (t2[1] = e2[0][0]), t2[1] > e2[0][1] && (t2[1] = e2[0][1]), t2[2] < e2[1][0] && (t2[2] = e2[1][0]), t2[2] > e2[1][1] && (t2[2] = e2[1][1]), t2[3] < e2[2][0] && (t2[3] = e2[2][0]), t2[3] > e2[2][1] && (t2[3] = e2[2][1]), t2;
  }, intersectionLineCube: function(t2, e2, i3) {
    var s2, r3, o2, n2;
    for (s2 = i3, r3 = 0; r3 < 3; r3++)
      0 !== e2[r3] && (o2 = (this.bbox3D[r3][0] - t2[r3]) / e2[r3], n2 = (this.bbox3D[r3][1] - t2[r3]) / e2[r3], s2 = i3 < 0 ? Math.max(s2, Math.min(o2, n2)) : Math.min(s2, Math.max(o2, n2)));
    return s2;
  }, isInCube: function(t2) {
    return t2[0] > this.bbox3D[0][0] - o.Z.eps && t2[0] < this.bbox3D[0][1] + o.Z.eps && t2[1] > this.bbox3D[1][0] - o.Z.eps && t2[1] < this.bbox3D[1][1] + o.Z.eps && t2[2] > this.bbox3D[2][0] - o.Z.eps && t2[2] < this.bbox3D[2][1] + o.Z.eps;
  }, intersectionPlanePlane: function(t2, e2, i3) {
    var s2, r3, n2, a2, h2 = [[], []];
    return i3 = i3 || e2.d, s2 = o.Z.Geometry.meet3Planes(t2.normal, t2.d, e2.normal, i3, o.Z.crossProduct(t2.normal, e2.normal), 0), r3 = o.Z.Geometry.meetPlanePlane(t2.vec1, t2.vec2, e2.vec1, e2.vec2), n2 = this.intersectionLineCube(s2, r3, 1 / 0), a2 = o.Z.axpy(n2, r3, s2), this.isInCube(a2) && (h2[0] = a2), n2 = this.intersectionLineCube(s2, r3, -1 / 0), a2 = o.Z.axpy(n2, r3, s2), this.isInCube(a2) && (h2[1] = a2), h2;
  }, getMesh: function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2 = [0, 0, 0], u2 = e2[2], p2 = i3[2], _2 = [], f2 = [];
    for (l2 = (s.Z.evaluate(e2[1]) - s.Z.evaluate(e2[0])) / u2, c2 = (s.Z.evaluate(i3[1]) - s.Z.evaluate(i3[0])) / p2, r3 = 0; r3 <= u2; r3++) {
      for (n2 = e2[0] + l2 * r3, o2 = 0; o2 <= p2; o2++)
        a2 = i3[0] + c2 * o2, d2 = s.Z.isFunction(t2) ? t2(n2, a2) : [t2[0](n2, a2), t2[1](n2, a2), t2[2](n2, a2)], h2 = this.project3DTo2D(d2), _2.push(h2[1]), f2.push(h2[2]);
      _2.push(NaN), f2.push(NaN);
    }
    for (o2 = 0; o2 <= p2; o2++) {
      for (a2 = i3[0] + c2 * o2, r3 = 0; r3 <= u2; r3++)
        n2 = e2[0] + l2 * r3, d2 = s.Z.isFunction(t2) ? t2(n2, a2) : [t2[0](n2, a2), t2[1](n2, a2), t2[2](n2, a2)], h2 = this.project3DTo2D(d2), _2.push(h2[1]), f2.push(h2[2]);
      _2.push(NaN), f2.push(NaN);
    }
    return [_2, f2];
  }, animateAzimuth: function() {
    var t2 = this.az_slide._smin, e2 = this.az_slide._smax - t2, i3 = this.az_slide.Value() + 0.1;
    this.az_slide.position = (i3 - t2) / e2, this.az_slide.position > 1 && (this.az_slide.position = 0), this.board.update(), this.timeoutAzimuth = setTimeout(function() {
      this.animateAzimuth();
    }.bind(this), 200);
  }, stopAzimuth: function() {
    clearTimeout(this.timeoutAzimuth), this.timeoutAzimuth = null;
  } }), t.Z.createView3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2 = i3[0], u2 = i3[1];
    return n2 = s.Z.copyAttributes(r3, e2.options, "view3d"), (o2 = new t.Z.View3D(e2, i3, n2)).defaultAxes = o2.create("axes3d", i3, r3), a2 = d2[0], h2 = d2[1], l2 = u2[0], c2 = u2[1], o2.az_slide = e2.create("slider", [[a2 - 1, h2 - 2], [a2 + l2 + 1, h2 - 2], [0, 1, 2 * Math.PI]], { style: 6, name: "az", point1: { frozen: true }, point2: { frozen: true } }), o2.el_slide = e2.create("slider", [[a2 - 1, h2], [a2 - 1, h2 + c2], [0, 0.3, Math.PI / 2]], { style: 6, name: "el", point1: { frozen: true }, point2: { frozen: true } }), o2.board.highlightInfobox = function(t2, e3, i4) {
      var r4, n3, a3, h3, l3 = i4.board, c3 = null;
      for (n3 = 0; n3 < i4.parents.length && !(c3 = l3.objects[i4.parents[n3]]).is3D; n3++)
        ;
      if (c3) {
        if (h3 = [1, 0, 0, c3.coords[3]], a3 = o2.project2DTo3DPlane(c3.element2D, [1, 0, 0, 1], h3), !o2.isInCube(a3))
          return void o2.board.highlightCustomInfobox("", c3);
        "auto" === (r4 = s.Z.evaluate(c3.visProp.infoboxdigits)) ? o2.board.highlightCustomInfobox("(" + s.Z.autoDigits(c3.X()) + " | " + s.Z.autoDigits(c3.Y()) + " | " + s.Z.autoDigits(c3.Z()) + ")", c3) : o2.board.highlightCustomInfobox("(" + s.Z.toFixed(c3.X(), r4) + " | " + s.Z.toFixed(c3.Y(), r4) + " | " + s.Z.toFixed(c3.Z(), r4) + ")", c3);
      } else
        o2.board.highlightCustomInfobox("(" + t2 + ", " + e3 + ")", i4);
    }, o2.board.update(), o2;
  }, t.Z.registerElement("view3d", t.Z.createView3D);
  t.Z.View3D;
  t.Z.GeometryElement3D = function(t2, e2) {
    this.elType = e2, this.id = this.board.setId(this, e2), this.view = t2, this.element2D = null, this.is3D = true, this.view.objects[this.id] = this, this.view.objectsList.push(this), "" !== this.name && (this.view.elementsByName[this.name] = this);
  };
  t.Z.GeometryElement3D;
  t.Z.createAxes3D = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2, d2, u2, p2, _2, f2, b2, g2, m2, v2, Z2, C2 = e2[0], y2 = ["x", "y", "z"], P2 = "Axis", E2 = ["Rear", "Front"], O2 = [0, 0, 0], x2 = [0, 0, 0], w2 = {};
    if (s.Z.exists(C2.bbox3D))
      for (r3 = 0; r3 < y2.length; r3++)
        O2[r3] = C2.bbox3D[r3][0], x2[r3] = C2.bbox3D[r3][1];
    else
      for (r3 = 0; r3 < y2.length; r3++)
        O2[r3] = e2[1][r3], x2[r3] = e2[2][1];
    for (c2 = (l2 = s.Z.copyAttributes(i3, t2.options, "axes3d")).axesposition, r3 = 0; r3 < y2.length; r3++)
      m2 = (d2 = y2[r3]) + P2, "center" === c2 ? (u2 = [0, 0, 0], (p2 = [0, 0, 0])[r3] = x2[r3], w2[m2] = C2.create("axis3d", [u2, p2], l2[m2.toLowerCase()])) : (m2 += "Border", u2 = O2.slice(), p2 = x2.slice(), 2 === r3 ? (u2[1] = x2[1], p2[0] = O2[0]) : (u2[r3] = x2[r3], p2[2] = O2[2]), p2[r3] = x2[r3], l2[m2.toLowerCase()].lastArrow = false, w2[m2] = C2.create("axis3d", [u2, p2], l2[m2.toLowerCase()]), Z2 = { visible: true, minorTicks: 0, tickEndings: [0, 1], drawLabels: false }, 2 === r3 && (Z2.tickEndings = [1, 0]), w2[m2 + "Ticks"] = C2.create("ticks", [w2[m2], 1], Z2));
    for (w2.O = C2.create("intersection", [w2[y2[0] + P2], w2[y2[1] + P2]], { name: "", visible: false, withLabel: false }), r3 = 0; r3 < y2.length; r3++)
      for (a2 = (r3 + 1) % 3, h2 = (r3 + 2) % 3, d2 = y2[r3], o2 = 0; o2 < E2.length; o2++)
        (u2 = [0, 0, 0])[r3] = 0 === o2 ? O2[r3] : x2[r3], f2 = [0, 0, 0], (_2 = [0, 0, 0])[a2] = 1, f2[h2] = 1, b2 = [O2[a2], x2[a2]], g2 = [O2[h2], x2[h2]], m2 = d2 + "Plane" + E2[o2], l2 = s.Z.copyAttributes(i3, t2.options, "axes3d", m2), w2[m2] = C2.create("plane3d", [u2, _2, f2, b2, g2], l2), w2[m2].elType = "axisplane3d";
    for (r3 = 0; r3 < y2.length; r3++)
      for (d2 = y2[r3], o2 = 0; o2 < E2.length; o2++)
        for (n2 = 1; n2 <= 2; n2++)
          m2 = d2 + "Plane" + E2[o2] + y2[a2 = (r3 + n2) % 3].toUpperCase() + "Axis", v2 = d2 + "Plane" + E2[o2], (u2 = [0, 0, 0])[r3] = (p2 = [0, 0, 0])[r3] = 0 === o2 ? O2[r3] : x2[r3], u2[a2] = O2[a2], p2[a2] = x2[a2], l2 = s.Z.copyAttributes(i3, t2.options, "axes3d", m2), w2[m2] = C2.create("axis3d", [u2, p2], l2), w2[v2].addChild(w2[m2]), w2[v2].element2D.inherits.push(w2[m2]);
    return w2;
  }, t.Z.registerElement("axes3d", t.Z.createAxes3D), t.Z.createAxis3D = function(t2, e2, i3) {
    var r3, o2, n2, a2, h2, l2, c2 = e2[0], d2 = e2[1], u2 = e2[2];
    return r3 = s.Z.copyAttributes(i3.point1, t2.options, "axis3d", "point1"), o2 = c2.create("point", [(a2 = d2[0], h2 = d2[1], l2 = d2[2], function() {
      return c2.project3DTo2D(a2, h2, l2)[1];
    }), function(t3, e3, i4) {
      return function() {
        return c2.project3DTo2D(t3, e3, i4)[2];
      };
    }(d2[0], d2[1], d2[2])], r3), r3 = s.Z.copyAttributes(i3.point2, t2.options, "axis3d", "point2"), n2 = c2.create("point", [function(t3, e3, i4) {
      return function() {
        return c2.project3DTo2D(t3, e3, i4)[1];
      };
    }(u2[0], u2[1], u2[2]), function(t3, e3, i4) {
      return function() {
        return c2.project3DTo2D(t3, e3, i4)[2];
      };
    }(u2[0], u2[1], u2[2])], r3), r3 = s.Z.copyAttributes(i3, t2.options, "axis3d"), c2.create("arrow", [o2, n2], r3);
  }, t.Z.registerElement("axis3d", t.Z.createAxis3D), t.Z.createMesh3D = function(e2, i3, r3) {
    var o2, n2 = i3[0], a2 = i3[1], h2 = i3[2], l2 = i3[3], c2 = i3[4], d2 = i3[5];
    return (o2 = n2.create("curve", [[], []], r3)).updateDataArray = function() {
      var e3, i4, r4, o3, u2 = l2[0], p2 = l2[1], _2 = d2[0], f2 = d2[1], b2 = [0, 0, 0], g2 = [0, 0, 0], m2 = [0, 0, 0];
      if (this.dataX = [], this.dataY = [], s.Z.isFunction(a2))
        m2 = a2().slice(1);
      else
        for (o3 = 0; o3 < 3; o3++)
          m2[o3] = s.Z.evaluate(a2[o3]);
      for (o3 = 0; o3 < 3; o3++)
        b2[o3] = s.Z.evaluate(h2[o3]), g2[o3] = s.Z.evaluate(c2[o3]);
      for (e3 = t.Z.Math.norm(b2, 3), i4 = t.Z.Math.norm(g2, 3), o3 = 0; o3 < 3; o3++)
        b2[o3] /= e3, g2[o3] /= i4;
      r4 = n2.getMesh([function(t2, e4) {
        return m2[0] + t2 * b2[0] + e4 * g2[0];
      }, function(t2, e4) {
        return m2[1] + t2 * b2[1] + e4 * g2[1];
      }, function(t2, e4) {
        return m2[2] + t2 * b2[2] + e4 * g2[2];
      }], [Math.ceil(u2), Math.floor(p2), (Math.ceil(p2) - Math.floor(u2)) / 1], [Math.ceil(_2), Math.floor(f2), (Math.ceil(f2) - Math.floor(_2)) / 1]), this.dataX = r4[0], this.dataY = r4[1];
    }, o2;
  }, t.Z.registerElement("mesh3d", t.Z.createMesh3D), t.Z.Point3D = function(t2, e2, r3, o2) {
    this.constructor(t2.board, o2, i2.Z.OBJECT_TYPE_POINT3D, i2.Z.OBJECT_CLASS_3D), this.constructor3D(t2, "point3d"), this.id = this.view.board.setId(this, "P3D"), this.board.finalizeAdding(this), this.coords = [0, 0, 0, 0], this.F = e2, this.slide = r3, this.X = function() {
      return this.coords[1];
    }, this.Y = function() {
      return this.coords[2];
    }, this.Z = function() {
      return this.coords[3];
    }, this._params = null, this._c2d = null, this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.Point3D.prototype = new t.Z.GeometryElement(), s.Z.copyPrototypeMethods(t.Z.Point3D, t.Z.GeometryElement3D, "constructor3D"), t.Z.extend(t.Z.Point3D.prototype, { updateCoords: function() {
    var t2;
    if (s.Z.isFunction(this.F))
      this.coords = [1].concat(s.Z.evaluate(this.F));
    else
      for (this.coords[0] = 1, t2 = 0; t2 < 3; t2++)
        s.Z.isFunction(this.F[t2]) && (this.coords[t2 + 1] = s.Z.evaluate(this.F[t2]));
    return this;
  }, initCoords: function() {
    var t2;
    if (s.Z.isFunction(this.F))
      this.coords = [1].concat(s.Z.evaluate(this.F));
    else
      for (this.coords[0] = 1, t2 = 0; t2 < 3; t2++)
        this.coords[t2 + 1] = s.Z.evaluate(this.F[t2]);
    return this;
  }, normalizeCoords: function() {
    return Math.abs(this.coords[0]) > o.Z.eps && (this.coords[1] /= this.coords[0], this.coords[2] /= this.coords[0], this.coords[3] /= this.coords[0], this.coords[0] = 1), this;
  }, setPosition: function(t2, e2) {
    var i3 = this.coords;
    this.coords.slice();
    return 3 === t2.length ? (i3[0] = 1, i3[1] = t2[0], i3[2] = t2[1], i3[3] = t2[2]) : (i3[0] = t2[0], i3[1] = t2[1], i3[2] = t2[2], i3[3] = t2[2], this.normalizeCoords()), this;
  }, update: function(t2) {
    var e2, s2;
    return this.element2D.draggable() && 0 !== u.Z.distance(this._c2d, this.element2D.coords.usrCoords) ? this.slide ? this.projectCoords2Surface() : (s2 = [1, 0, 0, this.coords[3]], 0 !== (e2 = this.view.project2DTo3DPlane(this.element2D, [1, 0, 0, 1], s2))[0] && (this.coords = this.view.project3DToCube(e2))) : (this.updateCoords(), this.element2D.coords.setCoordinates(i2.Z.COORDS_BY_USER, this.view.project3DTo2D([1, this.X(), this.Y(), this.Z()]))), this._c2d = this.element2D.coords.usrCoords.slice(), this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  }, projectCoords2Surface: function() {
    var t2, e2, r3, n2 = [0, 0], a2 = this.slide, h2 = this;
    null !== a2 && (r3 = function(t3, e3, i3, s2) {
      var r4 = [1, a2.X(i3[0], i3[1]), a2.Y(i3[0], i3[1]), a2.Z(i3[0], i3[1])], o2 = h2.view.project3DTo2D(r4);
      return s2[0] = h2.element2D.X() - o2[1], s2[1] = h2.element2D.Y() - o2[2], s2[0] * s2[0] + s2[1] * s2[1];
    }, s.Z.exists(this._params) && (n2 = this._params.slice()), o.Z.Nlp.FindMinimum(r3, 2, 2, n2, 5, 1e-6, 0, 200), t2 = [1, a2.X(n2[0], n2[1]), a2.Y(n2[0], n2[1]), a2.Z(n2[0], n2[1])], e2 = this.view.project3DTo2D(t2), this._params = n2, this.coords = t2, this.element2D.coords.setCoordinates(i2.Z.COORDS_BY_USER, e2), this._c2d = e2);
  }, __evt__update3D: function(t2) {
  } }), t.Z.createPoint3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2 = i3[0];
    if (a2 = i3.length > 2 && s.Z.exists(i3[i3.length - 1].is3D) ? i3.pop() : null, 2 === i3.length)
      n2 = i3[1];
    else {
      if (4 !== i3.length)
        throw new Error("JSXGraph: Can't create point3d with parent types '" + typeof i3[0] + "' and '" + typeof i3[1] + "'.\nPossible parent types: [[x,y,z]], [x,y,z]");
      n2 = i3.slice(1);
    }
    return o2 = s.Z.copyAttributes(r3, e2.options, "point3d"), (l2 = new t.Z.Point3D(c2, n2, a2, o2)).initCoords(), h2 = c2.project3DTo2D(l2.coords), o2.name = l2.name, l2.element2D = c2.create("point", h2, o2), l2.addChild(l2.element2D), l2.inherits.push(l2.element2D), l2.element2D.setParents(l2), l2._c2d = l2.element2D.coords.usrCoords.slice(), l2;
  }, t.Z.registerElement("point3d", t.Z.createPoint3D), t.Z.Curve3D = function(t2, e2, r3, o2, n2, a2, h2) {
    this.constructor(t2.board, h2, i2.Z.OBJECT_TYPE_CURVE3D, i2.Z.OBJECT_CLASS_3D), this.constructor3D(t2, "surface3d"), this.id = this.view.board.setId(this, "S3D"), this.board.finalizeAdding(this), this.F = e2, this.X = r3, this.Y = o2, this.Z = n2, null !== this.F && (this.X = function(t3) {
      return this.F(t3)[0];
    }, this.Y = function(t3) {
      return this.F(t3)[1];
    }, this.Z = function(t3) {
      return this.F(t3)[2];
    }), this.range = a2, this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.Curve3D.prototype = new t.Z.GeometryElement(), s.Z.copyPrototypeMethods(t.Z.Curve3D, t.Z.GeometryElement3D, "constructor3D"), t.Z.extend(t.Z.Curve3D.prototype, { updateDataArray: function() {
    var t2, e2, i3, r3, o2, n2, a2, h2, l2 = s.Z.evaluate(this.visProp.numberpointshigh), c2 = [0, 0, 0];
    if (a2 = [], h2 = [], s.Z.isArray(this.X))
      for (l2 = this.X.length, n2 = 0; n2 < l2; n2++)
        c2 = [this.X[n2], this.Y[n2], this.Z[n2]], o2 = this.view.project3DTo2D(c2), a2.push(o2[1]), h2.push(o2[2]);
    else
      for (t2 = s.Z.evaluate(this.range), e2 = s.Z.evaluate(t2[0]), r3 = ((i3 = s.Z.evaluate(t2[1])) - e2) / (l2 - 1), n2 = e2; n2 <= i3; n2 += r3)
        c2 = null !== this.F ? this.F(n2) : [this.X(n2), this.Y(n2), this.Z(n2)], o2 = this.view.project3DTo2D(c2), a2.push(o2[1]), h2.push(o2[2]);
    return { X: a2, Y: h2 };
  }, update: function() {
    return this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  } }), t.Z.createCurve3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2 = i3[0];
    return 3 === i3.length ? (o2 = i3[1], l2 = i3[2], n2 = null, a2 = null, h2 = null) : (n2 = i3[1], a2 = i3[2], h2 = i3[3], l2 = i3[4], o2 = null), c2 = s.Z.copyAttributes(r3, e2.options, "curve3d"), (d2 = new t.Z.Curve3D(u2, o2, n2, a2, h2, l2, c2)).element2D = e2.create("curve", [[], []], c2), d2.element2D.updateDataArray = function() {
      var t2 = d2.updateDataArray();
      this.dataX = t2.X, this.dataY = t2.Y;
    }, d2.addChild(d2.element2D), d2.inherits.push(d2.element2D), d2.element2D.setParents(d2), d2.element2D.prepareUpdate().update(), e2.isSuspendedUpdate || d2.element2D.updateVisibility().updateRenderer(), d2;
  }, t.Z.registerElement("curve3d", t.Z.createCurve3D), t.Z.Line3D = function(t2, e2, r3, o2, n2) {
    this.constructor(t2.board, n2, i2.Z.OBJECT_TYPE_LINE3D, i2.Z.OBJECT_CLASS_3D), this.constructor3D(t2, "line3d"), this.id = this.view.board.setId(this, "L3D"), this.board.finalizeAdding(this), this.point = e2, this.direction = r3, this.range = o2 || [-1 / 0, 1 / 0], this.point1 = null, this.point2 = null, this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.Line3D.prototype = new t.Z.GeometryElement(), s.Z.copyPrototypeMethods(t.Z.Line3D, t.Z.GeometryElement3D, "constructor3D"), t.Z.extend(t.Z.Line3D.prototype, { getPointCoords: function(t2) {
    var e2, i3, r3, o2 = [];
    if (e2 = [this.point.X(), this.point.Y(), this.point.Z()], s.Z.isFunction(this.direction))
      o2 = this.direction();
    else
      for (i3 = 1; i3 < 4; i3++)
        o2.push(s.Z.evaluate(this.direction[i3]));
    return r3 = s.Z.evaluate(t2), Math.abs(r3) === 1 / 0 && (t2 = this.view.intersectionLineCube(e2, o2, r3)), [e2[0] + o2[0] * r3, e2[1] + o2[1] * r3, e2[2] + o2[2] * r3];
  }, update: function() {
    return this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  } }), t.Z.createLine3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2 = i3[0];
    return o2 = s.Z.copyAttributes(r3, e2.options, "line3d"), s.Z.isPoint3D(i3[2]) || 3 === i3.length && (s.Z.isArray(i3[2]) || s.Z.isFunction(i3[2])) ? (c2 = s.Z.providePoints3D(p2, [i3[1]], r3, "line3d", ["point1"])[0], d2 = s.Z.providePoints3D(p2, [i3[2]], r3, "line3d", ["point2"])[0], h2 = function() {
      return [d2.X() - c2.X(), d2.Y() - c2.Y(), d2.Z() - c2.Z()];
    }, l2 = [0, 1], u2 = new t.Z.Line3D(p2, c2, h2, l2, o2)) : (a2 = s.Z.providePoints3D(p2, [i3[1]], r3, "line3d", ["point"])[0], s.Z.isFunction(i3[2]) ? h2 = i3[2] : 3 === i3[2].length ? h2 = [1].concat(i3[2]) : 4 === i3[2].length && (h2 = i3[2]), l2 = i3[3], n2 = s.Z.providePoints3D(p2, [[0, 0, 0], [0, 0, 0]], r3, "line3d", ["point1", "point2"]), u2 = new t.Z.Line3D(p2, a2, h2, l2, o2), n2[0].F = function() {
      return u2.getPointCoords(s.Z.evaluate(u2.range[0]));
    }, n2[0].prepareUpdate().update(), c2 = n2[0], n2[1].F = function() {
      return u2.getPointCoords(s.Z.evaluate(u2.range[1]));
    }, n2[1].prepareUpdate().update(), d2 = n2[1]), u2.element2D = p2.create("segment", [c2.element2D, d2.element2D], o2), u2.addChild(u2.element2D), u2.inherits.push(u2.element2D), u2.element2D.setParents(u2), c2.addChild(u2), d2.addChild(u2), u2.point1 = c2, u2.point2 = d2, u2.update(), u2.element2D.prepareUpdate().update().updateRenderer(), u2;
  }, t.Z.registerElement("line3d", t.Z.createLine3D), t.Z.Plane3D = function(t2, e2, r3, o2, n2, a2, h2) {
    this.constructor(t2.board, h2, i2.Z.OBJECT_TYPE_PLANE3D, i2.Z.OBJECT_CLASS_3D), this.constructor3D(t2, "plane3d"), this.id = this.view.board.setId(this, "PL3D"), this.board.finalizeAdding(this), this.point = e2, this.direction1 = r3, this.direction2 = n2, this.range1 = o2 || [-1 / 0, 1 / 0], this.range2 = a2 || [-1 / 0, 1 / 0], this.vec1 = [0, 0, 0], this.vec2 = [0, 0, 0], this.grid = null, this.normal = [0, 0, 0], this.d = 0, this.updateNormal(), this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.Plane3D.prototype = new t.Z.GeometryElement(), s.Z.copyPrototypeMethods(t.Z.Plane3D, t.Z.GeometryElement3D, "constructor3D"), t.Z.extend(t.Z.Plane3D.prototype, { updateNormal: function() {
    var t2, e2;
    for (t2 = 0; t2 < 3; t2++)
      this.vec1[t2] = s.Z.evaluate(this.direction1[t2]), this.vec2[t2] = s.Z.evaluate(this.direction2[t2]);
    if (this.normal = o.Z.crossProduct(this.vec1, this.vec2), e2 = o.Z.norm(this.normal), Math.abs(e2) > o.Z.eps)
      for (t2 = 0; t2 < 3; t2++)
        this.normal[t2] /= e2;
    return this.d = o.Z.innerProduct(this.point.coords.slice(1), this.normal, 3), this;
  }, updateDataArray: function() {
    var t2, e2, i3, r3, n2, a2, h2, l2, c2, d2, p2, _2, f2, b2, g2 = ["xPlaneRear", "yPlaneRear", "zPlaneRear"], m2 = [], v2 = [0, 0, 0], Z2 = [0, 0, 0], C2 = [0, 0, 0], y2 = [0, 0, 0], P2 = this.view;
    if (this.dataX = [], this.dataY = [], this.updateNormal(), "axisplane3d" !== this.elType && P2.defaultAxes && s.Z.evaluate(this.range1[0]) === -1 / 0 && s.Z.evaluate(this.range1[1]) === 1 / 0 && s.Z.evaluate(this.range2[0]) === -1 / 0 && s.Z.evaluate(this.range2[1]) === 1 / 0) {
      for (d2 = 0; d2 < g2.length; d2++) {
        if (3 === (y2 = P2.intersectionPlanePlane(this, P2.defaultAxes[g2[d2]]))[0].length && 3 === y2[1].length) {
          for (c2 = 0; c2 < m2.length && !(u.Z.distance(y2[0], m2[c2][0], 3) < o.Z.eps && u.Z.distance(y2[1], m2[c2][1], 3) < o.Z.eps || u.Z.distance(y2[0], m2[c2][1], 3) < o.Z.eps && u.Z.distance(y2[1], m2[c2][0], 3) < o.Z.eps); c2++)
            ;
          c2 === m2.length && m2.push(y2.slice());
        }
        if ((y2 = [0, 0, 0])[d2] = P2.bbox3D[d2][1], l2 = o.Z.innerProduct(y2, P2.defaultAxes[g2[d2]].normal, 3), 3 === (y2 = P2.intersectionPlanePlane(this, P2.defaultAxes[g2[d2]], l2))[0].length && 3 === y2[1].length) {
          for (c2 = 0; c2 < m2.length && !(u.Z.distance(y2[0], m2[c2][0], 3) < o.Z.eps && u.Z.distance(y2[1], m2[c2][1], 3) < o.Z.eps || u.Z.distance(y2[0], m2[c2][1], 3) < o.Z.eps && u.Z.distance(y2[1], m2[c2][0], 3) < o.Z.eps); c2++)
            ;
          c2 === m2.length && m2.push(y2.slice());
        }
      }
      f2 = 0, c2 = 0;
      do {
        for (3 === (y2 = m2[f2][c2]).length && (n2 = P2.project3DTo2D(y2), this.dataX.push(n2[1]), this.dataY.push(n2[2])), c2 = (c2 + 1) % 2, y2 = m2[f2][c2], b2 = f2, d2 = 0; d2 < m2.length; d2++) {
          if (d2 !== f2 && u.Z.distance(y2, m2[d2][0]) < o.Z.eps) {
            f2 = d2, c2 = 0;
            break;
          }
          if (d2 !== f2 && u.Z.distance(y2, m2[d2][1]) < o.Z.eps) {
            f2 = d2, c2 = 1;
            break;
          }
        }
        if (f2 === b2) {
          console.log("Error: update plane3d: did not find next", f2);
          break;
        }
      } while (0 !== f2);
      n2 = P2.project3DTo2D(m2[0][0]), this.dataX.push(n2[1]), this.dataY.push(n2[2]);
    } else {
      for (t2 = s.Z.evaluate(this.range1[0]), e2 = s.Z.evaluate(this.range1[1]), i3 = s.Z.evaluate(this.range2[0]), r3 = s.Z.evaluate(this.range2[1]), C2 = this.point.coords.slice(1), v2 = this.vec1.slice(), Z2 = this.vec2.slice(), a2 = o.Z.norm(v2, 3), h2 = o.Z.norm(Z2, 3), c2 = 0; c2 < 3; c2++)
        v2[c2] /= a2, Z2[c2] /= h2;
      for (d2 = 0; d2 < 4; d2++) {
        switch (d2) {
          case 0:
            p2 = t2, _2 = i3;
            break;
          case 1:
            p2 = e2, _2 = i3;
            break;
          case 2:
            p2 = e2, _2 = r3;
            break;
          case 3:
            p2 = t2, _2 = r3;
        }
        for (c2 = 0; c2 < 3; c2++)
          y2[c2] = C2[c2] + p2 * v2[c2] + _2 * Z2[c2];
        n2 = P2.project3DTo2D(y2), this.dataX.push(n2[1]), this.dataY.push(n2[2]);
      }
      this.dataX.push(this.dataX[0]), this.dataY.push(this.dataY[0]);
    }
    return { X: this.dataX, Y: this.dataY };
  }, update: function() {
    return this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  } }), t.Z.createPlane3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2 = i3[0], c2 = i3[2], d2 = i3[3], u2 = i3[4] || [-1 / 0, 1 / 0], p2 = i3[5] || [-1 / 0, 1 / 0];
    return n2 = s.Z.providePoints3D(l2, [i3[1]], r3, "plane3d", ["point"])[0], o2 = s.Z.copyAttributes(r3, e2.options, "plane3d"), a2 = new t.Z.Plane3D(l2, n2, c2, u2, d2, p2, o2), n2.addChild(a2), a2.element2D = l2.create("curve", [[], []], o2), a2.element2D.updateDataArray = function() {
      var t2 = a2.updateDataArray();
      this.dataX = t2.X, this.dataY = t2.Y;
    }, a2.addChild(a2.element2D), a2.inherits.push(a2.element2D), a2.element2D.setParents(a2), o2 = s.Z.copyAttributes(r3.mesh3d, e2.options, "mesh3d"), Math.abs(a2.range1[0]) !== 1 / 0 && Math.abs(a2.range1[1]) !== 1 / 0 && Math.abs(a2.range2[0]) !== 1 / 0 && Math.abs(a2.range2[1]) !== 1 / 0 && (h2 = l2.create("mesh3d", [function() {
      return n2.coords;
    }, c2, u2, d2, p2], o2), a2.grid = h2, a2.addChild(h2), a2.inherits.push(h2), h2.setParents(a2)), a2.element2D.prepareUpdate().update(), e2.isSuspendedUpdate || a2.element2D.updateVisibility().updateRenderer(), a2;
  }, t.Z.registerElement("plane3d", t.Z.createPlane3D), t.Z.Surface3D = function(t2, e2, r3, o2, n2, a2, h2, l2) {
    this.constructor(t2.board, l2, i2.Z.OBJECT_TYPE_SURFACE3D, i2.Z.OBJECT_CLASS_3D), this.constructor3D(t2, "surface3d"), this.id = this.view.board.setId(this, "S3D"), this.board.finalizeAdding(this), this.F = e2, this.X = r3, this.Y = o2, this.Z = n2, null !== this.F && (this.X = function(t3, e3) {
      return this.F(t3, e3)[0];
    }, this.Y = function(t3, e3) {
      return this.F(t3, e3)[1];
    }, this.Z = function(t3, e3) {
      return this.F(t3, e3)[2];
    }), this.range_u = a2, this.range_v = h2, this.methodMap = s.Z.deepCopy(this.methodMap, {});
  }, t.Z.Surface3D.prototype = new t.Z.GeometryElement(), s.Z.copyPrototypeMethods(t.Z.Surface3D, t.Z.GeometryElement3D, "constructor3D"), t.Z.extend(t.Z.Surface3D.prototype, { updateDataArray: function() {
    var t2, e2, i3 = s.Z.evaluate(this.visProp.stepsu), r3 = s.Z.evaluate(this.visProp.stepsv), o2 = s.Z.evaluate(this.range_u), n2 = s.Z.evaluate(this.range_v);
    return t2 = null !== this.F ? this.F : [this.X, this.Y, this.Z], { X: (e2 = this.view.getMesh(t2, o2.concat([i3]), n2.concat([r3])))[0], Y: e2[1] };
  }, update: function() {
    return this;
  }, updateRenderer: function() {
    return this.needsUpdate = false, this;
  } }), t.Z.createParametricSurface3D = function(e2, i3, r3) {
    var o2, n2, a2, h2, l2, c2, d2, u2, p2 = i3[0];
    return 4 === i3.length ? (o2 = i3[1], l2 = i3[2], c2 = i3[3], n2 = null, a2 = null, h2 = null) : (n2 = i3[1], a2 = i3[2], h2 = i3[3], l2 = i3[4], c2 = i3[5], o2 = null), d2 = s.Z.copyAttributes(r3, e2.options, "surface3d"), (u2 = new t.Z.Surface3D(p2, o2, n2, a2, h2, l2, c2, d2)).element2D = p2.create("curve", [[], []], d2), u2.element2D.updateDataArray = function() {
      var t2 = u2.updateDataArray();
      this.dataX = t2.X, this.dataY = t2.Y;
    }, u2.addChild(u2.element2D), u2.inherits.push(u2.element2D), u2.element2D.setParents(u2), u2.element2D.prepareUpdate().update(), e2.isSuspendedUpdate || u2.element2D.updateVisibility().updateRenderer(), u2;
  }, t.Z.registerElement("parametricsurface3d", t.Z.createParametricSurface3D), t.Z.createFunctiongraph3D = function(t2, e2, i3) {
    var s2 = e2[0], r3 = e2[1], o2 = e2[2], n2 = e2[3];
    return s2.create("parametricsurface3d", [function(t3, e3) {
      return t3;
    }, function(t3, e3) {
      return e3;
    }, r3, o2, n2], i3);
  }, t.Z.registerElement("functiongraph3d", t.Z.createFunctiongraph3D);
  const et = t.Z.COORDS_BY_SCREEN, it = t.Z.COORDS_BY_USER, st = t.Z.Dump, rt = t.Z.JSXGraph, ot = t.Z.Math, nt = t.Z.Options, at = t.Z.boards, ht = t.Z.elements, lt = t.Z.palette, ct = t.Z.paletteWong, dt = t.Z.Board, ut = t.Z.Chart, pt = t.Z.Circle, _t = t.Z.Complex, ft = t.Z.Composition, bt = t.Z.Coords, gt = t.Z.CoordsElement, mt = t.Z.Curve, vt = t.Z.GeometryElement, Zt = t.Z.Group, Ct = t.Z.Image, yt = t.Z.JessieCode, Pt = t.Z.Line, Et = t.Z.Point, Ot = t.Z.Polygon, xt = t.Z.Text, wt = t.Z.Ticks, St = t.Z.Transformation, Tt = t.Z.Turtle, Mt = t.Z.View3D, Nt = t.Z.LMS2rgb, At = t.Z.addEvent, kt = t.Z.autoDigits, Rt = t.Z.autoHighlight, Dt = t.Z.bind, Lt = t.Z.capitalize, Bt = t.Z.clearVisPropOld, It = t.Z.clone, Yt = t.Z.cloneAndCopy, jt = t.Z.cmpArrays, Xt = t.Z.coordsArrayToMatrix, Ut = t.Z.copyAttributes, Ft = t.Z.createEvalFunction, Jt = t.Z.createFunction, Gt = t.Z.createHTMLSlider, zt = t.Z.debug, Ht = t.Z.debugInt, Wt = t.Z.debugLine, Vt = t.Z.debugWST, $t = t.Z.deepCopy, Kt = t.Z.def, qt = t.Z.deprecated, Qt = t.Z.eliminateDuplicates, te = t.Z.escapeHTML, ee = t.Z.evalSlider, ie = t.Z.evaluate, se = t.Z.filterElements, re = t.Z.getBoardByContainerId, oe = t.Z.getCSSTransformMatrix, ne = t.Z.getCSSTransform, ae = t.Z.getDimensions, he = t.Z.getOffset, le = t.Z.getPosition, ce = t.Z.getProp, de = t.Z.hex2rgb, ue = t.Z.hsv2rgb, pe = t.Z.isAndroid, _e = t.Z.isApple, fe = t.Z.isArray, be = t.Z.isInArray, ge = t.Z.isInObject, me = t.Z.isMetroApp, ve = t.Z.isMozilla, Ze = t.Z.isName, Ce = t.Z.isNode, ye = t.Z.isNumber, Pe = t.Z.isObject, Ee = t.Z.isPointType, Oe = t.Z.isString, xe = t.Z.isTouchDevice, we = t.Z.isTransformationOrArray, Se = t.Z.isWebWorker, Te = t.Z.isWebkitAndroid, Me = t.Z.isWebkitApple, Ne = t.Z.keys, Ae = t.Z.merge, ke = t.Z.normalizePointFace, Re = t.Z.providePoints, De = t.Z.registerElement, Le = t.Z.registerReader, Be = t.Z.removeAllEvents, Ie = t.Z.removeElementFromArray, Ye = t.Z.removeEvent, je = t.Z.rgb2LMS, Xe = t.Z.rgb2bw, Ue = t.Z.rgb2cb, Fe = t.Z.rgb2css, Je = t.Z.rgb2hex, Ge = t.Z.rgb2hsv, ze = t.Z.rgbParser, He = t.Z.rgba2rgbo, We = t.Z.rgbo2rgba, Ve = t.Z.sanitizeHTML, $e = t.Z.shortcut, Ke = t.Z.str2Bool, qe = t.Z.supportsCanvas, Qe = t.Z.supportsPointerEvents, ti = t.Z.supportsSVG, ei = t.Z.supportsVML, ii = t.Z.swap, si = t.Z.timedChunk, ri = t.Z.toFixed, oi = t.Z.toFullscreen, ni = t.Z.toJSON, ai = t.Z.trim, hi = t.Z.trimNumber, li = t.Z.truncate, ci = t.Z.unescapeHTML, di = t.Z.uniqueArray, ui = t.Z.useBlackWhiteOptions, pi = t.Z.useStandardOptions, _i = t.Z.warn;
  e.Z.isBrowser ? window.JXG = t.Z : e.Z.isWebWorker() && (self.JXG = t.Z);
  const fi = t.Z;
})();
var __webpack_exports__default = __webpack_exports__.ZP;
const BoardContext = reactExports.createContext();
const graph = React.memo(function Graph(props) {
  let { name, id, SVs, children, actions, callAction } = useDoenetRenderer(props);
  const [board, setBoard] = reactExports.useState(null);
  const previousDimensions = reactExports.useRef(null);
  const previousBoundingbox = reactExports.useRef(null);
  const xaxis = reactExports.useRef(null);
  const yaxis = reactExports.useRef(null);
  const settingBoundingBox = reactExports.useRef(false);
  const boardJustInitialized = reactExports.useRef(false);
  const previousShowNavigation = reactExports.useRef(false);
  let previousXaxisWithLabel = reactExports.useRef(null);
  let previousYaxisWithLabel = reactExports.useRef(null);
  let showNavigation = SVs.showNavigation && !SVs.fixAxes;
  let onChangeVisibility = (isVisible) => {
    callAction({
      action: actions.recordVisibilityChange,
      args: { isVisible }
    });
  };
  reactExports.useEffect(() => {
    if (SVs.haveGraphParent) {
      return;
    }
    return () => {
      callAction({
        action: actions.recordVisibilityChange,
        args: { isVisible: false }
      });
    };
  }, []);
  reactExports.useEffect(() => {
    if (SVs.haveGraphParent) {
      return;
    }
    let boundingbox = [SVs.xmin, SVs.ymax, SVs.xmax, SVs.ymin];
    previousBoundingbox.current = boundingbox;
    __webpack_exports__default.Options.layer.numlayers = 100;
    __webpack_exports__default.Options.navbar.highlightFillColor = "var(--canvastext)";
    __webpack_exports__default.Options.navbar.strokeColor = "var(--canvastext)";
    let haveFixedGrid = false;
    if (Array.isArray(SVs.grid)) {
      haveFixedGrid = true;
      __webpack_exports__default.Options.grid.gridX = SVs.grid[0];
      __webpack_exports__default.Options.grid.gridY = SVs.grid[1];
    }
    let newBoard = window.JXG.JSXGraph.initBoard(id, {
      boundingbox,
      axis: false,
      showCopyright: false,
      showNavigation: false,
      // will add navigation buttons later so can style them
      // keepAspectRatio: SVs.identicalAxisScales,
      zoom: { wheel: !SVs.fixAxes },
      pan: { enabled: !SVs.fixAxes },
      grid: haveFixedGrid
    });
    newBoard.itemsRenderedLowQuality = {};
    newBoard.on("boundingbox", () => {
      if (!settingBoundingBox.current) {
        let newBoundingbox = newBoard.getBoundingBox();
        let [xmin, ymax, xmax, ymin] = newBoundingbox;
        let xscale = Math.abs(xmax - xmin);
        let yscale = Math.abs(ymax - ymin);
        let diffs = newBoundingbox.map(
          (v, i2) => Math.abs(v - previousBoundingbox.current[i2])
        );
        if (Math.max(
          diffs[0] / xscale,
          diffs[1] / yscale,
          diffs[2] / xscale,
          diffs[3] / yscale
        ) > 1e-12) {
          previousBoundingbox.current = newBoundingbox;
          callAction({
            action: actions.changeAxisLimits,
            args: { xmin, xmax, ymin, ymax }
          });
        }
      }
    });
    setBoard(newBoard);
    previousDimensions.current = {
      width: parseFloat(sizeToCSS(SVs.width)),
      aspectRatio: SVs.aspectRatio
    };
    if (SVs.displayXAxis) {
      createXAxis(newBoard);
    }
    if (SVs.displayYAxis) {
      createYAxis(newBoard);
    }
    boardJustInitialized.current = true;
    previousShowNavigation.current = showNavigation;
    function keyFocusOutListener(evt) {
      var _a;
      let id_node = evt.target.id;
      if (id_node === "") {
        return false;
      }
      let el_id = id_node.replace(id + "_", "");
      let el = newBoard.select(el_id);
      (_a = el.triggerEventHandlers) == null ? void 0 : _a.call(el, ["keyfocusout"], [evt]);
    }
    newBoard.containerObj.addEventListener("focusout", keyFocusOutListener);
    function keyDownListener(evt) {
      var _a;
      let id_node = evt.target.id;
      if (id_node === "") {
        return false;
      }
      let el_id = id_node.replace(id + "_", "");
      let el = newBoard.select(el_id);
      (_a = el.triggerEventHandlers) == null ? void 0 : _a.call(el, ["keydown"], [evt]);
    }
    newBoard.containerObj.addEventListener("keydown", keyDownListener);
    return () => {
      newBoard.off("boundingbox");
    };
  }, []);
  reactExports.useEffect(() => {
    if (board && showNavigation) {
      addNavigationButtons();
    }
  }, [board]);
  if (SVs.haveGraphParent) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("a", { name: id }),
      children
    ] });
  }
  const divStyle = {
    width: sizeToCSS(SVs.width),
    aspectRatio: String(SVs.aspectRatio),
    maxWidth: "100%"
  };
  let outerStyle = {};
  if (SVs.hidden) {
    divStyle.display = "none";
  } else if (SVs.displayMode === "inline") {
    outerStyle = { display: "inline-block", verticalAlign: "middle" };
  } else {
    outerStyle = { display: "flex", justifyContent: SVs.horizontalAlign };
  }
  if (SVs.showBorder) {
    divStyle.border = "2px solid var(--canvastext)";
  } else {
    divStyle.border = "none";
  }
  divStyle.marginBottom = "12px";
  divStyle.marginTop = "12px";
  divStyle.backgroundColor = "var(--canvas)";
  divStyle.color = "var(--canvastext)";
  if (!board) {
    return /* @__PURE__ */ jsx(VisibilitySensor, { partialVisibility: true, onChange: onChangeVisibility, children: /* @__PURE__ */ jsxs("div", { style: outerStyle, children: [
      /* @__PURE__ */ jsx("a", { name: id }),
      /* @__PURE__ */ jsx("div", { id, className: "jxgbox", style: divStyle })
    ] }) });
  }
  if (boardJustInitialized.current) {
    boardJustInitialized.current = false;
  } else {
    if (Array.isArray(SVs.grid)) {
      let gridParamsChanged = __webpack_exports__default.Options.grid.gridX !== SVs.grid[0] || __webpack_exports__default.Options.grid.gridY !== SVs.grid[1];
      if (gridParamsChanged) {
        __webpack_exports__default.Options.grid.gridX = SVs.grid[0];
        __webpack_exports__default.Options.grid.gridY = SVs.grid[1];
        if (board.grids.length > 0) {
          board.removeObject(board.grids[0]);
          board.grids = [];
        }
      }
      if (board.grids.length === 0) {
        board.create("grid", [], { gridX: SVs.grid[0], gridY: SVs.grid[1] });
      }
    } else {
      if (board.grids.length > 0) {
        board.removeObject(board.grids[0]);
        board.grids = [];
      }
    }
    if (SVs.grid === "dense") {
      if (xaxis.current) {
        xaxis.current.defaultTicks.setAttribute({ majorHeight: -1 });
        xaxis.current.defaultTicks.setAttribute({ minorHeight: -1 });
      }
      if (yaxis.current) {
        yaxis.current.defaultTicks.setAttribute({ majorHeight: -1 });
        yaxis.current.defaultTicks.setAttribute({ minorHeight: -1 });
      }
    } else if (SVs.grid === "medium") {
      if (xaxis.current) {
        xaxis.current.defaultTicks.setAttribute({ majorHeight: -1 });
        xaxis.current.defaultTicks.setAttribute({ minorHeight: 10 });
      }
      if (yaxis.current) {
        yaxis.current.defaultTicks.setAttribute({ majorHeight: -1 });
        yaxis.current.defaultTicks.setAttribute({ minorHeight: 10 });
      }
    } else {
      if (xaxis.current) {
        xaxis.current.defaultTicks.setAttribute({ majorHeight: 12 });
        xaxis.current.defaultTicks.setAttribute({ minorHeight: 10 });
      }
      if (yaxis.current) {
        yaxis.current.defaultTicks.setAttribute({ majorHeight: 12 });
        yaxis.current.defaultTicks.setAttribute({ minorHeight: 10 });
      }
    }
    let displayXAxisChanged = SVs.displayXAxis ? !Boolean(xaxis.current) : Boolean(xaxis.current);
    let displayYAxisChanged = SVs.displayYAxis ? !Boolean(yaxis.current) : Boolean(yaxis.current);
    if (displayYAxisChanged && !displayXAxisChanged && SVs.displayXAxis) {
      board.removeObject(xaxis.current);
      xaxis.current = null;
    }
    if (displayXAxisChanged && !displayYAxisChanged && SVs.displayYAxis) {
      board.removeObject(yaxis.current);
      yaxis.current = null;
    }
    if (SVs.displayXAxis) {
      if (xaxis.current) {
        let xaxisWithLabel = Boolean(SVs.xlabel);
        if (xaxisWithLabel !== previousXaxisWithLabel.current) {
          xaxis.current.setAttribute({ withlabel: xaxisWithLabel });
          previousXaxisWithLabel.current = xaxisWithLabel;
        }
        xaxis.current.name = SVs.xlabel;
        xaxis.current.defaultTicks.setAttribute({
          drawLabels: SVs.displayXAxisTickLabels
        });
        if (xaxis.current.hasLabel) {
          let position = "rt";
          let offset = [5, 10];
          let anchorx = "right";
          if (SVs.xlabelPosition === "left") {
            position = "lft";
            anchorx = "left";
            offset = [-5, 10];
          }
          xaxis.current.label.visProp.position = position;
          xaxis.current.label.visProp.anchorx = anchorx;
          xaxis.current.label.visProp.offset = offset;
          xaxis.current.label.needsUpdate = true;
          xaxis.current.label.fullUpdate();
        }
      } else {
        createXAxis(board);
      }
    } else if (xaxis.current) {
      board.removeObject(xaxis.current);
      xaxis.current = null;
    }
    if (SVs.displayYAxis) {
      if (yaxis.current) {
        let yaxisWithLabel = Boolean(SVs.ylabel);
        if (yaxisWithLabel !== previousYaxisWithLabel.current) {
          yaxis.current.setAttribute({ withlabel: yaxisWithLabel });
          previousYaxisWithLabel.current = yaxisWithLabel;
        }
        yaxis.current.name = SVs.ylabel;
        yaxis.current.defaultTicks.setAttribute({
          drawLabels: SVs.displayYAxisTickLabels
        });
        if (yaxis.current.hasLabel) {
          let position = "rt";
          let offset = [-10, -5];
          let anchorx = "right";
          if (SVs.ylabelPosition === "bottom") {
            position = "lft";
            offset[1] = 5;
          }
          if (SVs.ylabelAlignment === "right") {
            anchorx = "left";
            offset[0] = 10;
          }
          yaxis.current.label.visProp.position = position;
          yaxis.current.label.visProp.offset = offset;
          yaxis.current.label.visProp.anchorx = anchorx;
          yaxis.current.label.needsUpdate = true;
          yaxis.current.label.fullUpdate();
        }
      } else {
        createYAxis(board);
      }
    } else if (yaxis.current) {
      board.removeObject(yaxis.current);
      yaxis.current = null;
    }
    if (showNavigation) {
      if (!previousShowNavigation.current) {
        addNavigationButtons();
        previousShowNavigation.current = true;
      }
    } else {
      if (previousShowNavigation.current) {
        removeNavigationButtons();
        previousShowNavigation.current = false;
      }
    }
    let currentDimensions = {
      width: parseFloat(sizeToCSS(SVs.width)),
      aspectRatio: SVs.aspectRatio
    };
    if ((currentDimensions.width !== previousDimensions.current.width || currentDimensions.aspectRatio !== previousDimensions.current.aspectRatio) && Number.isFinite(currentDimensions.width) && Number.isFinite(currentDimensions.aspectRatio)) {
      previousDimensions.current = currentDimensions;
    }
    let boundingbox = [SVs.xmin, SVs.ymax, SVs.xmax, SVs.ymin];
    if (boundingbox.some((v, i2) => v !== previousBoundingbox.current[i2])) {
      settingBoundingBox.current = true;
      board.setBoundingBox(boundingbox);
      settingBoundingBox.current = false;
      board.fullUpdate();
      if (board.updateQuality === board.BOARD_QUALITY_LOW) {
        board.itemsRenderedLowQuality[id] = board;
      }
      previousBoundingbox.current = boundingbox;
    }
  }
  return /* @__PURE__ */ jsx(VisibilitySensor, { partialVisibility: true, onChange: onChangeVisibility, children: /* @__PURE__ */ jsxs("div", { style: outerStyle, children: [
    /* @__PURE__ */ jsx("a", { name: id }),
    /* @__PURE__ */ jsx("div", { id, className: "jxgbox", style: divStyle }),
    /* @__PURE__ */ jsx(BoardContext.Provider, { value: board, children })
  ] }) });
  function createYAxis(theBoard) {
    let yaxisOptions = { highlight: false, fixed: true };
    if (SVs.ylabel) {
      let position = "rt";
      let offset = [-10, -5];
      let anchorx = "right";
      if (SVs.ylabelPosition === "bottom") {
        position = "lft";
        offset[1] = 5;
      }
      if (SVs.ylabelAlignment === "right") {
        anchorx = "left";
        offset[0] = 10;
      }
      yaxisOptions.name = SVs.ylabel;
      yaxisOptions.withLabel = true;
      yaxisOptions.label = {
        position,
        offset,
        anchorx,
        strokeColor: "var(--canvastext)",
        highlight: false
      };
      if (SVs.ylabelHasLatex) {
        yaxisOptions.label.useMathJax = true;
      }
    }
    previousYaxisWithLabel.current = Boolean(SVs.ylabel);
    yaxisOptions.strokeColor = "var(--canvastext)";
    yaxisOptions.highlight = false;
    yaxisOptions.ticks = {
      ticksDistance: 2,
      label: {
        offset: [12, -2],
        layer: 2,
        strokeColor: "var(--canvastext)",
        highlightStrokeColor: "var(--canvastext)",
        highlightStrokeOpacity: 1
      },
      strokeColor: "var(--canvastext)",
      strokeOpacity: 0.5,
      // minorTicks: 4,
      precision: 4,
      drawLabels: SVs.displayYAxisTickLabels
    };
    if (SVs.yTickScaleFactor !== null) {
      let yTickScaleFactor = Context.fromAst(SVs.yTickScaleFactor);
      let scale = yTickScaleFactor.evaluate_to_constant();
      if (scale > 0) {
        let scaleSymbol = yTickScaleFactor.toString();
        yaxisOptions.ticks.scale = scale;
        yaxisOptions.ticks.scaleSymbol = scaleSymbol;
      }
    }
    if (SVs.grid === "dense") {
      yaxisOptions.ticks.majorHeight = -1;
      yaxisOptions.ticks.minorHeight = -1;
    } else if (SVs.grid === "medium") {
      yaxisOptions.ticks.majorHeight = -1;
      yaxisOptions.ticks.minorHeight = 10;
    } else {
      yaxisOptions.ticks.majorHeight = 12;
      yaxisOptions.ticks.minorHeight = 10;
    }
    if (!SVs.displayXAxis) {
      yaxisOptions.ticks.drawZero = true;
    }
    theBoard.suspendUpdate();
    yaxis.current = theBoard.create(
      "axis",
      [
        [0, 0],
        [0, 1]
      ],
      yaxisOptions
    );
    yaxis.current.defaultTicks.ticksFunction = function() {
      var delta, b, dist;
      b = this.getLowerAndUpperBounds(
        this.getZeroCoordinates(),
        "ticksdistance"
      );
      dist = b.upper - b.lower;
      delta = Math.pow(10, Math.floor(Math.log(0.2 * dist) / Math.LN10));
      if (dist <= 6 * delta) {
        delta *= 0.5;
      }
      return delta;
    };
    yaxis.current.defaultTicks.generateEquidistantTicks = function(coordsZero, bounds) {
      var tickPosition, eps2 = 1e-6, deltas, ticksDelta = this.equidistant ? this.ticksFunction(1) : this.ticksDelta, ev_mt = 4;
      this.visProp.minorticks = 4;
      deltas = this.getXandYdeltas();
      ticksDelta *= this.visProp.scale;
      if (this.minTicksDistance > 1e-6) {
        ticksDelta = this.adjustTickDistance(ticksDelta, coordsZero, deltas);
        let mag = 10 ** Math.floor(Math.log10(ticksDelta)) * this.visProp.scale;
        if (Math.abs(ticksDelta / mag - 2) < 1e-14) {
          ev_mt = 3;
          this.visProp.minorticks = 3;
        }
        ticksDelta /= ev_mt + 1;
      }
      this.ticksDelta = ticksDelta;
      if (ticksDelta < 1e-6) {
        return;
      }
      tickPosition = 0;
      if (!this.visProp.drawzero) {
        tickPosition = ticksDelta;
      }
      while (tickPosition <= bounds.upper + eps2) {
        if (tickPosition >= bounds.lower - eps2) {
          this.processTickPosition(
            coordsZero,
            tickPosition,
            ticksDelta,
            deltas
          );
        }
        tickPosition += ticksDelta;
        if (bounds.upper - tickPosition > ticksDelta * 1e4) {
          break;
        }
      }
      tickPosition = -ticksDelta;
      while (tickPosition >= bounds.lower - eps2) {
        if (tickPosition <= bounds.upper + eps2) {
          this.processTickPosition(
            coordsZero,
            tickPosition,
            ticksDelta,
            deltas
          );
        }
        tickPosition -= ticksDelta;
        if (tickPosition - bounds.lower > ticksDelta * 1e4) {
          break;
        }
      }
    };
    theBoard.unsuspendUpdate();
  }
  function createXAxis(theBoard) {
    let xaxisOptions = { highlight: false, fixed: true };
    if (SVs.xlabel) {
      let position = "rt";
      let offset = [5, 10];
      let anchorx = "right";
      if (SVs.xlabelPosition === "left") {
        position = "lft";
        anchorx = "left";
        offset = [-5, 10];
      }
      xaxisOptions.name = SVs.xlabel;
      xaxisOptions.withLabel = true;
      xaxisOptions.label = {
        position,
        offset,
        anchorx,
        strokeColor: "var(--canvastext)",
        highlight: false
      };
      if (SVs.xlabelHasLatex) {
        xaxisOptions.label.useMathJax = true;
      }
    }
    previousXaxisWithLabel.current = Boolean(SVs.xlabel);
    xaxisOptions.ticks = {
      ticksDistance: 2,
      label: {
        offset: [-5, -15],
        layer: 2,
        strokeColor: "var(--canvastext)",
        highlightStrokeColor: "var(--canvastext)",
        highlightStrokeOpacity: 1
      },
      strokeColor: "var(--canvastext)",
      strokeOpacity: 0.5,
      // minorTicks: 4,
      precision: 4,
      drawLabels: SVs.displayXAxisTickLabels
    };
    if (SVs.xTickScaleFactor !== null) {
      let xTickScaleFactor = Context.fromAst(SVs.xTickScaleFactor);
      let scale = xTickScaleFactor.evaluate_to_constant();
      if (scale > 0) {
        let scaleSymbol = xTickScaleFactor.toString();
        xaxisOptions.ticks.scale = scale;
        xaxisOptions.ticks.scaleSymbol = scaleSymbol;
      }
    }
    xaxisOptions.strokeColor = "var(--canvastext)";
    xaxisOptions.highlight = false;
    if (SVs.grid === "dense") {
      xaxisOptions.ticks.majorHeight = -1;
      xaxisOptions.ticks.minorHeight = -1;
    } else if (SVs.grid === "medium") {
      xaxisOptions.ticks.majorHeight = -1;
      xaxisOptions.ticks.minorHeight = 10;
    } else {
      xaxisOptions.ticks.majorHeight = 12;
      xaxisOptions.ticks.minorHeight = 10;
    }
    if (!SVs.displayYAxis) {
      xaxisOptions.ticks.drawZero = true;
    }
    theBoard.suspendUpdate();
    xaxis.current = theBoard.create(
      "axis",
      [
        [0, 0],
        [1, 0]
      ],
      xaxisOptions
    );
    xaxis.current.defaultTicks.ticksFunction = function() {
      var delta, b, dist;
      b = this.getLowerAndUpperBounds(
        this.getZeroCoordinates(),
        "ticksdistance"
      );
      dist = b.upper - b.lower;
      delta = Math.pow(10, Math.floor(Math.log(0.2 * dist) / Math.LN10));
      if (dist <= 6 * delta) {
        delta *= 0.5;
      }
      return delta;
    };
    xaxis.current.defaultTicks.generateEquidistantTicks = function(coordsZero, bounds) {
      this.minTicksDistance = 2 * Math.max(
        2.5,
        Math.log10(Math.abs(bounds.lower)),
        Math.log10(Math.abs(bounds.upper))
      );
      var tickPosition, eps2 = 1e-6, deltas, ticksDelta = this.equidistant ? this.ticksFunction(1) : this.ticksDelta, ev_mt = 4;
      this.visProp.minorticks = 4;
      deltas = this.getXandYdeltas();
      ticksDelta *= this.visProp.scale;
      if (this.minTicksDistance > 1e-6) {
        ticksDelta = this.adjustTickDistance(ticksDelta, coordsZero, deltas);
        let mag = 10 ** Math.floor(Math.log10(ticksDelta)) * this.visProp.scale;
        if (Math.abs(ticksDelta / mag - 2) < 1e-14) {
          ev_mt = 3;
          this.visProp.minorticks = 3;
        }
        ticksDelta /= ev_mt + 1;
      }
      this.ticksDelta = ticksDelta;
      if (ticksDelta < 1e-6) {
        return;
      }
      tickPosition = 0;
      if (!this.visProp.drawzero) {
        tickPosition = ticksDelta;
      }
      while (tickPosition <= bounds.upper + eps2) {
        if (tickPosition >= bounds.lower - eps2) {
          this.processTickPosition(
            coordsZero,
            tickPosition,
            ticksDelta,
            deltas
          );
        }
        tickPosition += ticksDelta;
        if (bounds.upper - tickPosition > ticksDelta * 1e4) {
          break;
        }
      }
      tickPosition = -ticksDelta;
      while (tickPosition >= bounds.lower - eps2) {
        if (tickPosition <= bounds.upper + eps2) {
          this.processTickPosition(
            coordsZero,
            tickPosition,
            ticksDelta,
            deltas
          );
        }
        tickPosition -= ticksDelta;
        if (tickPosition - bounds.lower > ticksDelta * 1e4) {
          break;
        }
      }
    };
    theBoard.unsuspendUpdate();
  }
  function addNavigationButtons() {
    let navigationBar = document.querySelector(
      "#" + cesc(id) + `_navigationbar`
    );
    let addEvent = function(obj, type, fn) {
      var el = function() {
        return fn.apply(board, arguments);
      };
      board["x_internal" + type] = board["x_internal" + type] || [];
      board["x_internal" + type].push(el);
      obj.addEventListener(type, el, false);
    };
    let cancelbubble = function(e) {
      if (!e) {
        e = window.event;
      }
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    };
    let createButton = function(label, handler) {
      var button;
      button = document.createElement("span");
      navigationBar.appendChild(button);
      button.setAttribute("style", "color: var(--canvastext); opacity: 0.7");
      let text_node = document.createTextNode(label);
      button.appendChild(text_node);
      button.style.paddingLeft = "7px";
      button.style.paddingRight = "7px";
      if (button.classList !== void 0) {
        button.classList.add("JXG_navigation_button");
      }
      addEvent(
        button,
        "click",
        function(e) {
          handler.bind(board)();
          return false;
        }
      );
      addEvent(button, "mouseup", cancelbubble);
      addEvent(button, "mousedown", cancelbubble);
      addEvent(button, "touchend", cancelbubble);
      addEvent(button, "touchstart", cancelbubble);
    };
    if (board.attr.showzoom) {
      createButton("", board.zoomOut);
      createButton("o", board.zoom100);
      createButton("+", board.zoomIn);
    }
    createButton("", board.clickLeftArrow);
    createButton("", board.clickUpArrow);
    createButton("", board.clickDownArrow);
    createButton("", board.clickRightArrow);
  }
  function removeNavigationButtons() {
    for (let i2 = 7; i2 >= 1; i2--) {
      let button = document.querySelector(
        "#" + cesc(id) + `_navigationbar > :first-child`
      );
      button.remove();
    }
    board.internalclick = [];
    board.internalmousedown = [];
    board.internalmouseup = [];
    board.internaltouchend = [];
    board.internaltouchstart = [];
  }
});
let tempCounter = 0;
const BASE_LAYER_OFFSET = tempCounter++;
const IMAGE_LAYER_OFFSET = tempCounter++;
const LINE_LAYER_OFFSET = tempCounter++;
const VERTEX_LAYER_OFFSET = tempCounter++;
const CONTROL_POINT_LAYER_OFFSET = tempCounter++;
const POINT_LAYER_OFFSET = tempCounter++;
const TEXT_LAYER_OFFSET = tempCounter++;
export {
  BASE_LAYER_OFFSET,
  BoardContext,
  CONTROL_POINT_LAYER_OFFSET,
  IMAGE_LAYER_OFFSET,
  LINE_LAYER_OFFSET,
  POINT_LAYER_OFFSET,
  TEXT_LAYER_OFFSET,
  VERTEX_LAYER_OFFSET,
  graph as default
};
